// Known Errors
// AngularJs is blocking template html from loading because it is insecure
// maybe other stuff, will find out later

// AngularJs
/*
 AngularJS v1.7.8
 (c) 2010-2018 Google, Inc. http://angularjs.org
 License: MIT
*/
(function (C) {
    'use strict'; function re(a) { if (D(a)) w(a.objectMaxDepth) && (Wb.objectMaxDepth = Xb(a.objectMaxDepth) ? a.objectMaxDepth : NaN), w(a.urlErrorParamsEnabled) && Ga(a.urlErrorParamsEnabled) && (Wb.urlErrorParamsEnabled = a.urlErrorParamsEnabled); else return Wb } function Xb(a) { return W(a) && 0 < a } function F(a, b) {
        b = b || Error; return function () {
            var d = arguments[0], c; c = "[" + (a ? a + ":" : "") + d + "] http://errors.angularjs.org/1.7.8/" + (a ? a + "/" : "") + d; for (d = 1; d < arguments.length; d++) {
                c = c + (1 == d ? "?" : "&") + "p" + (d - 1) + "="; var e = encodeURIComponent,
                    f; f = arguments[d]; f = "function" == typeof f ? f.toString().replace(/ \{[\s\S]*$/, "") : "undefined" == typeof f ? "undefined" : "string" != typeof f ? JSON.stringify(f) : f; c += e(f)
            } return new b(c)
        }
    } function ya(a) { if (null == a || $a(a)) return !1; if (H(a) || A(a) || x && a instanceof x) return !0; var b = "length" in Object(a) && a.length; return W(b) && (0 <= b && b - 1 in a || "function" === typeof a.item) } function r(a, b, d) {
        var c, e; if (a) if (B(a)) for (c in a) "prototype" !== c && "length" !== c && "name" !== c && a.hasOwnProperty(c) && b.call(d, a[c], c, a); else if (H(a) ||
            ya(a)) { var f = "object" !== typeof a; c = 0; for (e = a.length; c < e; c++)(f || c in a) && b.call(d, a[c], c, a) } else if (a.forEach && a.forEach !== r) a.forEach(b, d, a); else if (Nc(a)) for (c in a) b.call(d, a[c], c, a); else if ("function" === typeof a.hasOwnProperty) for (c in a) a.hasOwnProperty(c) && b.call(d, a[c], c, a); else for (c in a) ta.call(a, c) && b.call(d, a[c], c, a); return a
    } function Oc(a, b, d) { for (var c = Object.keys(a).sort(), e = 0; e < c.length; e++)b.call(d, a[c[e]], c[e]); return c } function Yb(a) { return function (b, d) { a(d, b) } } function se() { return ++pb }
    function Zb(a, b, d) { for (var c = a.$$hashKey, e = 0, f = b.length; e < f; ++e) { var g = b[e]; if (D(g) || B(g)) for (var k = Object.keys(g), h = 0, l = k.length; h < l; h++) { var m = k[h], p = g[m]; d && D(p) ? ha(p) ? a[m] = new Date(p.valueOf()) : ab(p) ? a[m] = new RegExp(p) : p.nodeName ? a[m] = p.cloneNode(!0) : $b(p) ? a[m] = p.clone() : (D(a[m]) || (a[m] = H(p) ? [] : {}), Zb(a[m], [p], !0)) : a[m] = p } } c ? a.$$hashKey = c : delete a.$$hashKey; return a } function S(a) { return Zb(a, Ha.call(arguments, 1), !1) } function te(a) { return Zb(a, Ha.call(arguments, 1), !0) } function fa(a) {
        return parseInt(a,
            10)
    } function ac(a, b) { return S(Object.create(a), b) } function E() { } function Ta(a) { return a } function ia(a) { return function () { return a } } function bc(a) { return B(a.toString) && a.toString !== la } function z(a) { return "undefined" === typeof a } function w(a) { return "undefined" !== typeof a } function D(a) { return null !== a && "object" === typeof a } function Nc(a) { return null !== a && "object" === typeof a && !Pc(a) } function A(a) { return "string" === typeof a } function W(a) { return "number" === typeof a } function ha(a) { return "[object Date]" === la.call(a) }
    function H(a) { return Array.isArray(a) || a instanceof Array } function cc(a) { switch (la.call(a)) { case "[object Error]": return !0; case "[object Exception]": return !0; case "[object DOMException]": return !0; default: return a instanceof Error } } function B(a) { return "function" === typeof a } function ab(a) { return "[object RegExp]" === la.call(a) } function $a(a) { return a && a.window === a } function bb(a) { return a && a.$evalAsync && a.$watch } function Ga(a) { return "boolean" === typeof a } function ue(a) { return a && W(a.length) && ve.test(la.call(a)) }
    function $b(a) { return !(!a || !(a.nodeName || a.prop && a.attr && a.find)) } function we(a) { var b = {}; a = a.split(","); var d; for (d = 0; d < a.length; d++)b[a[d]] = !0; return b } function ua(a) { return K(a.nodeName || a[0] && a[0].nodeName) } function cb(a, b) { var d = a.indexOf(b); 0 <= d && a.splice(d, 1); return d } function Ia(a, b, d) {
        function c(a, b, c) {
            c--; if (0 > c) return "..."; var d = b.$$hashKey, f; if (H(a)) { f = 0; for (var g = a.length; f < g; f++)b.push(e(a[f], c)) } else if (Nc(a)) for (f in a) b[f] = e(a[f], c); else if (a && "function" === typeof a.hasOwnProperty) for (f in a) a.hasOwnProperty(f) &&
                (b[f] = e(a[f], c)); else for (f in a) ta.call(a, f) && (b[f] = e(a[f], c)); d ? b.$$hashKey = d : delete b.$$hashKey; return b
        } function e(a, b) { if (!D(a)) return a; var d = g.indexOf(a); if (-1 !== d) return k[d]; if ($a(a) || bb(a)) throw pa("cpws"); var d = !1, e = f(a); void 0 === e && (e = H(a) ? [] : Object.create(Pc(a)), d = !0); g.push(a); k.push(e); return d ? c(a, e, b) : e } function f(a) {
            switch (la.call(a)) {
                case "[object Int8Array]": case "[object Int16Array]": case "[object Int32Array]": case "[object Float32Array]": case "[object Float64Array]": case "[object Uint8Array]": case "[object Uint8ClampedArray]": case "[object Uint16Array]": case "[object Uint32Array]": return new a.constructor(e(a.buffer),
                    a.byteOffset, a.length); case "[object ArrayBuffer]": if (!a.slice) { var b = new ArrayBuffer(a.byteLength); (new Uint8Array(b)).set(new Uint8Array(a)); return b } return a.slice(0); case "[object Boolean]": case "[object Number]": case "[object String]": case "[object Date]": return new a.constructor(a.valueOf()); case "[object RegExp]": return b = new RegExp(a.source, a.toString().match(/[^/]*$/)[0]), b.lastIndex = a.lastIndex, b; case "[object Blob]": return new a.constructor([a], { type: a.type })
            }if (B(a.cloneNode)) return a.cloneNode(!0)
        }
        var g = [], k = []; d = Xb(d) ? d : NaN; if (b) { if (ue(b) || "[object ArrayBuffer]" === la.call(b)) throw pa("cpta"); if (a === b) throw pa("cpi"); H(b) ? b.length = 0 : r(b, function (a, c) { "$$hashKey" !== c && delete b[c] }); g.push(a); k.push(b); return c(a, b, d) } return e(a, d)
    } function dc(a, b) { return a === b || a !== a && b !== b } function va(a, b) {
        if (a === b) return !0; if (null === a || null === b) return !1; if (a !== a && b !== b) return !0; var d = typeof a, c; if (d === typeof b && "object" === d) if (H(a)) {
            if (!H(b)) return !1; if ((d = a.length) === b.length) {
                for (c = 0; c < d; c++)if (!va(a[c],
                    b[c])) return !1; return !0
            }
        } else { if (ha(a)) return ha(b) ? dc(a.getTime(), b.getTime()) : !1; if (ab(a)) return ab(b) ? a.toString() === b.toString() : !1; if (bb(a) || bb(b) || $a(a) || $a(b) || H(b) || ha(b) || ab(b)) return !1; d = T(); for (c in a) if ("$" !== c.charAt(0) && !B(a[c])) { if (!va(a[c], b[c])) return !1; d[c] = !0 } for (c in b) if (!(c in d) && "$" !== c.charAt(0) && w(b[c]) && !B(b[c])) return !1; return !0 } return !1
    } function db(a, b, d) { return a.concat(Ha.call(b, d)) } function Va(a, b) {
        var d = 2 < arguments.length ? Ha.call(arguments, 2) : []; return !B(b) || b instanceof
            RegExp ? b : d.length ? function () { return arguments.length ? b.apply(a, db(d, arguments, 0)) : b.apply(a, d) } : function () { return arguments.length ? b.apply(a, arguments) : b.call(a) }
    } function Qc(a, b) { var d = b; "string" === typeof a && "$" === a.charAt(0) && "$" === a.charAt(1) ? d = void 0 : $a(b) ? d = "$WINDOW" : b && C.document === b ? d = "$DOCUMENT" : bb(b) && (d = "$SCOPE"); return d } function eb(a, b) { if (!z(a)) return W(b) || (b = b ? 2 : null), JSON.stringify(a, Qc, b) } function Rc(a) { return A(a) ? JSON.parse(a) : a } function ec(a, b) {
        a = a.replace(xe, ""); var d = Date.parse("Jan 01, 1970 00:00:00 " +
            a) / 6E4; return X(d) ? b : d
    } function Sc(a, b) { a = new Date(a.getTime()); a.setMinutes(a.getMinutes() + b); return a } function fc(a, b, d) { d = d ? -1 : 1; var c = a.getTimezoneOffset(); b = ec(b, c); return Sc(a, d * (b - c)) } function za(a) { a = x(a).clone().empty(); var b = x("<div></div>").append(a).html(); try { return a[0].nodeType === Pa ? K(b) : b.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function (a, b) { return "<" + K(b) }) } catch (d) { return K(b) } } function Tc(a) { try { return decodeURIComponent(a) } catch (b) { } } function gc(a) {
        var b = {}; r((a || "").split("&"),
            function (a) { var c, e, f; a && (e = a = a.replace(/\+/g, "%20"), c = a.indexOf("="), -1 !== c && (e = a.substring(0, c), f = a.substring(c + 1)), e = Tc(e), w(e) && (f = w(f) ? Tc(f) : !0, ta.call(b, e) ? H(b[e]) ? b[e].push(f) : b[e] = [b[e], f] : b[e] = f)) }); return b
    } function ye(a) { var b = []; r(a, function (a, c) { H(a) ? r(a, function (a) { b.push(ba(c, !0) + (!0 === a ? "" : "=" + ba(a, !0))) }) : b.push(ba(c, !0) + (!0 === a ? "" : "=" + ba(a, !0))) }); return b.length ? b.join("&") : "" } function hc(a) { return ba(a, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+") } function ba(a,
        b) { return encodeURIComponent(a).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, b ? "%20" : "+") } function ze(a, b) { var d, c, e = Qa.length; for (c = 0; c < e; ++c)if (d = Qa[c] + b, A(d = a.getAttribute(d))) return d; return null } function Ae(a, b) {
            var d, c, e = {}; r(Qa, function (b) { b += "app"; !d && a.hasAttribute && a.hasAttribute(b) && (d = a, c = a.getAttribute(b)) }); r(Qa, function (b) { b += "app"; var e; !d && (e = a.querySelector("[" + b.replace(":", "\\:") + "]")) && (d = e, c = e.getAttribute(b)) });
            d && (Be ? (e.strictDi = null !== ze(d, "strict-di"), b(d, c ? [c] : [], e)) : C.console.error("AngularJS: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match."))
        } function Uc(a, b, d) {
            D(d) || (d = {}); d = S({ strictDi: !1 }, d); var c = function () {
                a = x(a); if (a.injector()) { var c = a[0] === C.document ? "document" : za(a); throw pa("btstrpd", c.replace(/</, "&lt;").replace(/>/, "&gt;")); } b = b || []; b.unshift(["$provide", function (b) { b.value("$rootElement", a) }]); d.debugInfoEnabled && b.push(["$compileProvider",
                    function (a) { a.debugInfoEnabled(!0) }]); b.unshift("ng"); c = fb(b, d.strictDi); c.invoke(["$rootScope", "$rootElement", "$compile", "$injector", function (a, b, c, d) { a.$apply(function () { b.data("$injector", d); c(b)(a) }) }]); return c
            }, e = /^NG_ENABLE_DEBUG_INFO!/, f = /^NG_DEFER_BOOTSTRAP!/; C && e.test(C.name) && (d.debugInfoEnabled = !0, C.name = C.name.replace(e, "")); if (C && !f.test(C.name)) return c(); C.name = C.name.replace(f, ""); ca.resumeBootstrap = function (a) { r(a, function (a) { b.push(a) }); return c() }; B(ca.resumeDeferredBootstrap) &&
                ca.resumeDeferredBootstrap()
        } function Ce() { C.name = "NG_ENABLE_DEBUG_INFO!" + C.name; C.location.reload() } function De(a) { a = ca.element(a).injector(); if (!a) throw pa("test"); return a.get("$$testability") } function Vc(a, b) { b = b || "_"; return a.replace(Ee, function (a, c) { return (c ? b : "") + a.toLowerCase() }) } function Fe() {
            var a; if (!Wc) {
                var b = qb(); (rb = z(b) ? C.jQuery : b ? C[b] : void 0) && rb.fn.on ? (x = rb, S(rb.fn, { scope: Wa.scope, isolateScope: Wa.isolateScope, controller: Wa.controller, injector: Wa.injector, inheritedData: Wa.inheritedData })) :
                    x = Y; a = x.cleanData; x.cleanData = function (b) { for (var c, e = 0, f; null != (f = b[e]); e++)(c = (x._data(f) || {}).events) && c.$destroy && x(f).triggerHandler("$destroy"); a(b) }; ca.element = x; Wc = !0
            }
        } function gb(a, b, d) { if (!a) throw pa("areq", b || "?", d || "required"); return a } function sb(a, b, d) { d && H(a) && (a = a[a.length - 1]); gb(B(a), b, "not a function, got " + (a && "object" === typeof a ? a.constructor.name || "Object" : typeof a)); return a } function Ja(a, b) { if ("hasOwnProperty" === a) throw pa("badname", b); } function Ge(a, b, d) {
            if (!b) return a; b = b.split(".");
            for (var c, e = a, f = b.length, g = 0; g < f; g++)c = b[g], a && (a = (e = a)[c]); return !d && B(a) ? Va(e, a) : a
        } function tb(a) { for (var b = a[0], d = a[a.length - 1], c, e = 1; b !== d && (b = b.nextSibling); e++)if (c || a[e] !== b) c || (c = x(Ha.call(a, 0, e))), c.push(b); return c || a } function T() { return Object.create(null) } function ic(a) { if (null == a) return ""; switch (typeof a) { case "string": break; case "number": a = "" + a; break; default: a = !bc(a) || H(a) || ha(a) ? eb(a) : a.toString() }return a } function He(a) {
            function b(a, b, c) { return a[b] || (a[b] = c()) } var d = F("$injector"),
                c = F("ng"); a = b(a, "angular", Object); a.$$minErr = a.$$minErr || F; return b(a, "module", function () {
                    var a = {}; return function (f, g, k) {
                        var h = {}; if ("hasOwnProperty" === f) throw c("badname", "module"); g && a.hasOwnProperty(f) && (a[f] = null); return b(a, f, function () {
                            function a(b, c, d, f) { f || (f = e); return function () { f[d || "push"]([b, c, arguments]); return t } } function b(a, c, d) { d || (d = e); return function (b, e) { e && B(e) && (e.$$moduleName = f); d.push([a, c, arguments]); return t } } if (!g) throw d("nomod", f); var e = [], n = [], s = [], G = a("$injector", "invoke",
                                "push", n), t = {
                                    _invokeQueue: e, _configBlocks: n, _runBlocks: s, info: function (a) { if (w(a)) { if (!D(a)) throw c("aobj", "value"); h = a; return this } return h }, requires: g, name: f, provider: b("$provide", "provider"), factory: b("$provide", "factory"), service: b("$provide", "service"), value: a("$provide", "value"), constant: a("$provide", "constant", "unshift"), decorator: b("$provide", "decorator", n), animation: b("$animateProvider", "register"), filter: b("$filterProvider", "register"), controller: b("$controllerProvider", "register"), directive: b("$compileProvider",
                                        "directive"), component: b("$compileProvider", "component"), config: G, run: function (a) { s.push(a); return this }
                                }; k && G(k); return t
                        })
                    }
                })
        } function ja(a, b) { if (H(a)) { b = b || []; for (var d = 0, c = a.length; d < c; d++)b[d] = a[d] } else if (D(a)) for (d in b = b || {}, a) if ("$" !== d.charAt(0) || "$" !== d.charAt(1)) b[d] = a[d]; return b || a } function Ie(a, b) { var d = []; Xb(b) && (a = ca.copy(a, null, b)); return JSON.stringify(a, function (a, b) { b = Qc(a, b); if (D(b)) { if (0 <= d.indexOf(b)) return "..."; d.push(b) } return b }) } function Je(a) {
            S(a, {
                errorHandlingConfig: re,
                bootstrap: Uc, copy: Ia, extend: S, merge: te, equals: va, element: x, forEach: r, injector: fb, noop: E, bind: Va, toJson: eb, fromJson: Rc, identity: Ta, isUndefined: z, isDefined: w, isString: A, isFunction: B, isObject: D, isNumber: W, isElement: $b, isArray: H, version: Ke, isDate: ha, callbacks: { $$counter: 0 }, getTestability: De, reloadWithDebugInfo: Ce, $$minErr: F, $$csp: Aa, $$encodeUriSegment: hc, $$encodeUriQuery: ba, $$lowercase: K, $$stringify: ic, $$uppercase: ub
            }); kc = He(C); kc("ng", ["ngLocale"], ["$provide", function (a) {
                a.provider({ $$sanitizeUri: Le });
                a.provider("$compile", Xc).directive({
                    a: Me, input: Yc, textarea: Yc, form: Ne, script: Oe, select: Pe, option: Qe, ngBind: Re, ngBindHtml: Se, ngBindTemplate: Te, ngClass: Ue, ngClassEven: Ve, ngClassOdd: We, ngCloak: Xe, ngController: Ye, ngForm: Ze, ngHide: $e, ngIf: af, ngInclude: bf, ngInit: cf, ngNonBindable: df, ngPluralize: ef, ngRef: ff, ngRepeat: gf, ngShow: hf, ngStyle: jf, ngSwitch: kf, ngSwitchWhen: lf, ngSwitchDefault: mf, ngOptions: nf, ngTransclude: of, ngModel: pf, ngList: qf, ngChange: rf, pattern: Zc, ngPattern: Zc, required: $c, ngRequired: $c, minlength: ad,
                    ngMinlength: ad, maxlength: bd, ngMaxlength: bd, ngValue: sf, ngModelOptions: tf
                }).directive({ ngInclude: uf, input: vf }).directive(vb).directive(cd); a.provider({
                    $anchorScroll: wf, $animate: xf, $animateCss: yf, $$animateJs: zf, $$animateQueue: Af, $$AnimateRunner: Bf, $$animateAsyncRun: Cf, $browser: Df, $cacheFactory: Ef, $controller: Ff, $document: Gf, $$isDocumentHidden: Hf, $exceptionHandler: If, $filter: dd, $$forceReflow: Jf, $interpolate: Kf, $interval: Lf, $$intervalFactory: Mf, $http: Nf, $httpParamSerializer: Of, $httpParamSerializerJQLike: Pf,
                    $httpBackend: Qf, $xhrFactory: Rf, $jsonpCallbacks: Sf, $location: Tf, $log: Uf, $parse: Vf, $rootScope: Wf, $q: Xf, $$q: Yf, $sce: Zf, $sceDelegate: $f, $sniffer: ag, $$taskTrackerFactory: bg, $templateCache: cg, $templateRequest: dg, $$testability: eg, $timeout: fg, $window: gg, $$rAF: hg, $$jqLite: ig, $$Map: jg, $$cookieReader: kg
                })
            }]).info({ angularVersion: "1.7.8" })
        } function wb(a, b) { return b.toUpperCase() } function xb(a) { return a.replace(lg, wb) } function lc(a) { a = a.nodeType; return 1 === a || !a || 9 === a } function ed(a, b) {
            var d, c, e = b.createDocumentFragment(),
            f = []; if (mc.test(a)) { d = e.appendChild(b.createElement("div")); c = (mg.exec(a) || ["", ""])[1].toLowerCase(); c = oa[c] || oa._default; d.innerHTML = c[1] + a.replace(ng, "<$1></$2>") + c[2]; for (c = c[0]; c--;)d = d.lastChild; f = db(f, d.childNodes); d = e.firstChild; d.textContent = "" } else f.push(b.createTextNode(a)); e.textContent = ""; e.innerHTML = ""; r(f, function (a) { e.appendChild(a) }); return e
        } function Y(a) {
            if (a instanceof Y) return a; var b; A(a) && (a = U(a), b = !0); if (!(this instanceof Y)) { if (b && "<" !== a.charAt(0)) throw nc("nosel"); return new Y(a) } if (b) {
                b =
                C.document; var d; a = (d = og.exec(a)) ? [b.createElement(d[1])] : (d = ed(a, b)) ? d.childNodes : []; oc(this, a)
            } else B(a) ? fd(a) : oc(this, a)
        } function pc(a) { return a.cloneNode(!0) } function yb(a, b) { !b && lc(a) && x.cleanData([a]); a.querySelectorAll && x.cleanData(a.querySelectorAll("*")) } function gd(a) { for (var b in a) return !1; return !0 } function hd(a) { var b = a.ng339, d = b && Ka[b], c = d && d.events, d = d && d.data; d && !gd(d) || c && !gd(c) || (delete Ka[b], a.ng339 = void 0) } function id(a, b, d, c) {
            if (w(c)) throw nc("offargs"); var e = (c = zb(a)) && c.events,
                f = c && c.handle; if (f) { if (b) { var g = function (b) { var c = e[b]; w(d) && cb(c || [], d); w(d) && c && 0 < c.length || (a.removeEventListener(b, f), delete e[b]) }; r(b.split(" "), function (a) { g(a); Ab[a] && g(Ab[a]) }) } else for (b in e) "$destroy" !== b && a.removeEventListener(b, f), delete e[b]; hd(a) }
        } function qc(a, b) { var d = a.ng339; if (d = d && Ka[d]) b ? delete d.data[b] : d.data = {}, hd(a) } function zb(a, b) { var d = a.ng339, d = d && Ka[d]; b && !d && (a.ng339 = d = ++pg, d = Ka[d] = { events: {}, data: {}, handle: void 0 }); return d } function rc(a, b, d) {
            if (lc(a)) {
                var c, e = w(d),
                f = !e && b && !D(b), g = !b; a = (a = zb(a, !f)) && a.data; if (e) a[xb(b)] = d; else { if (g) return a; if (f) return a && a[xb(b)]; for (c in b) a[xb(c)] = b[c] }
            }
        } function Bb(a, b) { return a.getAttribute ? -1 < (" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + b + " ") : !1 } function Cb(a, b) { if (b && a.setAttribute) { var d = (" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "), c = d; r(b.split(" "), function (a) { a = U(a); c = c.replace(" " + a + " ", " ") }); c !== d && a.setAttribute("class", U(c)) } } function Db(a, b) {
            if (b && a.setAttribute) {
                var d =
                    (" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "), c = d; r(b.split(" "), function (a) { a = U(a); -1 === c.indexOf(" " + a + " ") && (c += a + " ") }); c !== d && a.setAttribute("class", U(c))
            }
        } function oc(a, b) { if (b) if (b.nodeType) a[a.length++] = b; else { var d = b.length; if ("number" === typeof d && b.window !== b) { if (d) for (var c = 0; c < d; c++)a[a.length++] = b[c] } else a[a.length++] = b } } function jd(a, b) { return Eb(a, "$" + (b || "ngController") + "Controller") } function Eb(a, b, d) {
            9 === a.nodeType && (a = a.documentElement); for (b = H(b) ? b : [b]; a;) {
                for (var c =
                    0, e = b.length; c < e; c++)if (w(d = x.data(a, b[c]))) return d; a = a.parentNode || 11 === a.nodeType && a.host
            }
        } function kd(a) { for (yb(a, !0); a.firstChild;)a.removeChild(a.firstChild) } function Fb(a, b) { b || yb(a); var d = a.parentNode; d && d.removeChild(a) } function qg(a, b) { b = b || C; if ("complete" === b.document.readyState) b.setTimeout(a); else x(b).on("load", a) } function fd(a) {
            function b() { C.document.removeEventListener("DOMContentLoaded", b); C.removeEventListener("load", b); a() } "complete" === C.document.readyState ? C.setTimeout(a) : (C.document.addEventListener("DOMContentLoaded",
                b), C.addEventListener("load", b))
        } function ld(a, b) { var d = Gb[b.toLowerCase()]; return d && md[ua(a)] && d } function rg(a, b) {
            var d = function (c, d) {
                c.isDefaultPrevented = function () { return c.defaultPrevented }; var f = b[d || c.type], g = f ? f.length : 0; if (g) {
                    if (z(c.immediatePropagationStopped)) { var k = c.stopImmediatePropagation; c.stopImmediatePropagation = function () { c.immediatePropagationStopped = !0; c.stopPropagation && c.stopPropagation(); k && k.call(c) } } c.isImmediatePropagationStopped = function () { return !0 === c.immediatePropagationStopped };
                    var h = f.specialHandlerWrapper || sg; 1 < g && (f = ja(f)); for (var l = 0; l < g; l++)c.isImmediatePropagationStopped() || h(a, c, f[l])
                }
            }; d.elem = a; return d
        } function sg(a, b, d) { d.call(a, b) } function tg(a, b, d) { var c = b.relatedTarget; c && (c === a || ug.call(a, c)) || d.call(a, b) } function ig() { this.$get = function () { return S(Y, { hasClass: function (a, b) { a.attr && (a = a[0]); return Bb(a, b) }, addClass: function (a, b) { a.attr && (a = a[0]); return Db(a, b) }, removeClass: function (a, b) { a.attr && (a = a[0]); return Cb(a, b) } }) } } function La(a, b) {
            var d = a && a.$$hashKey;
            if (d) return "function" === typeof d && (d = a.$$hashKey()), d; d = typeof a; return d = "function" === d || "object" === d && null !== a ? a.$$hashKey = d + ":" + (b || se)() : d + ":" + a
        } function nd() { this._keys = []; this._values = []; this._lastKey = NaN; this._lastIndex = -1 } function od(a) { a = Function.prototype.toString.call(a).replace(vg, ""); return a.match(wg) || a.match(xg) } function yg(a) { return (a = od(a)) ? "function(" + (a[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn" } function fb(a, b) {
            function d(a) {
                return function (b, c) {
                    if (D(b)) r(b, Yb(a)); else return a(b,
                        c)
                }
            } function c(a, b) { Ja(a, "service"); if (B(b) || H(b)) b = n.instantiate(b); if (!b.$get) throw Ba("pget", a); return p[a + "Provider"] = b } function e(a, b) { return function () { var c = t.invoke(b, this); if (z(c)) throw Ba("undef", a); return c } } function f(a, b, d) { return c(a, { $get: !1 !== d ? e(a, b) : b }) } function g(a) {
                gb(z(a) || H(a), "modulesToLoad", "not an array"); var b = [], c; r(a, function (a) {
                    function d(a) { var b, c; b = 0; for (c = a.length; b < c; b++) { var e = a[b], f = n.get(e[0]); f[e[1]].apply(f, e[2]) } } if (!m.get(a)) {
                        m.set(a, !0); try {
                            A(a) ? (c = kc(a),
                                t.modules[a] = c, b = b.concat(g(c.requires)).concat(c._runBlocks), d(c._invokeQueue), d(c._configBlocks)) : B(a) ? b.push(n.invoke(a)) : H(a) ? b.push(n.invoke(a)) : sb(a, "module")
                        } catch (e) { throw H(a) && (a = a[a.length - 1]), e.message && e.stack && -1 === e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), Ba("modulerr", a, e.stack || e.message || e); }
                    }
                }); return b
            } function k(a, c) {
                function d(b, e) {
                    if (a.hasOwnProperty(b)) { if (a[b] === h) throw Ba("cdep", b + " <- " + l.join(" <- ")); return a[b] } try {
                        return l.unshift(b), a[b] = h, a[b] = c(b, e),
                            a[b]
                    } catch (f) { throw a[b] === h && delete a[b], f; } finally { l.shift() }
                } function e(a, c, f) { var g = []; a = fb.$$annotate(a, b, f); for (var h = 0, k = a.length; h < k; h++) { var l = a[h]; if ("string" !== typeof l) throw Ba("itkn", l); g.push(c && c.hasOwnProperty(l) ? c[l] : d(l, f)) } return g } return {
                    invoke: function (a, b, c, d) {
                        "string" === typeof c && (d = c, c = null); c = e(a, c, d); H(a) && (a = a[a.length - 1]); d = a; if (Ca || "function" !== typeof d) d = !1; else { var f = d.$$ngIsClass; Ga(f) || (f = d.$$ngIsClass = /^class\b/.test(Function.prototype.toString.call(d))); d = f } return d ?
                            (c.unshift(null), new (Function.prototype.bind.apply(a, c))) : a.apply(b, c)
                    }, instantiate: function (a, b, c) { var d = H(a) ? a[a.length - 1] : a; a = e(a, b, c); a.unshift(null); return new (Function.prototype.bind.apply(d, a)) }, get: d, annotate: fb.$$annotate, has: function (b) { return p.hasOwnProperty(b + "Provider") || a.hasOwnProperty(b) }
                }
            } b = !0 === b; var h = {}, l = [], m = new Hb, p = {
                $provide: {
                    provider: d(c), factory: d(f), service: d(function (a, b) { return f(a, ["$injector", function (a) { return a.instantiate(b) }]) }), value: d(function (a, b) {
                        return f(a,
                            ia(b), !1)
                    }), constant: d(function (a, b) { Ja(a, "constant"); p[a] = b; s[a] = b }), decorator: function (a, b) { var c = n.get(a + "Provider"), d = c.$get; c.$get = function () { var a = t.invoke(d, c); return t.invoke(b, null, { $delegate: a }) } }
                }
            }, n = p.$injector = k(p, function (a, b) { ca.isString(b) && l.push(b); throw Ba("unpr", l.join(" <- ")); }), s = {}, G = k(s, function (a, b) { var c = n.get(a + "Provider", b); return t.invoke(c.$get, c, void 0, a) }), t = G; p.$injectorProvider = { $get: ia(G) }; t.modules = n.modules = T(); var N = g(a), t = G.get("$injector"); t.strictDi = b; r(N,
                function (a) { a && t.invoke(a) }); t.loadNewModules = function (a) { r(g(a), function (a) { a && t.invoke(a) }) }; return t
        } function wf() {
            var a = !0; this.disableAutoScrolling = function () { a = !1 }; this.$get = ["$window", "$location", "$rootScope", function (b, d, c) {
                function e(a) { var b = null; Array.prototype.some.call(a, function (a) { if ("a" === ua(a)) return b = a, !0 }); return b } function f(a) {
                    if (a) {
                        a.scrollIntoView(); var c; c = g.yOffset; B(c) ? c = c() : $b(c) ? (c = c[0], c = "fixed" !== b.getComputedStyle(c).position ? 0 : c.getBoundingClientRect().bottom) : W(c) ||
                            (c = 0); c && (a = a.getBoundingClientRect().top, b.scrollBy(0, a - c))
                    } else b.scrollTo(0, 0)
                } function g(a) { a = A(a) ? a : W(a) ? a.toString() : d.hash(); var b; a ? (b = k.getElementById(a)) ? f(b) : (b = e(k.getElementsByName(a))) ? f(b) : "top" === a && f(null) : f(null) } var k = b.document; a && c.$watch(function () { return d.hash() }, function (a, b) { a === b && "" === a || qg(function () { c.$evalAsync(g) }) }); return g
            }]
        } function hb(a, b) { if (!a && !b) return ""; if (!a) return b; if (!b) return a; H(a) && (a = a.join(" ")); H(b) && (b = b.join(" ")); return a + " " + b } function zg(a) {
            A(a) &&
            (a = a.split(" ")); var b = T(); r(a, function (a) { a.length && (b[a] = !0) }); return b
        } function ra(a) { return D(a) ? a : {} } function Ag(a, b, d, c, e) {
            function f() { qa = null; k() } function g() { t = y(); t = z(t) ? null : t; va(t, P) && (t = P); N = P = t } function k() { var a = N; g(); if (v !== h.url() || a !== t) v = h.url(), N = t, r(J, function (a) { a(h.url(), t) }) } var h = this, l = a.location, m = a.history, p = a.setTimeout, n = a.clearTimeout, s = {}, G = e(d); h.isMock = !1; h.$$completeOutstandingRequest = G.completeTask; h.$$incOutstandingRequestCount = G.incTaskCount; h.notifyWhenNoOutstandingRequests =
                G.notifyWhenNoPendingTasks; var t, N, v = l.href, jc = b.find("base"), qa = null, y = c.history ? function () { try { return m.state } catch (a) { } } : E; g(); h.url = function (b, d, e) {
                    z(e) && (e = null); l !== a.location && (l = a.location); m !== a.history && (m = a.history); if (b) {
                        var f = N === e; b = ga(b).href; if (v === b && (!c.history || f)) return h; var k = v && Da(v) === Da(b); v = b; N = e; !c.history || k && f ? (k || (qa = b), d ? l.replace(b) : k ? (d = l, e = b, f = e.indexOf("#"), e = -1 === f ? "" : e.substr(f), d.hash = e) : l.href = b, l.href !== b && (qa = b)) : (m[d ? "replaceState" : "pushState"](e, "", b), g());
                        qa && (qa = b); return h
                    } return (qa || l.href).replace(/#$/, "")
                }; h.state = function () { return t }; var J = [], I = !1, P = null; h.onUrlChange = function (b) { if (!I) { if (c.history) x(a).on("popstate", f); x(a).on("hashchange", f); I = !0 } J.push(b); return b }; h.$$applicationDestroyed = function () { x(a).off("hashchange popstate", f) }; h.$$checkUrlChange = k; h.baseHref = function () { var a = jc.attr("href"); return a ? a.replace(/^(https?:)?\/\/[^/]*/, "") : "" }; h.defer = function (a, b, c) {
                    var d; b = b || 0; c = c || G.DEFAULT_TASK_TYPE; G.incTaskCount(c); d = p(function () {
                        delete s[d];
                        G.completeTask(a, c)
                    }, b); s[d] = c; return d
                }; h.defer.cancel = function (a) { if (s.hasOwnProperty(a)) { var b = s[a]; delete s[a]; n(a); G.completeTask(E, b); return !0 } return !1 }
        } function Df() { this.$get = ["$window", "$log", "$sniffer", "$document", "$$taskTrackerFactory", function (a, b, d, c, e) { return new Ag(a, c, b, d, e) }] } function Ef() {
            this.$get = function () {
                function a(a, c) {
                    function e(a) { a !== p && (n ? n === a && (n = a.n) : n = a, f(a.n, a.p), f(a, p), p = a, p.n = null) } function f(a, b) { a !== b && (a && (a.p = b), b && (b.n = a)) } if (a in b) throw F("$cacheFactory")("iid",
                        a); var g = 0, k = S({}, c, { id: a }), h = T(), l = c && c.capacity || Number.MAX_VALUE, m = T(), p = null, n = null; return b[a] = {
                            put: function (a, b) { if (!z(b)) { if (l < Number.MAX_VALUE) { var c = m[a] || (m[a] = { key: a }); e(c) } a in h || g++; h[a] = b; g > l && this.remove(n.key); return b } }, get: function (a) { if (l < Number.MAX_VALUE) { var b = m[a]; if (!b) return; e(b) } return h[a] }, remove: function (a) { if (l < Number.MAX_VALUE) { var b = m[a]; if (!b) return; b === p && (p = b.p); b === n && (n = b.n); f(b.n, b.p); delete m[a] } a in h && (delete h[a], g--) }, removeAll: function () {
                                h = T(); g = 0; m = T();
                                p = n = null
                            }, destroy: function () { m = k = h = null; delete b[a] }, info: function () { return S({}, k, { size: g }) }
                        }
                } var b = {}; a.info = function () { var a = {}; r(b, function (b, e) { a[e] = b.info() }); return a }; a.get = function (a) { return b[a] }; return a
            }
        } function cg() { this.$get = ["$cacheFactory", function (a) { return a("templates") }] } function Xc(a, b) {
            function d(a, b, c) {
                var d = /^([@&]|[=<](\*?))(\??)\s*([\w$]*)$/, e = T(); r(a, function (a, f) {
                    a = a.trim(); if (a in p) e[f] = p[a]; else {
                        var g = a.match(d); if (!g) throw $("iscp", b, f, a, c ? "controller bindings definition" :
                            "isolate scope definition"); e[f] = { mode: g[1][0], collection: "*" === g[2], optional: "?" === g[3], attrName: g[4] || f }; g[4] && (p[a] = e[f])
                    }
                }); return e
            } function c(a) { var b = a.charAt(0); if (!b || b !== K(b)) throw $("baddir", a); if (a !== a.trim()) throw $("baddir", a); } function e(a) { var b = a.require || a.controller && a.name; !H(b) && D(b) && r(b, function (a, c) { var d = a.match(l); a.substring(d[0].length) || (b[c] = d[0] + c) }); return b } var f = {}, g = /^\s*directive:\s*([\w-]+)\s+(.*)$/, k = /(([\w-]+)(?::([^;]+))?;?)/, h = we("ngSrc,ngSrcset,src,srcset"),
                l = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, m = /^(on[a-z]+|formaction)$/, p = T(); this.directive = function qa(b, d) {
                    gb(b, "name"); Ja(b, "directive"); A(b) ? (c(b), gb(d, "directiveFactory"), f.hasOwnProperty(b) || (f[b] = [], a.factory(b + "Directive", ["$injector", "$exceptionHandler", function (a, c) {
                        var d = []; r(f[b], function (f, g) {
                            try {
                                var h = a.invoke(f); B(h) ? h = { compile: ia(h) } : !h.compile && h.link && (h.compile = ia(h.link)); h.priority = h.priority || 0; h.index = g; h.name = h.name || b; h.require = e(h); var k = h, l = h.restrict; if (l && (!A(l) || !/[EACM]/.test(l))) throw $("badrestrict",
                                    l, b); k.restrict = l || "EA"; h.$$moduleName = f.$$moduleName; d.push(h)
                            } catch (m) { c(m) }
                        }); return d
                    }])), f[b].push(d)) : r(b, Yb(qa)); return this
                }; this.component = function y(a, b) {
                    function c(a) {
                        function e(b) { return B(b) || H(b) ? function (c, d) { return a.invoke(b, this, { $element: c, $attrs: d }) } : b } var f = b.template || b.templateUrl ? b.template : "", g = {
                            controller: d, controllerAs: Bg(b.controller) || b.controllerAs || "$ctrl", template: e(f), templateUrl: e(b.templateUrl), transclude: b.transclude, scope: {}, bindToController: b.bindings || {}, restrict: "E",
                            require: b.require
                        }; r(b, function (a, b) { "$" === b.charAt(0) && (g[b] = a) }); return g
                    } if (!A(a)) return r(a, Yb(Va(this, y))), this; var d = b.controller || function () { }; r(b, function (a, b) { "$" === b.charAt(0) && (c[b] = a, B(d) && (d[b] = a)) }); c.$inject = ["$injector"]; return this.directive(a, c)
                }; this.aHrefSanitizationWhitelist = function (a) { return w(a) ? (b.aHrefSanitizationWhitelist(a), this) : b.aHrefSanitizationWhitelist() }; this.imgSrcSanitizationWhitelist = function (a) { return w(a) ? (b.imgSrcSanitizationWhitelist(a), this) : b.imgSrcSanitizationWhitelist() };
            var n = !0; this.debugInfoEnabled = function (a) { return w(a) ? (n = a, this) : n }; var s = !1; this.strictComponentBindingsEnabled = function (a) { return w(a) ? (s = a, this) : s }; var G = 10; this.onChangesTtl = function (a) { return arguments.length ? (G = a, this) : G }; var t = !0; this.commentDirectivesEnabled = function (a) { return arguments.length ? (t = a, this) : t }; var N = !0; this.cssClassDirectivesEnabled = function (a) { return arguments.length ? (N = a, this) : N }; var v = T(); this.addPropertySecurityContext = function (a, b, c) {
                var d = a.toLowerCase() + "|" + b.toLowerCase();
                if (d in v && v[d] !== c) throw $("ctxoverride", a, b, v[d], c); v[d] = c; return this
            }; (function () { function a(b, c) { r(c, function (a) { v[a.toLowerCase()] = b }) } a(V.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]); a(V.CSS, ["*|style"]); a(V.URL, "area|href area|ping a|href a|ping blockquote|cite body|background del|cite input|src ins|cite q|cite".split(" ")); a(V.MEDIA_URL, "audio|src img|src img|srcset source|src source|srcset track|src video|src video|poster".split(" ")); a(V.RESOURCE_URL, "*|formAction applet|code applet|codebase base|href embed|src frame|src form|action head|profile html|manifest iframe|src link|href media|src object|codebase object|data script|src".split(" ")) })();
            this.$get = ["$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", function (a, b, c, e, p, M, L, u, R) {
                function q() { try { if (!--Ja) throw Ua = void 0, $("infchng", G); L.$apply(function () { for (var a = 0, b = Ua.length; a < b; ++a)try { Ua[a]() } catch (d) { c(d) } Ua = void 0 }) } finally { Ja++ } } function ma(a, b) {
                    if (!a) return a; if (!A(a)) throw $("srcset", b, a.toString()); for (var c = "", d = U(a), e = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, e = /\s/.test(d) ? e : /(,)/, d = d.split(e), e = Math.floor(d.length /
                        2), f = 0; f < e; f++)var g = 2 * f, c = c + u.getTrustedMediaUrl(U(d[g])), c = c + (" " + U(d[g + 1])); d = U(d[2 * f]).split(/\s/); c += u.getTrustedMediaUrl(U(d[0])); 2 === d.length && (c += " " + U(d[1])); return c
                } function w(a, b) { if (b) { var c = Object.keys(b), d, e, f; d = 0; for (e = c.length; d < e; d++)f = c[d], this[f] = b[f] } else this.$attr = {}; this.$$element = a } function O(a, b, c) { Fa.innerHTML = "<span " + b + ">"; b = Fa.firstChild.attributes; var d = b[0]; b.removeNamedItem(d.name); d.value = c; a.attributes.setNamedItem(d) } function sa(a, b) { try { a.addClass(b) } catch (c) { } }
                function da(a, b, c, d, e) {
                    a instanceof x || (a = x(a)); var f = Xa(a, b, a, c, d, e); da.$$addScopeClass(a); var g = null; return function (b, c, d) {
                        if (!a) throw $("multilink"); gb(b, "scope"); e && e.needsNewScope && (b = b.$parent.$new()); d = d || {}; var h = d.parentBoundTranscludeFn, k = d.transcludeControllers; d = d.futureParentElement; h && h.$$boundTransclude && (h = h.$$boundTransclude); g || (g = (d = d && d[0]) ? "foreignobject" !== ua(d) && la.call(d).match(/SVG/) ? "svg" : "html" : "html"); d = "html" !== g ? x(ja(g, x("<div></div>").append(a).html())) : c ? Wa.clone.call(a) :
                            a; if (k) for (var l in k) d.data("$" + l + "Controller", k[l].instance); da.$$addScopeInfo(d, b); c && c(d, b); f && f(b, d, d, h); c || (a = f = null); return d
                    }
                } function Xa(a, b, c, d, e, f) {
                    function g(a, c, d, e) {
                        var f, k, l, m, p, I, t; if (n) for (t = Array(c.length), m = 0; m < h.length; m += 3)f = h[m], t[f] = c[f]; else t = c; m = 0; for (p = h.length; m < p;)k = t[h[m++]], c = h[m++], f = h[m++], c ? (c.scope ? (l = a.$new(), da.$$addScopeInfo(x(k), l)) : l = a, I = c.transcludeOnThisElement ? ka(a, c.transclude, e) : !c.templateOnThisElement && e ? e : !e && b ? ka(a, b) : null, c(f, l, k, d, I)) : f && f(a, k.childNodes,
                            void 0, e)
                    } for (var h = [], k = H(a) || a instanceof x, l, m, p, I, n, t = 0; t < a.length; t++) { l = new w; 11 === Ca && ib(a, t, k); m = sc(a[t], [], l, 0 === t ? d : void 0, e); (f = m.length ? aa(m, a[t], l, b, c, null, [], [], f) : null) && f.scope && da.$$addScopeClass(l.$$element); l = f && f.terminal || !(p = a[t].childNodes) || !p.length ? null : Xa(p, f ? (f.transcludeOnThisElement || !f.templateOnThisElement) && f.transclude : b); if (f || l) h.push(t, f, l), I = !0, n = n || f; f = null } return I ? g : null
                } function ib(a, b, c) {
                    var d = a[b], e = d.parentNode, f; if (d.nodeType === Pa) for (; ;) {
                        f = e ? d.nextSibling :
                            a[b + 1]; if (!f || f.nodeType !== Pa) break; d.nodeValue += f.nodeValue; f.parentNode && f.parentNode.removeChild(f); c && f === a[b + 1] && a.splice(b + 1, 1)
                    }
                } function ka(a, b, c) { function d(e, f, g, h, k) { e || (e = a.$new(!1, k), e.$$transcluded = !0); return b(e, f, { parentBoundTranscludeFn: c, transcludeControllers: g, futureParentElement: h }) } var e = d.$$slots = T(), f; for (f in b.$$slots) e[f] = b.$$slots[f] ? ka(a, b.$$slots[f], c) : null; return d } function sc(a, b, d, e, f) {
                    var g = d.$attr, h; switch (a.nodeType) {
                        case 1: h = ua(a); X(b, wa(h), "E", e, f); for (var l, m,
                            n, t, J, s = a.attributes, v = 0, G = s && s.length; v < G; v++) {
                                var P = !1, N = !1, r = !1, y = !1, u = !1, M; l = s[v]; m = l.name; t = l.value; n = wa(m.toLowerCase()); (J = n.match(Ra)) ? (r = "Attr" === J[1], y = "Prop" === J[1], u = "On" === J[1], m = m.replace(pd, "").toLowerCase().substr(4 + J[1].length).replace(/_(.)/g, function (a, b) { return b.toUpperCase() })) : (M = n.match(Sa)) && ca(M[1]) && (P = m, N = m.substr(0, m.length - 5) + "end", m = m.substr(0, m.length - 6)); if (y || u) d[n] = t, g[n] = l.name, y ? Ea(a, b, n, m) : b.push(qd(p, L, c, n, m, !1)); else {
                                    n = wa(m.toLowerCase()); g[n] = m; if (r || !d.hasOwnProperty(n)) d[n] =
                                        t, ld(a, n) && (d[n] = !0); Ia(a, b, t, n, r); X(b, n, "A", e, f, P, N)
                                }
                        } "input" === h && "hidden" === a.getAttribute("type") && a.setAttribute("autocomplete", "off"); if (!Qa) break; g = a.className; D(g) && (g = g.animVal); if (A(g) && "" !== g) for (; a = k.exec(g);)n = wa(a[2]), X(b, n, "C", e, f) && (d[n] = U(a[3])), g = g.substr(a.index + a[0].length); break; case Pa: na(b, a.nodeValue); break; case 8: if (!Oa) break; F(a, b, d, e, f)
                    }b.sort(ia); return b
                } function F(a, b, c, d, e) { try { var f = g.exec(a.nodeValue); if (f) { var h = wa(f[1]); X(b, h, "M", d, e) && (c[h] = U(f[2])) } } catch (k) { } }
                function V(a, b, c) { var d = [], e = 0; if (b && a.hasAttribute && a.hasAttribute(b)) { do { if (!a) throw $("uterdir", b, c); 1 === a.nodeType && (a.hasAttribute(b) && e++, a.hasAttribute(c) && e--); d.push(a); a = a.nextSibling } while (0 < e) } else d.push(a); return x(d) } function Y(a, b, c) { return function (d, e, f, g, h) { e = V(e[0], b, c); return a(d, e, f, g, h) } } function Z(a, b, c, d, e, f) { var g; return a ? da(b, c, d, e, f) : function () { g || (g = da(b, c, d, e, f), b = c = f = null); return g.apply(this, arguments) } } function aa(a, b, d, e, f, g, h, k, l) {
                    function m(a, b, c, d) {
                        if (a) {
                            c && (a =
                                Y(a, c, d)); a.require = u.require; a.directiveName = Q; if (s === u || u.$$isolateScope) a = Aa(a, { isolateScope: !0 }); h.push(a)
                        } if (b) { c && (b = Y(b, c, d)); b.require = u.require; b.directiveName = Q; if (s === u || u.$$isolateScope) b = Aa(b, { isolateScope: !0 }); k.push(b) }
                    } function p(a, e, f, g, l) {
                        function m(a, b, c, d) { var e; bb(a) || (d = c, c = b, b = a, a = void 0); N && (e = P); c || (c = N ? Q.parent() : Q); if (d) { var f = l.$$slots[d]; if (f) return f(a, b, e, c, R); if (z(f)) throw $("noslot", d, za(Q)); } else return l(a, b, e, c, R) } var n, u, L, y, G, P, M, Q; b === f ? (g = d, Q = d.$$element) : (Q =
                            x(f), g = new w(Q, d)); G = e; s ? y = e.$new(!0) : t && (G = e.$parent); l && (M = m, M.$$boundTransclude = l, M.isSlotFilled = function (a) { return !!l.$$slots[a] }); J && (P = ea(Q, g, M, J, y, e, s)); s && (da.$$addScopeInfo(Q, y, !0, !(v && (v === s || v === s.$$originalDirective))), da.$$addScopeClass(Q, !0), y.$$isolateBindings = s.$$isolateBindings, u = Da(e, g, y, y.$$isolateBindings, s), u.removeWatches && y.$on("$destroy", u.removeWatches)); for (n in P) {
                                u = J[n]; L = P[n]; var Cg = u.$$bindings.bindToController; L.instance = L(); Q.data("$" + u.name + "Controller", L.instance);
                                L.bindingInfo = Da(G, g, L.instance, Cg, u)
                            } r(J, function (a, b) { var c = a.require; a.bindToController && !H(c) && D(c) && S(P[b].instance, W(b, c, Q, P)) }); r(P, function (a) { var b = a.instance; if (B(b.$onChanges)) try { b.$onChanges(a.bindingInfo.initialChanges) } catch (d) { c(d) } if (B(b.$onInit)) try { b.$onInit() } catch (e) { c(e) } B(b.$doCheck) && (G.$watch(function () { b.$doCheck() }), b.$doCheck()); B(b.$onDestroy) && G.$on("$destroy", function () { b.$onDestroy() }) }); n = 0; for (u = h.length; n < u; n++)L = h[n], Ba(L, L.isolateScope ? y : e, Q, g, L.require && W(L.directiveName,
                                L.require, Q, P), M); var R = e; s && (s.template || null === s.templateUrl) && (R = y); a && a(R, f.childNodes, void 0, l); for (n = k.length - 1; 0 <= n; n--)L = k[n], Ba(L, L.isolateScope ? y : e, Q, g, L.require && W(L.directiveName, L.require, Q, P), M); r(P, function (a) { a = a.instance; B(a.$postLink) && a.$postLink() })
                    } l = l || {}; for (var n = -Number.MAX_VALUE, t = l.newScopeDirective, J = l.controllerDirectives, s = l.newIsolateScopeDirective, v = l.templateDirective, L = l.nonTlbTranscludeDirective, G = !1, P = !1, N = l.hasElementTranscludeDirective, y = d.$$element = x(b), u, Q,
                        M, R = e, q, ma = !1, Ib = !1, O, sa = 0, A = a.length; sa < A; sa++) {
                            u = a[sa]; var E = u.$$start, ib = u.$$end; E && (y = V(b, E, ib)); M = void 0; if (n > u.priority) break; if (O = u.scope) u.templateUrl || (D(O) ? (ba("new/isolated scope", s || t, u, y), s = u) : ba("new/isolated scope", s, u, y)), t = t || u; Q = u.name; if (!ma && (u.replace && (u.templateUrl || u.template) || u.transclude && !u.$$tlb)) { for (O = sa + 1; ma = a[O++];)if (ma.transclude && !ma.$$tlb || ma.replace && (ma.templateUrl || ma.template)) { Ib = !0; break } ma = !0 } !u.templateUrl && u.controller && (J = J || T(), ba("'" + Q + "' controller",
                                J[Q], u, y), J[Q] = u); if (O = u.transclude) if (G = !0, u.$$tlb || (ba("transclusion", L, u, y), L = u), "element" === O) N = !0, n = u.priority, M = y, y = d.$$element = x(da.$$createComment(Q, d[Q])), b = y[0], pa(f, Ha.call(M, 0), b), R = Z(Ib, M, e, n, g && g.name, { nonTlbTranscludeDirective: L }); else {
                                    var ka = T(); if (D(O)) {
                                        M = C.document.createDocumentFragment(); var Xa = T(), F = T(); r(O, function (a, b) { var c = "?" === a.charAt(0); a = c ? a.substring(1) : a; Xa[a] = b; ka[b] = null; F[b] = c }); r(y.contents(), function (a) {
                                            var b = Xa[wa(ua(a))]; b ? (F[b] = !0, ka[b] = ka[b] || C.document.createDocumentFragment(),
                                                ka[b].appendChild(a)) : M.appendChild(a)
                                        }); r(F, function (a, b) { if (!a) throw $("reqslot", b); }); for (var K in ka) ka[K] && (R = x(ka[K].childNodes), ka[K] = Z(Ib, R, e)); M = x(M.childNodes)
                                    } else M = x(pc(b)).contents(); y.empty(); R = Z(Ib, M, e, void 0, void 0, { needsNewScope: u.$$isolateScope || u.$$newScope }); R.$$slots = ka
                                } if (u.template) if (P = !0, ba("template", v, u, y), v = u, O = B(u.template) ? u.template(y, d) : u.template, O = Na(O), u.replace) {
                                    g = u; M = mc.test(O) ? rd(ja(u.templateNamespace, U(O))) : []; b = M[0]; if (1 !== M.length || 1 !== b.nodeType) throw $("tplrt",
                                        Q, ""); pa(f, y, b); A = { $attr: {} }; O = sc(b, [], A); var Dg = a.splice(sa + 1, a.length - (sa + 1)); (s || t) && fa(O, s, t); a = a.concat(O).concat(Dg); ga(d, A); A = a.length
                                } else y.html(O); if (u.templateUrl) P = !0, ba("template", v, u, y), v = u, u.replace && (g = u), p = ha(a.splice(sa, a.length - sa), y, d, f, G && R, h, k, { controllerDirectives: J, newScopeDirective: t !== u && t, newIsolateScopeDirective: s, templateDirective: v, nonTlbTranscludeDirective: L }), A = a.length; else if (u.compile) try {
                                    q = u.compile(y, d, R); var X = u.$$originalDirective || u; B(q) ? m(null, Va(X, q), E, ib) :
                                        q && m(Va(X, q.pre), Va(X, q.post), E, ib)
                                } catch (ca) { c(ca, za(y)) } u.terminal && (p.terminal = !0, n = Math.max(n, u.priority))
                    } p.scope = t && !0 === t.scope; p.transcludeOnThisElement = G; p.templateOnThisElement = P; p.transclude = R; l.hasElementTranscludeDirective = N; return p
                } function W(a, b, c, d) {
                    var e; if (A(b)) {
                        var f = b.match(l); b = b.substring(f[0].length); var g = f[1] || f[3], f = "?" === f[2]; "^^" === g ? c = c.parent() : e = (e = d && d[b]) && e.instance; if (!e) { var h = "$" + b + "Controller"; e = "^^" === g && c[0] && 9 === c[0].nodeType ? null : g ? c.inheritedData(h) : c.data(h) } if (!e &&
                            !f) throw $("ctreq", b, a);
                    } else if (H(b)) for (e = [], g = 0, f = b.length; g < f; g++)e[g] = W(a, b[g], c, d); else D(b) && (e = {}, r(b, function (b, f) { e[f] = W(a, b, c, d) })); return e || null
                } function ea(a, b, c, d, e, f, g) { var h = T(), k; for (k in d) { var l = d[k], m = { $scope: l === g || l.$$isolateScope ? e : f, $element: a, $attrs: b, $transclude: c }, p = l.controller; "@" === p && (p = b[l.name]); m = M(p, m, !0, l.controllerAs); h[l.name] = m; a.data("$" + l.name + "Controller", m.instance) } return h } function fa(a, b, c) {
                    for (var d = 0, e = a.length; d < e; d++)a[d] = ac(a[d], {
                        $$isolateScope: b,
                        $$newScope: c
                    })
                } function X(b, c, e, g, h, k, l) {
                    if (c === h) return null; var m = null; if (f.hasOwnProperty(c)) {
                        h = a.get(c + "Directive"); for (var p = 0, n = h.length; p < n; p++)if (c = h[p], (z(g) || g > c.priority) && -1 !== c.restrict.indexOf(e)) {
                            k && (c = ac(c, { $$start: k, $$end: l })); if (!c.$$bindings) {
                                var I = m = c, t = c.name, u = { isolateScope: null, bindToController: null }; D(I.scope) && (!0 === I.bindToController ? (u.bindToController = d(I.scope, t, !0), u.isolateScope = {}) : u.isolateScope = d(I.scope, t, !1)); D(I.bindToController) && (u.bindToController = d(I.bindToController,
                                    t, !0)); if (u.bindToController && !I.controller) throw $("noctrl", t); m = m.$$bindings = u; D(m.isolateScope) && (c.$$isolateBindings = m.isolateScope)
                            } b.push(c); m = c
                        }
                    } return m
                } function ca(b) { if (f.hasOwnProperty(b)) for (var c = a.get(b + "Directive"), d = 0, e = c.length; d < e; d++)if (b = c[d], b.multiElement) return !0; return !1 } function ga(a, b) {
                    var c = b.$attr, d = a.$attr; r(a, function (d, e) { "$" !== e.charAt(0) && (b[e] && b[e] !== d && (d = d.length ? d + (("style" === e ? ";" : " ") + b[e]) : b[e]), a.$set(e, d, !0, c[e])) }); r(b, function (b, e) {
                        a.hasOwnProperty(e) ||
                        "$" === e.charAt(0) || (a[e] = b, "class" !== e && "style" !== e && (d[e] = c[e]))
                    })
                } function ha(a, b, d, f, g, h, k, l) {
                    var m = [], p, n, t = b[0], u = a.shift(), J = ac(u, { templateUrl: null, transclude: null, replace: null, $$originalDirective: u }), s = B(u.templateUrl) ? u.templateUrl(b, d) : u.templateUrl, L = u.templateNamespace; b.empty(); e(s).then(function (c) {
                        var e, I; c = Na(c); if (u.replace) {
                            c = mc.test(c) ? rd(ja(L, U(c))) : []; e = c[0]; if (1 !== c.length || 1 !== e.nodeType) throw $("tplrt", u.name, s); c = { $attr: {} }; pa(f, b, e); var v = sc(e, [], c); D(u.scope) && fa(v, !0); a =
                                v.concat(a); ga(d, c)
                        } else e = t, b.html(c); a.unshift(J); p = aa(a, e, d, g, b, u, h, k, l); r(f, function (a, c) { a === e && (f[c] = b[0]) }); for (n = Xa(b[0].childNodes, g); m.length;) { c = m.shift(); I = m.shift(); var y = m.shift(), P = m.shift(), v = b[0]; if (!c.$$destroyed) { if (I !== t) { var G = I.className; l.hasElementTranscludeDirective && u.replace || (v = pc(e)); pa(y, x(I), v); sa(x(v), G) } I = p.transcludeOnThisElement ? ka(c, p.transclude, P) : P; p(n, c, v, f, I) } } m = null
                    }).catch(function (a) { cc(a) && c(a) }); return function (a, b, c, d, e) {
                        a = e; b.$$destroyed || (m ? m.push(b,
                            c, d, a) : (p.transcludeOnThisElement && (a = ka(b, p.transclude, e)), p(n, b, c, d, a)))
                    }
                } function ia(a, b) { var c = b.priority - a.priority; return 0 !== c ? c : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index } function ba(a, b, c, d) { function e(a) { return a ? " (module: " + a + ")" : "" } if (b) throw $("multidir", b.name, e(b.$$moduleName), c.name, e(c.$$moduleName), a, za(d)); } function na(a, c) {
                    var d = b(c, !0); d && a.push({
                        priority: 0, compile: function (a) {
                            a = a.parent(); var b = !!a.length; b && da.$$addBindingClass(a); return function (a, c) {
                                var e = c.parent();
                                b || da.$$addBindingClass(e); da.$$addBindingInfo(e, d.expressions); a.$watch(d, function (a) { c[0].nodeValue = a })
                            }
                        }
                    })
                } function ja(a, b) { a = K(a || "html"); switch (a) { case "svg": case "math": var c = C.document.createElement("div"); c.innerHTML = "<" + a + ">" + b + "</" + a + ">"; return c.childNodes[0].childNodes; default: return b } } function oa(a, b) {
                    if ("srcdoc" === b) return u.HTML; if ("src" === b || "ngSrc" === b) return -1 === ["img", "video", "audio", "source", "track"].indexOf(a) ? u.RESOURCE_URL : u.MEDIA_URL; if ("xlinkHref" === b) return "image" === a ? u.MEDIA_URL :
                        "a" === a ? u.URL : u.RESOURCE_URL; if ("form" === a && "action" === b || "base" === a && "href" === b || "link" === a && "href" === b) return u.RESOURCE_URL; if ("a" === a && ("href" === b || "ngHref" === b)) return u.URL
                } function xa(a, b) { var c = b.toLowerCase(); return v[a + "|" + c] || v["*|" + c] } function ya(a) { return ma(u.valueOf(a), "ng-prop-srcset") } function Ea(a, b, c, d) {
                    if (m.test(d)) throw $("nodomevents"); a = ua(a); var e = xa(a, d), f = Ta; "srcset" !== d || "img" !== a && "source" !== a ? e && (f = u.getTrusted.bind(u, e)) : f = ya; b.push({
                        priority: 100, compile: function (a, b) {
                            var e =
                                p(b[c]), g = p(b[c], function (a) { return u.valueOf(a) }); return { pre: function (a, b) { function c() { var g = e(a); b[0][d] = f(g) } c(); a.$watch(g, c) } }
                        }
                    })
                } function Ia(a, c, d, e, f) {
                    var g = ua(a), k = oa(g, e), l = h[e] || f, p = b(d, !f, k, l); if (p) {
                        if ("multiple" === e && "select" === g) throw $("selmulti", za(a)); if (m.test(e)) throw $("nodomevents"); c.push({
                            priority: 100, compile: function () {
                                return {
                                    pre: function (a, c, f) {
                                        c = f.$$observers || (f.$$observers = T()); var g = f[e]; g !== d && (p = g && b(g, !0, k, l), d = g); p && (f[e] = p(a), (c[e] || (c[e] = [])).$$inter = !0, (f.$$observers &&
                                            f.$$observers[e].$$scope || a).$watch(p, function (a, b) { "class" === e && a !== b ? f.$updateClass(a, b) : f.$set(e, a) }))
                                    }
                                }
                            }
                        })
                    }
                } function pa(a, b, c) {
                    var d = b[0], e = b.length, f = d.parentNode, g, h; if (a) for (g = 0, h = a.length; g < h; g++)if (a[g] === d) { a[g++] = c; h = g + e - 1; for (var k = a.length; g < k; g++, h++)h < k ? a[g] = a[h] : delete a[g]; a.length -= e - 1; a.context === d && (a.context = c); break } f && f.replaceChild(c, d); a = C.document.createDocumentFragment(); for (g = 0; g < e; g++)a.appendChild(b[g]); x.hasData(d) && (x.data(c, x.data(d)), x(d).off("$destroy")); x.cleanData(a.querySelectorAll("*"));
                    for (g = 1; g < e; g++)delete b[g]; b[0] = c; b.length = 1
                } function Aa(a, b) { return S(function () { return a.apply(null, arguments) }, a, b) } function Ba(a, b, d, e, f, g) { try { a(b, d, e, f, g) } catch (h) { c(h, za(d)) } } function ra(a, b) { if (s) throw $("missingattr", a, b); } function Da(a, c, d, e, f) {
                    function g(b, c, e) { B(d.$onChanges) && !dc(c, e) && (Ua || (a.$$postDigest(q), Ua = []), m || (m = {}, Ua.push(h)), m[b] && (e = m[b].previousValue), m[b] = new Jb(e, c)) } function h() { d.$onChanges(m); m = void 0 } var k = [], l = {}, m; r(e, function (e, h) {
                        var m = e.attrName, n = e.optional,
                        I, t, u, s; switch (e.mode) {
                            case "@": n || ta.call(c, m) || (ra(m, f.name), d[h] = c[m] = void 0); n = c.$observe(m, function (a) { if (A(a) || Ga(a)) g(h, a, d[h]), d[h] = a }); c.$$observers[m].$$scope = a; I = c[m]; A(I) ? d[h] = b(I)(a) : Ga(I) && (d[h] = I); l[h] = new Jb(tc, d[h]); k.push(n); break; case "=": if (!ta.call(c, m)) { if (n) break; ra(m, f.name); c[m] = void 0 } if (n && !c[m]) break; t = p(c[m]); s = t.literal ? va : dc; u = t.assign || function () { I = d[h] = t(a); throw $("nonassign", c[m], m, f.name); }; I = d[h] = t(a); n = function (b) {
                                s(b, d[h]) || (s(b, I) ? u(a, b = d[h]) : d[h] = b); return I =
                                    b
                            }; n.$stateful = !0; n = e.collection ? a.$watchCollection(c[m], n) : a.$watch(p(c[m], n), null, t.literal); k.push(n); break; case "<": if (!ta.call(c, m)) { if (n) break; ra(m, f.name); c[m] = void 0 } if (n && !c[m]) break; t = p(c[m]); var v = t.literal, L = d[h] = t(a); l[h] = new Jb(tc, d[h]); n = a[e.collection ? "$watchCollection" : "$watch"](t, function (a, b) { if (b === a) { if (b === L || v && va(b, L)) return; b = L } g(h, a, b); d[h] = a }); k.push(n); break; case "&": n || ta.call(c, m) || ra(m, f.name); t = c.hasOwnProperty(m) ? p(c[m]) : E; if (t === E && n) break; d[h] = function (b) {
                                return t(a,
                                    b)
                            }
                        }
                    }); return { initialChanges: l, removeWatches: k.length && function () { for (var a = 0, b = k.length; a < b; ++a)k[a]() } }
                } var Ma = /^\w/, Fa = C.document.createElement("div"), Oa = t, Qa = N, Ja = G, Ua; w.prototype = {
                    $normalize: wa, $addClass: function (a) { a && 0 < a.length && R.addClass(this.$$element, a) }, $removeClass: function (a) { a && 0 < a.length && R.removeClass(this.$$element, a) }, $updateClass: function (a, b) { var c = sd(a, b); c && c.length && R.addClass(this.$$element, c); (c = sd(b, a)) && c.length && R.removeClass(this.$$element, c) }, $set: function (a, b, d, e) {
                        var f =
                            ld(this.$$element[0], a), g = td[a], h = a; f ? (this.$$element.prop(a, b), e = f) : g && (this[g] = b, h = g); this[a] = b; e ? this.$attr[a] = e : (e = this.$attr[a]) || (this.$attr[a] = e = Vc(a, "-")); "img" === ua(this.$$element) && "srcset" === a && (this[a] = b = ma(b, "$set('srcset', value)")); !1 !== d && (null === b || z(b) ? this.$$element.removeAttr(e) : Ma.test(e) ? f && !1 === b ? this.$$element.removeAttr(e) : this.$$element.attr(e, b) : O(this.$$element[0], e, b)); (a = this.$$observers) && r(a[h], function (a) { try { a(b) } catch (d) { c(d) } })
                    }, $observe: function (a, b) {
                        var c = this,
                        d = c.$$observers || (c.$$observers = T()), e = d[a] || (d[a] = []); e.push(b); L.$evalAsync(function () { e.$$inter || !c.hasOwnProperty(a) || z(c[a]) || b(c[a]) }); return function () { cb(e, b) }
                    }
                }; var Ka = b.startSymbol(), La = b.endSymbol(), Na = "{{" === Ka && "}}" === La ? Ta : function (a) { return a.replace(/\{\{/g, Ka).replace(/}}/g, La) }, Ra = /^ng(Attr|Prop|On)([A-Z].*)$/, Sa = /^(.+)Start$/; da.$$addBindingInfo = n ? function (a, b) { var c = a.data("$binding") || []; H(b) ? c = c.concat(b) : c.push(b); a.data("$binding", c) } : E; da.$$addBindingClass = n ? function (a) {
                    sa(a,
                        "ng-binding")
                } : E; da.$$addScopeInfo = n ? function (a, b, c, d) { a.data(c ? d ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope", b) } : E; da.$$addScopeClass = n ? function (a, b) { sa(a, b ? "ng-isolate-scope" : "ng-scope") } : E; da.$$createComment = function (a, b) { var c = ""; n && (c = " " + (a || "") + ": ", b && (c += b + " ")); return C.document.createComment(c) }; return da
            }]
        } function Jb(a, b) { this.previousValue = a; this.currentValue = b } function wa(a) { return a.replace(pd, "").replace(Eg, function (a, d, c) { return c ? d.toUpperCase() : d }) } function sd(a, b) {
            var d =
                "", c = a.split(/\s+/), e = b.split(/\s+/), f = 0; a: for (; f < c.length; f++) { for (var g = c[f], k = 0; k < e.length; k++)if (g === e[k]) continue a; d += (0 < d.length ? " " : "") + g } return d
        } function rd(a) { a = x(a); var b = a.length; if (1 >= b) return a; for (; b--;) { var d = a[b]; (8 === d.nodeType || d.nodeType === Pa && "" === d.nodeValue.trim()) && Fg.call(a, b, 1) } return a } function Bg(a, b) { if (b && A(b)) return b; if (A(a)) { var d = ud.exec(a); if (d) return d[3] } } function Ff() {
            var a = {}; this.has = function (b) { return a.hasOwnProperty(b) }; this.register = function (b, d) {
                Ja(b,
                    "controller"); D(b) ? S(a, b) : a[b] = d
            }; this.$get = ["$injector", function (b) {
                function d(a, b, d, g) { if (!a || !D(a.$scope)) throw F("$controller")("noscp", g, b); a.$scope[b] = d } return function (c, e, f, g) {
                    var k, h, l; f = !0 === f; g && A(g) && (l = g); if (A(c)) { g = c.match(ud); if (!g) throw vd("ctrlfmt", c); h = g[1]; l = l || g[3]; c = a.hasOwnProperty(h) ? a[h] : Ge(e.$scope, h, !0); if (!c) throw vd("ctrlreg", h); sb(c, h, !0) } if (f) return f = (H(c) ? c[c.length - 1] : c).prototype, k = Object.create(f || null), l && d(e, l, k, h || c.name), S(function () {
                        var a = b.invoke(c, k, e, h);
                        a !== k && (D(a) || B(a)) && (k = a, l && d(e, l, k, h || c.name)); return k
                    }, { instance: k, identifier: l }); k = b.instantiate(c, e, h); l && d(e, l, k, h || c.name); return k
                }
            }]
        } function Gf() { this.$get = ["$window", function (a) { return x(a.document) }] } function Hf() { this.$get = ["$document", "$rootScope", function (a, b) { function d() { e = c.hidden } var c = a[0], e = c && c.hidden; a.on("visibilitychange", d); b.$on("$destroy", function () { a.off("visibilitychange", d) }); return function () { return e } }] } function If() {
            this.$get = ["$log", function (a) {
                return function (b,
                    d) { a.error.apply(a, arguments) }
            }]
        } function uc(a) { return D(a) ? ha(a) ? a.toISOString() : eb(a) : a } function Of() { this.$get = function () { return function (a) { if (!a) return ""; var b = []; Oc(a, function (a, c) { null === a || z(a) || B(a) || (H(a) ? r(a, function (a) { b.push(ba(c) + "=" + ba(uc(a))) }) : b.push(ba(c) + "=" + ba(uc(a)))) }); return b.join("&") } } } function Pf() {
            this.$get = function () {
                return function (a) {
                    function b(a, e, f) {
                        H(a) ? r(a, function (a, c) { b(a, e + "[" + (D(a) ? c : "") + "]") }) : D(a) && !ha(a) ? Oc(a, function (a, c) { b(a, e + (f ? "" : "[") + c + (f ? "" : "]")) }) :
                            (B(a) && (a = a()), d.push(ba(e) + "=" + (null == a ? "" : ba(uc(a)))))
                    } if (!a) return ""; var d = []; b(a, "", !0); return d.join("&")
                }
            }
        } function vc(a, b) { if (A(a)) { var d = a.replace(Gg, "").trim(); if (d) { var c = b("Content-Type"), c = c && 0 === c.indexOf(wd), e; (e = c) || (e = (e = d.match(Hg)) && Ig[e[0]].test(d)); if (e) try { a = Rc(d) } catch (f) { if (!c) return a; throw Kb("baddata", a, f); } } } return a } function xd(a) {
            var b = T(), d; A(a) ? r(a.split("\n"), function (a) { d = a.indexOf(":"); var e = K(U(a.substr(0, d))); a = U(a.substr(d + 1)); e && (b[e] = b[e] ? b[e] + ", " + a : a) }) : D(a) &&
                r(a, function (a, d) { var f = K(d), g = U(a); f && (b[f] = b[f] ? b[f] + ", " + g : g) }); return b
        } function yd(a) { var b; return function (d) { b || (b = xd(a)); return d ? (d = b[K(d)], void 0 === d && (d = null), d) : b } } function zd(a, b, d, c) { if (B(c)) return c(a, b, d); r(c, function (c) { a = c(a, b, d) }); return a } function Nf() {
            var a = this.defaults = {
                transformResponse: [vc], transformRequest: [function (a) { return D(a) && "[object File]" !== la.call(a) && "[object Blob]" !== la.call(a) && "[object FormData]" !== la.call(a) ? eb(a) : a }], headers: {
                    common: { Accept: "application/json, text/plain, */*" },
                    post: ja(wc), put: ja(wc), patch: ja(wc)
                }, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", paramSerializer: "$httpParamSerializer", jsonpCallbackParam: "callback"
            }, b = !1; this.useApplyAsync = function (a) { return w(a) ? (b = !!a, this) : b }; var d = this.interceptors = [], c = this.xsrfWhitelistedOrigins = []; this.$get = ["$browser", "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", "$sce", function (e, f, g, k, h, l, m, p) {
                function n(b) {
                    function c(a, b) {
                        for (var d = 0, e = b.length; d < e;) {
                            var f = b[d++], g = b[d++];
                            a = a.then(f, g)
                        } b.length = 0; return a
                    } function d(a, b) { var c, e = {}; r(a, function (a, d) { B(a) ? (c = a(b), null != c && (e[d] = c)) : e[d] = a }); return e } function f(a) { var b = S({}, a); b.data = zd(a.data, a.headers, a.status, g.transformResponse); a = a.status; return 200 <= a && 300 > a ? b : l.reject(b) } if (!D(b)) throw F("$http")("badreq", b); if (!A(p.valueOf(b.url))) throw F("$http")("badreq", b.url); var g = S({ method: "get", transformRequest: a.transformRequest, transformResponse: a.transformResponse, paramSerializer: a.paramSerializer, jsonpCallbackParam: a.jsonpCallbackParam },
                        b); g.headers = function (b) { var c = a.headers, e = S({}, b.headers), f, g, h, c = S({}, c.common, c[K(b.method)]); a: for (f in c) { g = K(f); for (h in e) if (K(h) === g) continue a; e[f] = c[f] } return d(e, ja(b)) }(b); g.method = ub(g.method); g.paramSerializer = A(g.paramSerializer) ? m.get(g.paramSerializer) : g.paramSerializer; e.$$incOutstandingRequestCount("$http"); var h = [], k = []; b = l.resolve(g); r(v, function (a) { (a.request || a.requestError) && h.unshift(a.request, a.requestError); (a.response || a.responseError) && k.push(a.response, a.responseError) });
                    b = c(b, h); b = b.then(function (b) { var c = b.headers, d = zd(b.data, yd(c), void 0, b.transformRequest); z(d) && r(c, function (a, b) { "content-type" === K(b) && delete c[b] }); z(b.withCredentials) && !z(a.withCredentials) && (b.withCredentials = a.withCredentials); return s(b, d).then(f, f) }); b = c(b, k); return b = b.finally(function () { e.$$completeOutstandingRequest(E, "$http") })
                } function s(c, d) {
                    function e(a) { if (a) { var c = {}; r(a, function (a, d) { c[d] = function (c) { function d() { a(c) } b ? h.$applyAsync(d) : h.$$phase ? d() : h.$apply(d) } }); return c } } function k(a,
                        c, d, e, f) { function g() { m(c, a, d, e, f) } R && (200 <= a && 300 > a ? R.put(O, [a, c, xd(d), e, f]) : R.remove(O)); b ? h.$applyAsync(g) : (g(), h.$$phase || h.$apply()) } function m(a, b, d, e, f) { b = -1 <= b ? b : 0; (200 <= b && 300 > b ? L.resolve : L.reject)({ data: a, status: b, headers: yd(d), config: c, statusText: e, xhrStatus: f }) } function s(a) { m(a.data, a.status, ja(a.headers()), a.statusText, a.xhrStatus) } function v() { var a = n.pendingRequests.indexOf(c); -1 !== a && n.pendingRequests.splice(a, 1) } var L = l.defer(), u = L.promise, R, q, ma = c.headers, x = "jsonp" === K(c.method),
                            O = c.url; x ? O = p.getTrustedResourceUrl(O) : A(O) || (O = p.valueOf(O)); O = G(O, c.paramSerializer(c.params)); x && (O = t(O, c.jsonpCallbackParam)); n.pendingRequests.push(c); u.then(v, v); !c.cache && !a.cache || !1 === c.cache || "GET" !== c.method && "JSONP" !== c.method || (R = D(c.cache) ? c.cache : D(a.cache) ? a.cache : N); R && (q = R.get(O), w(q) ? q && B(q.then) ? q.then(s, s) : H(q) ? m(q[1], q[0], ja(q[2]), q[3], q[4]) : m(q, 200, {}, "OK", "complete") : R.put(O, u)); z(q) && ((q = jc(c.url) ? g()[c.xsrfCookieName || a.xsrfCookieName] : void 0) && (ma[c.xsrfHeaderName || a.xsrfHeaderName] =
                                q), f(c.method, O, d, k, ma, c.timeout, c.withCredentials, c.responseType, e(c.eventHandlers), e(c.uploadEventHandlers))); return u
                } function G(a, b) { 0 < b.length && (a += (-1 === a.indexOf("?") ? "?" : "&") + b); return a } function t(a, b) { var c = a.split("?"); if (2 < c.length) throw Kb("badjsonp", a); c = gc(c[1]); r(c, function (c, d) { if ("JSON_CALLBACK" === c) throw Kb("badjsonp", a); if (d === b) throw Kb("badjsonp", b, a); }); return a += (-1 === a.indexOf("?") ? "?" : "&") + b + "=JSON_CALLBACK" } var N = k("$http"); a.paramSerializer = A(a.paramSerializer) ? m.get(a.paramSerializer) :
                    a.paramSerializer; var v = []; r(d, function (a) { v.unshift(A(a) ? m.get(a) : m.invoke(a)) }); var jc = Jg(c); n.pendingRequests = []; (function (a) { r(arguments, function (a) { n[a] = function (b, c) { return n(S({}, c || {}, { method: a, url: b })) } }) })("get", "delete", "head", "jsonp"); (function (a) { r(arguments, function (a) { n[a] = function (b, c, d) { return n(S({}, d || {}, { method: a, url: b, data: c })) } }) })("post", "put", "patch"); n.defaults = a; return n
            }]
        } function Rf() { this.$get = function () { return function () { return new C.XMLHttpRequest } } } function Qf() {
            this.$get =
            ["$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function (a, b, d, c) { return Kg(a, c, a.defer, b, d[0]) }]
        } function Kg(a, b, d, c, e) {
            function f(a, b, d) {
                a = a.replace("JSON_CALLBACK", b); var f = e.createElement("script"), m = null; f.type = "text/javascript"; f.src = a; f.async = !0; m = function (a) { f.removeEventListener("load", m); f.removeEventListener("error", m); e.body.removeChild(f); f = null; var g = -1, s = "unknown"; a && ("load" !== a.type || c.wasCalled(b) || (a = { type: "error" }), s = a.type, g = "error" === a.type ? 404 : 200); d && d(g, s) }; f.addEventListener("load",
                    m); f.addEventListener("error", m); e.body.appendChild(f); return m
            } return function (e, k, h, l, m, p, n, s, G, t) {
                function N(a) { J = "timeout" === a; qa && qa(); y && y.abort() } function v(a, b, c, e, f, g) { w(P) && d.cancel(P); qa = y = null; a(b, c, e, f, g) } k = k || a.url(); if ("jsonp" === K(e)) var q = c.createCallback(k), qa = f(k, q, function (a, b) { var d = 200 === a && c.getResponse(q); v(l, a, d, "", b, "complete"); c.removeCallback(q) }); else {
                    var y = b(e, k), J = !1; y.open(e, k, !0); r(m, function (a, b) { w(a) && y.setRequestHeader(b, a) }); y.onload = function () {
                        var a = y.statusText ||
                            "", b = "response" in y ? y.response : y.responseText, c = 1223 === y.status ? 204 : y.status; 0 === c && (c = b ? 200 : "file" === ga(k).protocol ? 404 : 0); v(l, c, b, y.getAllResponseHeaders(), a, "complete")
                    }; y.onerror = function () { v(l, -1, null, null, "", "error") }; y.ontimeout = function () { v(l, -1, null, null, "", "timeout") }; y.onabort = function () { v(l, -1, null, null, "", J ? "timeout" : "abort") }; r(G, function (a, b) { y.addEventListener(b, a) }); r(t, function (a, b) { y.upload.addEventListener(b, a) }); n && (y.withCredentials = !0); if (s) try { y.responseType = s } catch (I) {
                        if ("json" !==
                            s) throw I;
                    } y.send(z(h) ? null : h)
                } if (0 < p) var P = d(function () { N("timeout") }, p); else p && B(p.then) && p.then(function () { N(w(p.$$timeoutId) ? "timeout" : "abort") })
            }
        } function Kf() {
            var a = "{{", b = "}}"; this.startSymbol = function (b) { return b ? (a = b, this) : a }; this.endSymbol = function (a) { return a ? (b = a, this) : b }; this.$get = ["$parse", "$exceptionHandler", "$sce", function (d, c, e) {
                function f(a) { return "\\\\\\" + a } function g(c) { return c.replace(p, a).replace(n, b) } function k(a, b, c, d) { var e = a.$watch(function (a) { e(); return d(a) }, b, c); return e }
                function h(f, h, n, p) {
                    function v(a) { try { return a = n && !r ? e.getTrusted(n, a) : e.valueOf(a), p && !w(a) ? a : ic(a) } catch (b) { c(Ma.interr(f, b)) } } var r = n === e.URL || n === e.MEDIA_URL; if (!f.length || -1 === f.indexOf(a)) { if (h) return; h = g(f); r && (h = e.getTrusted(n, h)); h = ia(h); h.exp = f; h.expressions = []; h.$$watchDelegate = k; return h } p = !!p; for (var q, y, J = 0, I = [], P, Q = f.length, M = [], L = [], u; J < Q;)if (-1 !== (q = f.indexOf(a, J)) && -1 !== (y = f.indexOf(b, q + l))) J !== q && M.push(g(f.substring(J, q))), J = f.substring(q + l, y), I.push(J), J = y + m, L.push(M.length),
                        M.push(""); else { J !== Q && M.push(g(f.substring(J))); break } u = 1 === M.length && 1 === L.length; var R = r && u ? void 0 : v; P = I.map(function (a) { return d(a, R) }); if (!h || I.length) {
                            var x = function (a) { for (var b = 0, c = I.length; b < c; b++) { if (p && z(a[b])) return; M[L[b]] = a[b] } if (r) return e.getTrusted(n, u ? M[0] : M.join("")); n && 1 < M.length && Ma.throwNoconcat(f); return M.join("") }; return S(function (a) { var b = 0, d = I.length, e = Array(d); try { for (; b < d; b++)e[b] = P[b](a); return x(e) } catch (g) { c(Ma.interr(f, g)) } }, {
                                exp: f, expressions: I, $$watchDelegate: function (a,
                                    b) { var c; return a.$watchGroup(P, function (d, e) { var f = x(d); b.call(this, f, d !== e ? c : f, a); c = f }) }
                            })
                        }
                } var l = a.length, m = b.length, p = new RegExp(a.replace(/./g, f), "g"), n = new RegExp(b.replace(/./g, f), "g"); h.startSymbol = function () { return a }; h.endSymbol = function () { return b }; return h
            }]
        } function Lf() {
            this.$get = ["$$intervalFactory", "$window", function (a, b) {
                var d = {}, c = function (a) { b.clearInterval(a); delete d[a] }, e = a(function (a, c, e) { a = b.setInterval(a, c); d[a] = e; return a }, c); e.cancel = function (a) {
                    if (!a) return !1; if (!a.hasOwnProperty("$$intervalId")) throw Lg("badprom");
                    if (!d.hasOwnProperty(a.$$intervalId)) return !1; a = a.$$intervalId; var b = d[a], e = b.promise; e.$$state && (e.$$state.pur = !0); b.reject("canceled"); c(a); return !0
                }; return e
            }]
        } function Mf() {
            this.$get = ["$browser", "$q", "$$q", "$rootScope", function (a, b, d, c) {
                return function (e, f) {
                    return function (g, k, h, l) {
                        function m() { p ? g.apply(null, n) : g(s) } var p = 4 < arguments.length, n = p ? Ha.call(arguments, 4) : [], s = 0, G = w(l) && !l, t = (G ? d : b).defer(), r = t.promise; h = w(h) ? h : 0; r.$$intervalId = e(function () {
                            G ? a.defer(m) : c.$evalAsync(m); t.notify(s++);
                            0 < h && s >= h && (t.resolve(s), f(r.$$intervalId)); G || c.$apply()
                        }, k, t, G); return r
                    }
                }
            }]
        } function Ad(a, b) { var d = ga(a); b.$$protocol = d.protocol; b.$$host = d.hostname; b.$$port = fa(d.port) || Mg[d.protocol] || null } function Bd(a, b, d) {
            if (Ng.test(a)) throw jb("badpath", a); var c = "/" !== a.charAt(0); c && (a = "/" + a); a = ga(a); for (var c = (c && "/" === a.pathname.charAt(0) ? a.pathname.substring(1) : a.pathname).split("/"), e = c.length; e--;)c[e] = decodeURIComponent(c[e]), d && (c[e] = c[e].replace(/\//g, "%2F")); d = c.join("/"); b.$$path = d; b.$$search = gc(a.search);
            b.$$hash = decodeURIComponent(a.hash); b.$$path && "/" !== b.$$path.charAt(0) && (b.$$path = "/" + b.$$path)
        } function xc(a, b) { return a.slice(0, b.length) === b } function xa(a, b) { if (xc(b, a)) return b.substr(a.length) } function Da(a) { var b = a.indexOf("#"); return -1 === b ? a : a.substr(0, b) } function yc(a, b, d) {
            this.$$html5 = !0; d = d || ""; Ad(a, this); this.$$parse = function (a) { var d = xa(b, a); if (!A(d)) throw jb("ipthprfx", a, b); Bd(d, this, !0); this.$$path || (this.$$path = "/"); this.$$compose() }; this.$$normalizeUrl = function (a) { return b + a.substr(1) };
            this.$$parseLinkUrl = function (c, e) { if (e && "#" === e[0]) return this.hash(e.slice(1)), !0; var f, g; w(f = xa(a, c)) ? (g = f, g = d && w(f = xa(d, f)) ? b + (xa("/", f) || f) : a + g) : w(f = xa(b, c)) ? g = b + f : b === c + "/" && (g = b); g && this.$$parse(g); return !!g }
        } function zc(a, b, d) {
            Ad(a, this); this.$$parse = function (c) {
                var e = xa(a, c) || xa(b, c), f; z(e) || "#" !== e.charAt(0) ? this.$$html5 ? f = e : (f = "", z(e) && (a = c, this.replace())) : (f = xa(d, e), z(f) && (f = e)); Bd(f, this, !1); c = this.$$path; var e = a, g = /^\/[A-Z]:(\/.*)/; xc(f, e) && (f = f.replace(e, "")); g.exec(f) || (c = (f = g.exec(c)) ?
                    f[1] : c); this.$$path = c; this.$$compose()
            }; this.$$normalizeUrl = function (b) { return a + (b ? d + b : "") }; this.$$parseLinkUrl = function (b, d) { return Da(a) === Da(b) ? (this.$$parse(b), !0) : !1 }
        } function Cd(a, b, d) { this.$$html5 = !0; zc.apply(this, arguments); this.$$parseLinkUrl = function (c, e) { if (e && "#" === e[0]) return this.hash(e.slice(1)), !0; var f, g; a === Da(c) ? f = c : (g = xa(b, c)) ? f = a + d + g : b === c + "/" && (f = b); f && this.$$parse(f); return !!f }; this.$$normalizeUrl = function (b) { return a + d + b } } function Lb(a) { return function () { return this[a] } } function Dd(a,
            b) { return function (d) { if (z(d)) return this[a]; this[a] = b(d); this.$$compose(); return this } } function Tf() {
                var a = "!", b = { enabled: !1, requireBase: !0, rewriteLinks: !0 }; this.hashPrefix = function (b) { return w(b) ? (a = b, this) : a }; this.html5Mode = function (a) { if (Ga(a)) return b.enabled = a, this; if (D(a)) { Ga(a.enabled) && (b.enabled = a.enabled); Ga(a.requireBase) && (b.requireBase = a.requireBase); if (Ga(a.rewriteLinks) || A(a.rewriteLinks)) b.rewriteLinks = a.rewriteLinks; return this } return b }; this.$get = ["$rootScope", "$browser", "$sniffer",
                    "$rootElement", "$window", function (d, c, e, f, g) {
                        function k(a, b) { return a === b || ga(a).href === ga(b).href } function h(a, b, d) { var e = m.url(), f = m.$$state; try { c.url(a, b, d), m.$$state = c.state() } catch (g) { throw m.url(e), m.$$state = f, g; } } function l(a, b) { d.$broadcast("$locationChangeSuccess", m.absUrl(), a, m.$$state, b) } var m, p; p = c.baseHref(); var n = c.url(), s; if (b.enabled) { if (!p && b.requireBase) throw jb("nobase"); s = n.substring(0, n.indexOf("/", n.indexOf("//") + 2)) + (p || "/"); p = e.history ? yc : Cd } else s = Da(n), p = zc; var r = s.substr(0,
                            Da(s).lastIndexOf("/") + 1); m = new p(s, r, "#" + a); m.$$parseLinkUrl(n, n); m.$$state = c.state(); var t = /^\s*(javascript|mailto):/i; f.on("click", function (a) {
                                var e = b.rewriteLinks; if (e && !a.ctrlKey && !a.metaKey && !a.shiftKey && 2 !== a.which && 2 !== a.button) {
                                    for (var g = x(a.target); "a" !== ua(g[0]);)if (g[0] === f[0] || !(g = g.parent())[0]) return; if (!A(e) || !z(g.attr(e))) {
                                        var e = g.prop("href"), h = g.attr("href") || g.attr("xlink:href"); D(e) && "[object SVGAnimatedString]" === e.toString() && (e = ga(e.animVal).href); t.test(e) || !e || g.attr("target") ||
                                            a.isDefaultPrevented() || !m.$$parseLinkUrl(e, h) || (a.preventDefault(), m.absUrl() !== c.url() && d.$apply())
                                    }
                                }
                            }); m.absUrl() !== n && c.url(m.absUrl(), !0); var N = !0; c.onUrlChange(function (a, b) { xc(a, r) ? (d.$evalAsync(function () { var c = m.absUrl(), e = m.$$state, f; m.$$parse(a); m.$$state = b; f = d.$broadcast("$locationChangeStart", a, c, b, e).defaultPrevented; m.absUrl() === a && (f ? (m.$$parse(c), m.$$state = e, h(c, !1, e)) : (N = !1, l(c, e))) }), d.$$phase || d.$digest()) : g.location.href = a }); d.$watch(function () {
                                if (N || m.$$urlUpdatedByLocation) {
                                    m.$$urlUpdatedByLocation =
                                    !1; var a = c.url(), b = m.absUrl(), f = c.state(), g = m.$$replace, n = !k(a, b) || m.$$html5 && e.history && f !== m.$$state; if (N || n) N = !1, d.$evalAsync(function () { var b = m.absUrl(), c = d.$broadcast("$locationChangeStart", b, a, m.$$state, f).defaultPrevented; m.absUrl() === b && (c ? (m.$$parse(a), m.$$state = f) : (n && h(b, g, f === m.$$state ? null : m.$$state), l(a, f))) })
                                } m.$$replace = !1
                            }); return m
                    }]
            } function Uf() {
                var a = !0, b = this; this.debugEnabled = function (b) { return w(b) ? (a = b, this) : a }; this.$get = ["$window", function (d) {
                    function c(a) {
                        cc(a) && (a.stack &&
                            f ? a = a.message && -1 === a.stack.indexOf(a.message) ? "Error: " + a.message + "\n" + a.stack : a.stack : a.sourceURL && (a = a.message + "\n" + a.sourceURL + ":" + a.line)); return a
                    } function e(a) { var b = d.console || {}, e = b[a] || b.log || E; return function () { var a = []; r(arguments, function (b) { a.push(c(b)) }); return Function.prototype.apply.call(e, b, a) } } var f = Ca || /\bEdge\//.test(d.navigator && d.navigator.userAgent); return {
                        log: e("log"), info: e("info"), warn: e("warn"), error: e("error"), debug: function () {
                            var c = e("debug"); return function () {
                                a && c.apply(b,
                                    arguments)
                            }
                        }()
                    }
                }]
            } function Og(a) { return a + "" } function Pg(a, b) { return "undefined" !== typeof a ? a : b } function Ed(a, b) { return "undefined" === typeof a ? b : "undefined" === typeof b ? a : a + b } function Qg(a, b) { switch (a.type) { case q.MemberExpression: if (a.computed) return !1; break; case q.UnaryExpression: return 1; case q.BinaryExpression: return "+" !== a.operator ? 1 : !1; case q.CallExpression: return !1 }return void 0 === b ? Fd : b } function Z(a, b, d) {
                var c, e, f = a.isPure = Qg(a, d); switch (a.type) {
                    case q.Program: c = !0; r(a.body, function (a) {
                        Z(a.expression,
                            b, f); c = c && a.expression.constant
                    }); a.constant = c; break; case q.Literal: a.constant = !0; a.toWatch = []; break; case q.UnaryExpression: Z(a.argument, b, f); a.constant = a.argument.constant; a.toWatch = a.argument.toWatch; break; case q.BinaryExpression: Z(a.left, b, f); Z(a.right, b, f); a.constant = a.left.constant && a.right.constant; a.toWatch = a.left.toWatch.concat(a.right.toWatch); break; case q.LogicalExpression: Z(a.left, b, f); Z(a.right, b, f); a.constant = a.left.constant && a.right.constant; a.toWatch = a.constant ? [] : [a]; break; case q.ConditionalExpression: Z(a.test,
                        b, f); Z(a.alternate, b, f); Z(a.consequent, b, f); a.constant = a.test.constant && a.alternate.constant && a.consequent.constant; a.toWatch = a.constant ? [] : [a]; break; case q.Identifier: a.constant = !1; a.toWatch = [a]; break; case q.MemberExpression: Z(a.object, b, f); a.computed && Z(a.property, b, f); a.constant = a.object.constant && (!a.computed || a.property.constant); a.toWatch = a.constant ? [] : [a]; break; case q.CallExpression: c = d = a.filter ? !b(a.callee.name).$stateful : !1; e = []; r(a.arguments, function (a) {
                            Z(a, b, f); c = c && a.constant; e.push.apply(e,
                                a.toWatch)
                        }); a.constant = c; a.toWatch = d ? e : [a]; break; case q.AssignmentExpression: Z(a.left, b, f); Z(a.right, b, f); a.constant = a.left.constant && a.right.constant; a.toWatch = [a]; break; case q.ArrayExpression: c = !0; e = []; r(a.elements, function (a) { Z(a, b, f); c = c && a.constant; e.push.apply(e, a.toWatch) }); a.constant = c; a.toWatch = e; break; case q.ObjectExpression: c = !0; e = []; r(a.properties, function (a) {
                            Z(a.value, b, f); c = c && a.value.constant; e.push.apply(e, a.value.toWatch); a.computed && (Z(a.key, b, !1), c = c && a.key.constant, e.push.apply(e,
                                a.key.toWatch))
                        }); a.constant = c; a.toWatch = e; break; case q.ThisExpression: a.constant = !1; a.toWatch = []; break; case q.LocalsExpression: a.constant = !1, a.toWatch = []
                }
            } function Gd(a) { if (1 === a.length) { a = a[0].expression; var b = a.toWatch; return 1 !== b.length ? b : b[0] !== a ? b : void 0 } } function Hd(a) { return a.type === q.Identifier || a.type === q.MemberExpression } function Id(a) { if (1 === a.body.length && Hd(a.body[0].expression)) return { type: q.AssignmentExpression, left: a.body[0].expression, right: { type: q.NGValueParameter }, operator: "=" } }
    function Jd(a) { this.$filter = a } function Kd(a) { this.$filter = a } function Mb(a, b, d) { this.ast = new q(a, d); this.astCompiler = d.csp ? new Kd(b) : new Jd(b) } function Ac(a) { return B(a.valueOf) ? a.valueOf() : Rg.call(a) } function Vf() {
        var a = T(), b = { "true": !0, "false": !1, "null": null, undefined: void 0 }, d, c; this.addLiteral = function (a, c) { b[a] = c }; this.setIdentifierFns = function (a, b) { d = a; c = b; return this }; this.$get = ["$filter", function (e) {
            function f(b, c) {
                var d, f; switch (typeof b) {
                    case "string": return f = b = b.trim(), d = a[f], d || (d = new Nb(G),
                        d = (new Mb(d, e, G)).parse(b), a[f] = p(d)), s(d, c); case "function": return s(b, c); default: return s(E, c)
                }
            } function g(a, b, c) { return null == a || null == b ? a === b : "object" !== typeof a || (a = Ac(a), "object" !== typeof a || c) ? a === b || a !== a && b !== b : !1 } function k(a, b, c, d, e) {
                var f = d.inputs, h; if (1 === f.length) { var k = g, f = f[0]; return a.$watch(function (a) { var b = f(a); g(b, k, f.isPure) || (h = d(a, void 0, void 0, [b]), k = b && Ac(b)); return h }, b, c, e) } for (var l = [], m = [], n = 0, p = f.length; n < p; n++)l[n] = g, m[n] = null; return a.$watch(function (a) {
                    for (var b =
                        !1, c = 0, e = f.length; c < e; c++) { var k = f[c](a); if (b || (b = !g(k, l[c], f[c].isPure))) m[c] = k, l[c] = k && Ac(k) } b && (h = d(a, void 0, void 0, m)); return h
                }, b, c, e)
            } function h(a, b, c, d, e) { function f() { h(m) && k() } function g(a, b, c, d) { m = u && d ? d[0] : n(a, b, c, d); h(m) && a.$$postDigest(f); return s(m) } var h = d.literal ? l : w, k, m, n = d.$$intercepted || d, s = d.$$interceptor || Ta, u = d.inputs && !n.inputs; g.literal = d.literal; g.constant = d.constant; g.inputs = d.inputs; p(g); return k = a.$watch(g, b, c, e) } function l(a) { var b = !0; r(a, function (a) { w(a) || (b = !1) }); return b }
            function m(a, b, c, d) { var e = a.$watch(function (a) { e(); return d(a) }, b, c); return e } function p(a) { a.constant ? a.$$watchDelegate = m : a.oneTime ? a.$$watchDelegate = h : a.inputs && (a.$$watchDelegate = k); return a } function n(a, b) { function c(d) { return b(a(d)) } c.$stateful = a.$stateful || b.$stateful; c.$$pure = a.$$pure && b.$$pure; return c } function s(a, b) {
                if (!b) return a; a.$$interceptor && (b = n(a.$$interceptor, b), a = a.$$intercepted); var c = !1, d = function (d, e, f, g) { d = c && g ? g[0] : a(d, e, f, g); return b(d) }; d.$$intercepted = a; d.$$interceptor =
                    b; d.literal = a.literal; d.oneTime = a.oneTime; d.constant = a.constant; b.$stateful || (c = !a.inputs, d.inputs = a.inputs ? a.inputs : [a], b.$$pure || (d.inputs = d.inputs.map(function (a) { return a.isPure === Fd ? function (b) { return a(b) } : a }))); return p(d)
            } var G = { csp: Aa().noUnsafeEval, literals: Ia(b), isIdentifierStart: B(d) && d, isIdentifierContinue: B(c) && c }; f.$$getAst = function (a) { var b = new Nb(G); return (new Mb(b, e, G)).getAst(a).ast }; return f
        }]
    } function Xf() {
        var a = !0; this.$get = ["$rootScope", "$exceptionHandler", function (b, d) {
            return Ld(function (a) { b.$evalAsync(a) },
                d, a)
        }]; this.errorOnUnhandledRejections = function (b) { return w(b) ? (a = b, this) : a }
    } function Yf() { var a = !0; this.$get = ["$browser", "$exceptionHandler", function (b, d) { return Ld(function (a) { b.defer(a) }, d, a) }]; this.errorOnUnhandledRejections = function (b) { return w(b) ? (a = b, this) : a } } function Ld(a, b, d) {
        function c() { return new e } function e() { var a = this.promise = new f; this.resolve = function (b) { h(a, b) }; this.reject = function (b) { m(a, b) }; this.notify = function (b) { n(a, b) } } function f() { this.$$state = { status: 0 } } function g() {
            for (; !w &&
                x.length;) { var a = x.shift(); if (!a.pur) { a.pur = !0; var c = a.value, c = "Possibly unhandled rejection: " + ("function" === typeof c ? c.toString().replace(/ \{[\s\S]*$/, "") : z(c) ? "undefined" : "string" !== typeof c ? Ie(c, void 0) : c); cc(a.value) ? b(a.value, c) : b(c) } }
        } function k(c) {
            !d || c.pending || 2 !== c.status || c.pur || (0 === w && 0 === x.length && a(g), x.push(c)); !c.processScheduled && c.pending && (c.processScheduled = !0, ++w, a(function () {
                var e, f, k; k = c.pending; c.processScheduled = !1; c.pending = void 0; try {
                    for (var l = 0, n = k.length; l < n; ++l) {
                        c.pur =
                        !0; f = k[l][0]; e = k[l][c.status]; try { B(e) ? h(f, e(c.value)) : 1 === c.status ? h(f, c.value) : m(f, c.value) } catch (p) { m(f, p), p && !0 === p.$$passToExceptionHandler && b(p) }
                    }
                } finally { --w, d && 0 === w && a(g) }
            }))
        } function h(a, b) { a.$$state.status || (b === a ? p(a, v("qcycle", b)) : l(a, b)) } function l(a, b) { function c(b) { g || (g = !0, l(a, b)) } function d(b) { g || (g = !0, p(a, b)) } function e(b) { n(a, b) } var f, g = !1; try { if (D(b) || B(b)) f = b.then; B(f) ? (a.$$state.status = -1, f.call(b, c, d, e)) : (a.$$state.value = b, a.$$state.status = 1, k(a.$$state)) } catch (h) { d(h) } } function m(a,
            b) { a.$$state.status || p(a, b) } function p(a, b) { a.$$state.value = b; a.$$state.status = 2; k(a.$$state) } function n(c, d) { var e = c.$$state.pending; 0 >= c.$$state.status && e && e.length && a(function () { for (var a, c, f = 0, g = e.length; f < g; f++) { c = e[f][0]; a = e[f][3]; try { n(c, B(a) ? a(d) : d) } catch (h) { b(h) } } }) } function s(a) { var b = new f; m(b, a); return b } function G(a, b, c) { var d = null; try { B(c) && (d = c()) } catch (e) { return s(e) } return d && B(d.then) ? d.then(function () { return b(a) }, s) : b(a) } function t(a, b, c, d) {
                var e = new f; h(e, a); return e.then(b, c,
                    d)
            } function q(a) { if (!B(a)) throw v("norslvr", a); var b = new f; a(function (a) { h(b, a) }, function (a) { m(b, a) }); return b } var v = F("$q", TypeError), w = 0, x = []; S(f.prototype, {
                then: function (a, b, c) { if (z(a) && z(b) && z(c)) return this; var d = new f; this.$$state.pending = this.$$state.pending || []; this.$$state.pending.push([d, a, b, c]); 0 < this.$$state.status && k(this.$$state); return d }, "catch": function (a) { return this.then(null, a) }, "finally": function (a, b) {
                    return this.then(function (b) { return G(b, y, a) }, function (b) { return G(b, s, a) },
                        b)
                }
            }); var y = t; q.prototype = f.prototype; q.defer = c; q.reject = s; q.when = t; q.resolve = y; q.all = function (a) { var b = new f, c = 0, d = H(a) ? [] : {}; r(a, function (a, e) { c++; t(a).then(function (a) { d[e] = a; --c || h(b, d) }, function (a) { m(b, a) }) }); 0 === c && h(b, d); return b }; q.race = function (a) { var b = c(); r(a, function (a) { t(a).then(b.resolve, b.reject) }); return b.promise }; return q
    } function hg() {
        this.$get = ["$window", "$timeout", function (a, b) {
            var d = a.requestAnimationFrame || a.webkitRequestAnimationFrame, c = a.cancelAnimationFrame || a.webkitCancelAnimationFrame ||
                a.webkitCancelRequestAnimationFrame, e = !!d, f = e ? function (a) { var b = d(a); return function () { c(b) } } : function (a) { var c = b(a, 16.66, !1); return function () { b.cancel(c) } }; f.supported = e; return f
        }]
    } function Wf() {
        function a(a) { function b() { this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null; this.$$listeners = {}; this.$$listenerCount = {}; this.$$watchersCount = 0; this.$id = ++pb; this.$$ChildScope = null; this.$$suspended = !1 } b.prototype = a; return b } var b = 10, d = F("$rootScope"), c = null, e = null; this.digestTtl =
            function (a) { arguments.length && (b = a); return b }; this.$get = ["$exceptionHandler", "$parse", "$browser", function (f, g, k) {
                function h(a) { a.currentScope.$$destroyed = !0 } function l(a) { 9 === Ca && (a.$$childHead && l(a.$$childHead), a.$$nextSibling && l(a.$$nextSibling)); a.$parent = a.$$nextSibling = a.$$prevSibling = a.$$childHead = a.$$childTail = a.$root = a.$$watchers = null } function m() {
                    this.$id = ++pb; this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null; this.$root =
                        this; this.$$suspended = this.$$destroyed = !1; this.$$listeners = {}; this.$$listenerCount = {}; this.$$watchersCount = 0; this.$$isolateBindings = null
                } function p(a) { if (v.$$phase) throw d("inprog", v.$$phase); v.$$phase = a } function n(a, b) { do a.$$watchersCount += b; while (a = a.$parent) } function s(a, b, c) { do a.$$listenerCount[c] -= b, 0 === a.$$listenerCount[c] && delete a.$$listenerCount[c]; while (a = a.$parent) } function G() { } function t() { for (; y.length;)try { y.shift()() } catch (a) { f(a) } e = null } function q() {
                    null === e && (e = k.defer(function () { v.$apply(t) },
                        null, "$applyAsync"))
                } m.prototype = {
                    constructor: m, $new: function (b, c) { var d; c = c || this; b ? (d = new m, d.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = a(this)), d = new this.$$ChildScope); d.$parent = c; d.$$prevSibling = c.$$childTail; c.$$childHead ? (c.$$childTail.$$nextSibling = d, c.$$childTail = d) : c.$$childHead = c.$$childTail = d; (b || c !== this) && d.$on("$destroy", h); return d }, $watch: function (a, b, d, e) {
                        var f = g(a); b = B(b) ? b : E; if (f.$$watchDelegate) return f.$$watchDelegate(this, b, d, f, a); var h = this, k = h.$$watchers, l =
                            { fn: b, last: G, get: f, exp: e || a, eq: !!d }; c = null; k || (k = h.$$watchers = [], k.$$digestWatchIndex = -1); k.unshift(l); k.$$digestWatchIndex++; n(this, 1); return function () { var a = cb(k, l); 0 <= a && (n(h, -1), a < k.$$digestWatchIndex && k.$$digestWatchIndex--); c = null }
                    }, $watchGroup: function (a, b) {
                        function c() { h = !1; try { k ? (k = !1, b(e, e, g)) : b(e, d, g) } finally { for (var f = 0; f < a.length; f++)d[f] = e[f] } } var d = Array(a.length), e = Array(a.length), f = [], g = this, h = !1, k = !0; if (!a.length) {
                            var l = !0; g.$evalAsync(function () { l && b(e, e, g) }); return function () {
                                l =
                                !1
                            }
                        } if (1 === a.length) return this.$watch(a[0], function (a, c, f) { e[0] = a; d[0] = c; b(e, a === c ? e : d, f) }); r(a, function (a, b) { var d = g.$watch(a, function (a) { e[b] = a; h || (h = !0, g.$evalAsync(c)) }); f.push(d) }); return function () { for (; f.length;)f.shift()() }
                    }, $watchCollection: function (a, b) {
                        function c(a) {
                            e = a; var b, d, g, h; if (!z(e)) {
                                if (D(e)) if (ya(e)) for (f !== n && (f = n, t = f.length = 0, l++), a = e.length, t !== a && (l++, f.length = t = a), b = 0; b < a; b++)h = f[b], g = e[b], d = h !== h && g !== g, d || h === g || (l++, f[b] = g); else {
                                    f !== p && (f = p = {}, t = 0, l++); a = 0; for (b in e) ta.call(e,
                                        b) && (a++, g = e[b], h = f[b], b in f ? (d = h !== h && g !== g, d || h === g || (l++, f[b] = g)) : (t++, f[b] = g, l++)); if (t > a) for (b in l++, f) ta.call(e, b) || (t--, delete f[b])
                                } else f !== e && (f = e, l++); return l
                            }
                        } c.$$pure = g(a).literal; c.$stateful = !c.$$pure; var d = this, e, f, h, k = 1 < b.length, l = 0, m = g(a, c), n = [], p = {}, s = !0, t = 0; return this.$watch(m, function () { s ? (s = !1, b(e, e, d)) : b(e, h, d); if (k) if (D(e)) if (ya(e)) { h = Array(e.length); for (var a = 0; a < e.length; a++)h[a] = e[a] } else for (a in h = {}, e) ta.call(e, a) && (h[a] = e[a]); else h = e })
                    }, $digest: function () {
                        var a,
                        g, h, l, m, n, s, r = b, q, y = w.length ? v : this, N = [], z, A; p("$digest"); k.$$checkUrlChange(); this === v && null !== e && (k.defer.cancel(e), t()); c = null; do {
                            s = !1; q = y; for (n = 0; n < w.length; n++) { try { A = w[n], l = A.fn, l(A.scope, A.locals) } catch (C) { f(C) } c = null } w.length = 0; a: do {
                                if (n = !q.$$suspended && q.$$watchers) for (n.$$digestWatchIndex = n.length; n.$$digestWatchIndex--;)try {
                                    if (a = n[n.$$digestWatchIndex]) if (m = a.get, (g = m(q)) !== (h = a.last) && !(a.eq ? va(g, h) : X(g) && X(h))) s = !0, c = a, a.last = a.eq ? Ia(g, null) : g, l = a.fn, l(g, h === G ? g : h, q), 5 > r && (z = 4 - r, N[z] ||
                                        (N[z] = []), N[z].push({ msg: B(a.exp) ? "fn: " + (a.exp.name || a.exp.toString()) : a.exp, newVal: g, oldVal: h })); else if (a === c) { s = !1; break a }
                                } catch (E) { f(E) } if (!(n = !q.$$suspended && q.$$watchersCount && q.$$childHead || q !== y && q.$$nextSibling)) for (; q !== y && !(n = q.$$nextSibling);)q = q.$parent
                            } while (q = n); if ((s || w.length) && !r--) throw v.$$phase = null, d("infdig", b, N);
                        } while (s || w.length); for (v.$$phase = null; J < x.length;)try { x[J++]() } catch (D) { f(D) } x.length = J = 0; k.$$checkUrlChange()
                    }, $suspend: function () { this.$$suspended = !0 }, $isSuspended: function () { return this.$$suspended },
                    $resume: function () { this.$$suspended = !1 }, $destroy: function () {
                        if (!this.$$destroyed) {
                            var a = this.$parent; this.$broadcast("$destroy"); this.$$destroyed = !0; this === v && k.$$applicationDestroyed(); n(this, -this.$$watchersCount); for (var b in this.$$listenerCount) s(this, this.$$listenerCount[b], b); a && a.$$childHead === this && (a.$$childHead = this.$$nextSibling); a && a.$$childTail === this && (a.$$childTail = this.$$prevSibling); this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling); this.$$nextSibling && (this.$$nextSibling.$$prevSibling =
                                this.$$prevSibling); this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = E; this.$on = this.$watch = this.$watchGroup = function () { return E }; this.$$listeners = {}; this.$$nextSibling = null; l(this)
                        }
                    }, $eval: function (a, b) { return g(a)(this, b) }, $evalAsync: function (a, b) { v.$$phase || w.length || k.defer(function () { w.length && v.$digest() }, null, "$evalAsync"); w.push({ scope: this, fn: g(a), locals: b }) }, $$postDigest: function (a) { x.push(a) }, $apply: function (a) {
                        try {
                            p("$apply"); try { return this.$eval(a) } finally {
                                v.$$phase =
                                null
                            }
                        } catch (b) { f(b) } finally { try { v.$digest() } catch (c) { throw f(c), c; } }
                    }, $applyAsync: function (a) { function b() { c.$eval(a) } var c = this; a && y.push(b); a = g(a); q() }, $on: function (a, b) { var c = this.$$listeners[a]; c || (this.$$listeners[a] = c = []); c.push(b); var d = this; do d.$$listenerCount[a] || (d.$$listenerCount[a] = 0), d.$$listenerCount[a]++; while (d = d.$parent); var e = this; return function () { var d = c.indexOf(b); -1 !== d && (delete c[d], s(e, 1, a)) } }, $emit: function (a, b) {
                        var c = [], d, e = this, g = !1, h = {
                            name: a, targetScope: e, stopPropagation: function () {
                                g =
                                !0
                            }, preventDefault: function () { h.defaultPrevented = !0 }, defaultPrevented: !1
                        }, k = db([h], arguments, 1), l, m; do { d = e.$$listeners[a] || c; h.currentScope = e; l = 0; for (m = d.length; l < m; l++)if (d[l]) try { d[l].apply(null, k) } catch (n) { f(n) } else d.splice(l, 1), l--, m--; if (g) break; e = e.$parent } while (e); h.currentScope = null; return h
                    }, $broadcast: function (a, b) {
                        var c = this, d = this, e = { name: a, targetScope: this, preventDefault: function () { e.defaultPrevented = !0 }, defaultPrevented: !1 }; if (!this.$$listenerCount[a]) return e; for (var g = db([e], arguments,
                            1), h, k; c = d;) { e.currentScope = c; d = c.$$listeners[a] || []; h = 0; for (k = d.length; h < k; h++)if (d[h]) try { d[h].apply(null, g) } catch (l) { f(l) } else d.splice(h, 1), h--, k--; if (!(d = c.$$listenerCount[a] && c.$$childHead || c !== this && c.$$nextSibling)) for (; c !== this && !(d = c.$$nextSibling);)c = c.$parent } e.currentScope = null; return e
                    }
                }; var v = new m, w = v.$$asyncQueue = [], x = v.$$postDigestQueue = [], y = v.$$applyAsyncQueue = [], J = 0; return v
            }]
    } function Le() {
        var a = /^\s*(https?|s?ftp|mailto|tel|file):/, b = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function (b) { return w(b) ? (a = b, this) : a }; this.imgSrcSanitizationWhitelist = function (a) { return w(a) ? (b = a, this) : b }; this.$get = function () { return function (d, c) { var e = c ? b : a, f = ga(d && d.trim()).href; return "" === f || f.match(e) ? d : "unsafe:" + f } }
    } function Sg(a) {
        if ("self" === a) return a; if (A(a)) { if (-1 < a.indexOf("***")) throw Ea("iwcard", a); a = Md(a).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*"); return new RegExp("^" + a + "$") } if (ab(a)) return new RegExp("^" + a.source + "$"); throw Ea("imatcher");
    } function Nd(a) { var b = []; w(a) && r(a, function (a) { b.push(Sg(a)) }); return b } function $f() {
        this.SCE_CONTEXTS = V; var a = ["self"], b = []; this.resourceUrlWhitelist = function (b) { arguments.length && (a = Nd(b)); return a }; this.resourceUrlBlacklist = function (a) { arguments.length && (b = Nd(a)); return b }; this.$get = ["$injector", "$$sanitizeUri", function (d, c) {
            function e(a, b) {
                var c; "self" === a ? (c = Bc(b, Od)) || (C.document.baseURI ? c = C.document.baseURI : (Na || (Na = C.document.createElement("a"), Na.href = ".", Na = Na.cloneNode(!1)), c = Na.href),
                    c = Bc(b, c)) : c = !!a.exec(b.href); return c
            } function f(a) { var b = function (a) { this.$$unwrapTrustedValue = function () { return a } }; a && (b.prototype = new a); b.prototype.valueOf = function () { return this.$$unwrapTrustedValue() }; b.prototype.toString = function () { return this.$$unwrapTrustedValue().toString() }; return b } var g = function (a) { throw Ea("unsafe"); }; d.has("$sanitize") && (g = d.get("$sanitize")); var k = f(), h = {}; h[V.HTML] = f(k); h[V.CSS] = f(k); h[V.MEDIA_URL] = f(k); h[V.URL] = f(h[V.MEDIA_URL]); h[V.JS] = f(k); h[V.RESOURCE_URL] =
                f(h[V.URL]); return {
                    trustAs: function (a, b) { var c = h.hasOwnProperty(a) ? h[a] : null; if (!c) throw Ea("icontext", a, b); if (null === b || z(b) || "" === b) return b; if ("string" !== typeof b) throw Ea("itype", a); return new c(b) }, getTrusted: function (d, f) {
                        if (null === f || z(f) || "" === f) return f; var k = h.hasOwnProperty(d) ? h[d] : null; if (k && f instanceof k) return f.$$unwrapTrustedValue(); B(f.$$unwrapTrustedValue) && (f = f.$$unwrapTrustedValue()); if (d === V.MEDIA_URL || d === V.URL) return c(f.toString(), d === V.MEDIA_URL); if (d === V.RESOURCE_URL) {
                            var k =
                                ga(f.toString()), n, s, r = !1; n = 0; for (s = a.length; n < s; n++)if (e(a[n], k)) { r = !0; break } if (r) for (n = 0, s = b.length; n < s; n++)if (e(b[n], k)) { r = !1; break } if (r) return f; throw Ea("insecurl", f.toString());
                        } if (d === V.HTML) return g(f); throw Ea("unsafe");
                    }, valueOf: function (a) { return a instanceof k ? a.$$unwrapTrustedValue() : a }
                }
        }]
    } function Zf() {
        var a = !0; this.enabled = function (b) { arguments.length && (a = !!b); return a }; this.$get = ["$parse", "$sceDelegate", function (b, d) {
            if (a && 8 > Ca) throw Ea("iequirks"); var c = ja(V); c.isEnabled = function () { return a };
            c.trustAs = d.trustAs; c.getTrusted = d.getTrusted; c.valueOf = d.valueOf; a || (c.trustAs = c.getTrusted = function (a, b) { return b }, c.valueOf = Ta); c.parseAs = function (a, d) { var e = b(d); return e.literal && e.constant ? e : b(d, function (b) { return c.getTrusted(a, b) }) }; var e = c.parseAs, f = c.getTrusted, g = c.trustAs; r(V, function (a, b) { var d = K(b); c[("parse_as_" + d).replace(Cc, wb)] = function (b) { return e(a, b) }; c[("get_trusted_" + d).replace(Cc, wb)] = function (b) { return f(a, b) }; c[("trust_as_" + d).replace(Cc, wb)] = function (b) { return g(a, b) } });
            return c
        }]
    } function ag() {
        this.$get = ["$window", "$document", function (a, b) {
            var d = {}, c = !((!a.nw || !a.nw.process) && a.chrome && (a.chrome.app && a.chrome.app.runtime || !a.chrome.app && a.chrome.runtime && a.chrome.runtime.id)) && a.history && a.history.pushState, e = fa((/android (\d+)/.exec(K((a.navigator || {}).userAgent)) || [])[1]), f = /Boxee/i.test((a.navigator || {}).userAgent), g = b[0] || {}, k = g.body && g.body.style, h = !1, l = !1; k && (h = !!("transition" in k || "webkitTransition" in k), l = !!("animation" in k || "webkitAnimation" in k)); return {
                history: !(!c ||
                    4 > e || f), hasEvent: function (a) { if ("input" === a && Ca) return !1; if (z(d[a])) { var b = g.createElement("div"); d[a] = "on" + a in b } return d[a] }, csp: Aa(), transitions: h, animations: l, android: e
            }
        }]
    } function bg() { this.$get = ia(function (a) { return new Tg(a) }) } function Tg(a) {
        function b() { var a = e.pop(); return a && a.cb } function d(a) { for (var b = e.length - 1; 0 <= b; --b) { var c = e[b]; if (c.type === a) return e.splice(b, 1), c.cb } } var c = {}, e = [], f = this.ALL_TASKS_TYPE = "$$all$$", g = this.DEFAULT_TASK_TYPE = "$$default$$"; this.completeTask = function (e,
            h) { h = h || g; try { e() } finally { var l; l = h || g; c[l] && (c[l]--, c[f]--); l = c[h]; var m = c[f]; if (!m || !l) for (l = m ? d : b; m = l(h);)try { m() } catch (p) { a.error(p) } } }; this.incTaskCount = function (a) { a = a || g; c[a] = (c[a] || 0) + 1; c[f] = (c[f] || 0) + 1 }; this.notifyWhenNoPendingTasks = function (a, b) { b = b || f; c[b] ? e.push({ type: b, cb: a }) : a() }
    } function dg() {
        var a; this.httpOptions = function (b) { return b ? (a = b, this) : a }; this.$get = ["$exceptionHandler", "$templateCache", "$http", "$q", "$sce", function (b, d, c, e, f) {
            function g(k, h) {
                g.totalPendingRequests++; if (!A(k) ||
                    z(d.get(k))) k = f.getTrustedResourceUrl(k); var l = c.defaults && c.defaults.transformResponse; H(l) ? l = l.filter(function (a) { return a !== vc }) : l === vc && (l = null); return c.get(k, S({ cache: d, transformResponse: l }, a)).finally(function () { g.totalPendingRequests-- }).then(function (a) { return d.put(k, a.data) }, function (a) { h || (a = Ug("tpload", k, a.status, a.statusText), b(a)); return e.reject(a) })
            } g.totalPendingRequests = 0; return g
        }]
    } function eg() {
        this.$get = ["$rootScope", "$browser", "$location", function (a, b, d) {
            return {
                findBindings: function (a,
                    b, d) { a = a.getElementsByClassName("ng-binding"); var g = []; r(a, function (a) { var c = ca.element(a).data("$binding"); c && r(c, function (c) { d ? (new RegExp("(^|\\s)" + Md(b) + "(\\s|\\||$)")).test(c) && g.push(a) : -1 !== c.indexOf(b) && g.push(a) }) }); return g }, findModels: function (a, b, d) { for (var g = ["ng-", "data-ng-", "ng\\:"], k = 0; k < g.length; ++k) { var h = a.querySelectorAll("[" + g[k] + "model" + (d ? "=" : "*=") + '"' + b + '"]'); if (h.length) return h } }, getLocation: function () { return d.url() }, setLocation: function (b) { b !== d.url() && (d.url(b), a.$digest()) },
                whenStable: function (a) { b.notifyWhenNoOutstandingRequests(a) }
            }
        }]
    } function fg() {
        this.$get = ["$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function (a, b, d, c, e) {
            function f(f, h, l) { B(f) || (l = h, h = f, f = E); var m = Ha.call(arguments, 3), p = w(l) && !l, n = (p ? c : d).defer(), s = n.promise, r; r = b.defer(function () { try { n.resolve(f.apply(null, m)) } catch (b) { n.reject(b), e(b) } finally { delete g[s.$$timeoutId] } p || a.$apply() }, h, "$timeout"); s.$$timeoutId = r; g[r] = n; return s } var g = {}; f.cancel = function (a) {
                if (!a) return !1; if (!a.hasOwnProperty("$$timeoutId")) throw Vg("badprom");
                if (!g.hasOwnProperty(a.$$timeoutId)) return !1; a = a.$$timeoutId; var c = g[a], d = c.promise; d.$$state && (d.$$state.pur = !0); c.reject("canceled"); delete g[a]; return b.defer.cancel(a)
            }; return f
        }]
    } function ga(a) {
        if (!A(a)) return a; Ca && (aa.setAttribute("href", a), a = aa.href); aa.setAttribute("href", a); a = aa.hostname; !Wg && -1 < a.indexOf(":") && (a = "[" + a + "]"); return {
            href: aa.href, protocol: aa.protocol ? aa.protocol.replace(/:$/, "") : "", host: aa.host, search: aa.search ? aa.search.replace(/^\?/, "") : "", hash: aa.hash ? aa.hash.replace(/^#/,
                "") : "", hostname: a, port: aa.port, pathname: "/" === aa.pathname.charAt(0) ? aa.pathname : "/" + aa.pathname
        }
    } function Jg(a) { var b = [Od].concat(a.map(ga)); return function (a) { a = ga(a); return b.some(Bc.bind(null, a)) } } function Bc(a, b) { a = ga(a); b = ga(b); return a.protocol === b.protocol && a.host === b.host } function gg() { this.$get = ia(C) } function Pd(a) {
        function b(a) { try { return decodeURIComponent(a) } catch (b) { return a } } var d = a[0] || {}, c = {}, e = ""; return function () {
            var a, g, k, h, l; try { a = d.cookie || "" } catch (m) { a = "" } if (a !== e) for (e = a, a =
                e.split("; "), c = {}, k = 0; k < a.length; k++)g = a[k], h = g.indexOf("="), 0 < h && (l = b(g.substring(0, h)), z(c[l]) && (c[l] = b(g.substring(h + 1)))); return c
        }
    } function kg() { this.$get = Pd } function dd(a) {
        function b(d, c) { if (D(d)) { var e = {}; r(d, function (a, c) { e[c] = b(c, a) }); return e } return a.factory(d + "Filter", c) } this.register = b; this.$get = ["$injector", function (a) { return function (b) { return a.get(b + "Filter") } }]; b("currency", Qd); b("date", Rd); b("filter", Xg); b("json", Yg); b("limitTo", Zg); b("lowercase", $g); b("number", Sd); b("orderBy",
            Td); b("uppercase", ah)
    } function Xg() { return function (a, b, d, c) { if (!ya(a)) { if (null == a) return a; throw F("filter")("notarray", a); } c = c || "$"; var e; switch (Dc(b)) { case "function": break; case "boolean": case "null": case "number": case "string": e = !0; case "object": b = bh(b, d, c, e); break; default: return a }return Array.prototype.filter.call(a, b) } } function bh(a, b, d, c) {
        var e = D(a) && d in a; !0 === b ? b = va : B(b) || (b = function (a, b) {
            if (z(a)) return !1; if (null === a || null === b) return a === b; if (D(b) || D(a) && !bc(a)) return !1; a = K("" + a); b = K("" +
                b); return -1 !== a.indexOf(b)
        }); return function (f) { return e && !D(f) ? Fa(f, a[d], b, d, !1) : Fa(f, a, b, d, c) }
    } function Fa(a, b, d, c, e, f) {
        var g = Dc(a), k = Dc(b); if ("string" === k && "!" === b.charAt(0)) return !Fa(a, b.substring(1), d, c, e); if (H(a)) return a.some(function (a) { return Fa(a, b, d, c, e) }); switch (g) {
            case "object": var h; if (e) { for (h in a) if (h.charAt && "$" !== h.charAt(0) && Fa(a[h], b, d, c, !0)) return !0; return f ? !1 : Fa(a, b, d, c, !1) } if ("object" === k) { for (h in b) if (f = b[h], !B(f) && !z(f) && (g = h === c, !Fa(g ? a : a[h], f, d, c, g, g))) return !1; return !0 } return d(a,
                b); case "function": return !1; default: return d(a, b)
        }
    } function Dc(a) { return null === a ? "null" : typeof a } function Qd(a) { var b = a.NUMBER_FORMATS; return function (a, c, e) { z(c) && (c = b.CURRENCY_SYM); z(e) && (e = b.PATTERNS[1].maxFrac); var f = c ? /\u00A4/g : /\s*\u00A4\s*/g; return null == a ? a : Ud(a, b.PATTERNS[1], b.GROUP_SEP, b.DECIMAL_SEP, e).replace(f, c) } } function Sd(a) { var b = a.NUMBER_FORMATS; return function (a, c) { return null == a ? a : Ud(a, b.PATTERNS[0], b.GROUP_SEP, b.DECIMAL_SEP, c) } } function ch(a) {
        var b = 0, d, c, e, f, g; -1 < (c = a.indexOf(Vd)) &&
            (a = a.replace(Vd, "")); 0 < (e = a.search(/e/i)) ? (0 > c && (c = e), c += +a.slice(e + 1), a = a.substring(0, e)) : 0 > c && (c = a.length); for (e = 0; a.charAt(e) === Ec; e++); if (e === (g = a.length)) d = [0], c = 1; else { for (g--; a.charAt(g) === Ec;)g--; c -= e; d = []; for (f = 0; e <= g; e++, f++)d[f] = +a.charAt(e) } c > Wd && (d = d.splice(0, Wd - 1), b = c - 1, c = 1); return { d: d, e: b, i: c }
    } function dh(a, b, d, c) {
        var e = a.d, f = e.length - a.i; b = z(b) ? Math.min(Math.max(d, f), c) : +b; d = b + a.i; c = e[d]; if (0 < d) { e.splice(Math.max(a.i, d)); for (var g = d; g < e.length; g++)e[g] = 0 } else for (f = Math.max(0, f), a.i =
            1, e.length = Math.max(1, d = b + 1), e[0] = 0, g = 1; g < d; g++)e[g] = 0; if (5 <= c) if (0 > d - 1) { for (c = 0; c > d; c--)e.unshift(0), a.i++; e.unshift(1); a.i++ } else e[d - 1]++; for (; f < Math.max(0, b); f++)e.push(0); if (b = e.reduceRight(function (a, b, c, d) { b += a; d[c] = b % 10; return Math.floor(b / 10) }, 0)) e.unshift(b), a.i++
    } function Ud(a, b, d, c, e) {
        if (!A(a) && !W(a) || isNaN(a)) return ""; var f = !isFinite(a), g = !1, k = Math.abs(a) + "", h = ""; if (f) h = "\u221e"; else {
            g = ch(k); dh(g, e, b.minFrac, b.maxFrac); h = g.d; k = g.i; e = g.e; f = []; for (g = h.reduce(function (a, b) { return a && !b },
                !0); 0 > k;)h.unshift(0), k++; 0 < k ? f = h.splice(k, h.length) : (f = h, h = [0]); k = []; for (h.length >= b.lgSize && k.unshift(h.splice(-b.lgSize, h.length).join("")); h.length > b.gSize;)k.unshift(h.splice(-b.gSize, h.length).join("")); h.length && k.unshift(h.join("")); h = k.join(d); f.length && (h += c + f.join("")); e && (h += "e+" + e)
        } return 0 > a && !g ? b.negPre + h + b.negSuf : b.posPre + h + b.posSuf
    } function Ob(a, b, d, c) { var e = ""; if (0 > a || c && 0 >= a) c ? a = -a + 1 : (a = -a, e = "-"); for (a = "" + a; a.length < b;)a = Ec + a; d && (a = a.substr(a.length - b)); return e + a } function ea(a,
        b, d, c, e) { d = d || 0; return function (f) { f = f["get" + a](); if (0 < d || f > -d) f += d; 0 === f && -12 === d && (f = 12); return Ob(f, b, c, e) } } function kb(a, b, d) { return function (c, e) { var f = c["get" + a](), g = ub((d ? "STANDALONE" : "") + (b ? "SHORT" : "") + a); return e[g][f] } } function Xd(a) { var b = (new Date(a, 0, 1)).getDay(); return new Date(a, 0, (4 >= b ? 5 : 12) - b) } function Yd(a) { return function (b) { var d = Xd(b.getFullYear()); b = +new Date(b.getFullYear(), b.getMonth(), b.getDate() + (4 - b.getDay())) - +d; b = 1 + Math.round(b / 6048E5); return Ob(b, a) } } function Fc(a, b) {
            return 0 >=
                a.getFullYear() ? b.ERAS[0] : b.ERAS[1]
        } function Rd(a) {
            function b(a) { var b; if (b = a.match(d)) { a = new Date(0); var f = 0, g = 0, k = b[8] ? a.setUTCFullYear : a.setFullYear, h = b[8] ? a.setUTCHours : a.setHours; b[9] && (f = fa(b[9] + b[10]), g = fa(b[9] + b[11])); k.call(a, fa(b[1]), fa(b[2]) - 1, fa(b[3])); f = fa(b[4] || 0) - f; g = fa(b[5] || 0) - g; k = fa(b[6] || 0); b = Math.round(1E3 * parseFloat("0." + (b[7] || 0))); h.call(a, f, g, k, b) } return a } var d = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/; return function (c,
                d, f) { var g = "", k = [], h, l; d = d || "mediumDate"; d = a.DATETIME_FORMATS[d] || d; A(c) && (c = eh.test(c) ? fa(c) : b(c)); W(c) && (c = new Date(c)); if (!ha(c) || !isFinite(c.getTime())) return c; for (; d;)(l = fh.exec(d)) ? (k = db(k, l, 1), d = k.pop()) : (k.push(d), d = null); var m = c.getTimezoneOffset(); f && (m = ec(f, m), c = fc(c, f, !0)); r(k, function (b) { h = gh[b]; g += h ? h(c, a.DATETIME_FORMATS, m) : "''" === b ? "'" : b.replace(/(^'|'$)/g, "").replace(/''/g, "'") }); return g }
        } function Yg() { return function (a, b) { z(b) && (b = 2); return eb(a, b) } } function Zg() {
            return function (a,
                b, d) { b = Infinity === Math.abs(Number(b)) ? Number(b) : fa(b); if (X(b)) return a; W(a) && (a = a.toString()); if (!ya(a)) return a; d = !d || isNaN(d) ? 0 : fa(d); d = 0 > d ? Math.max(0, a.length + d) : d; return 0 <= b ? Gc(a, d, d + b) : 0 === d ? Gc(a, b, a.length) : Gc(a, Math.max(0, d + b), d) }
        } function Gc(a, b, d) { return A(a) ? a.slice(b, d) : Ha.call(a, b, d) } function Td(a) {
            function b(b) {
                return b.map(function (b) {
                    var c = 1, d = Ta; if (B(b)) d = b; else if (A(b)) {
                        if ("+" === b.charAt(0) || "-" === b.charAt(0)) c = "-" === b.charAt(0) ? -1 : 1, b = b.substring(1); if ("" !== b && (d = a(b), d.constant)) var e =
                            d(), d = function (a) { return a[e] }
                    } return { get: d, descending: c }
                })
            } function d(a) { switch (typeof a) { case "number": case "boolean": case "string": return !0; default: return !1 } } function c(a, b) { var c = 0, d = a.type, h = b.type; if (d === h) { var h = a.value, l = b.value; "string" === d ? (h = h.toLowerCase(), l = l.toLowerCase()) : "object" === d && (D(h) && (h = a.index), D(l) && (l = b.index)); h !== l && (c = h < l ? -1 : 1) } else c = "undefined" === d ? 1 : "undefined" === h ? -1 : "null" === d ? 1 : "null" === h ? -1 : d < h ? -1 : 1; return c } return function (a, f, g, k) {
                if (null == a) return a; if (!ya(a)) throw F("orderBy")("notarray",
                    a); H(f) || (f = [f]); 0 === f.length && (f = ["+"]); var h = b(f), l = g ? -1 : 1, m = B(k) ? k : c; a = Array.prototype.map.call(a, function (a, b) { return { value: a, tieBreaker: { value: b, type: "number", index: b }, predicateValues: h.map(function (c) { var e = c.get(a); c = typeof e; if (null === e) c = "null"; else if ("object" === c) a: { if (B(e.valueOf) && (e = e.valueOf(), d(e))) break a; bc(e) && (e = e.toString(), d(e)) } return { value: e, type: c, index: b } }) } }); a.sort(function (a, b) {
                        for (var d = 0, e = h.length; d < e; d++) {
                            var f = m(a.predicateValues[d], b.predicateValues[d]); if (f) return f *
                                h[d].descending * l
                        } return (m(a.tieBreaker, b.tieBreaker) || c(a.tieBreaker, b.tieBreaker)) * l
                    }); return a = a.map(function (a) { return a.value })
            }
        } function Ra(a) { B(a) && (a = { link: a }); a.restrict = a.restrict || "AC"; return ia(a) } function Pb(a, b, d, c, e) { this.$$controls = []; this.$error = {}; this.$$success = {}; this.$pending = void 0; this.$name = e(b.name || b.ngForm || "")(d); this.$dirty = !1; this.$valid = this.$pristine = !0; this.$submitted = this.$invalid = !1; this.$$parentForm = lb; this.$$element = a; this.$$animate = c; Zd(this) } function Zd(a) {
            a.$$classCache =
            {}; a.$$classCache[$d] = !(a.$$classCache[mb] = a.$$element.hasClass(mb))
        } function ae(a) {
            function b(a, b, c) { c && !a.$$classCache[b] ? (a.$$animate.addClass(a.$$element, b), a.$$classCache[b] = !0) : !c && a.$$classCache[b] && (a.$$animate.removeClass(a.$$element, b), a.$$classCache[b] = !1) } function d(a, c, d) { c = c ? "-" + Vc(c, "-") : ""; b(a, mb + c, !0 === d); b(a, $d + c, !1 === d) } var c = a.set, e = a.unset; a.clazz.prototype.$setValidity = function (a, g, k) {
                z(g) ? (this.$pending || (this.$pending = {}), c(this.$pending, a, k)) : (this.$pending && e(this.$pending,
                    a, k), be(this.$pending) && (this.$pending = void 0)); Ga(g) ? g ? (e(this.$error, a, k), c(this.$$success, a, k)) : (c(this.$error, a, k), e(this.$$success, a, k)) : (e(this.$error, a, k), e(this.$$success, a, k)); this.$pending ? (b(this, "ng-pending", !0), this.$valid = this.$invalid = void 0, d(this, "", null)) : (b(this, "ng-pending", !1), this.$valid = be(this.$error), this.$invalid = !this.$valid, d(this, "", this.$valid)); g = this.$pending && this.$pending[a] ? void 0 : this.$error[a] ? !1 : this.$$success[a] ? !0 : null; d(this, a, g); this.$$parentForm.$setValidity(a,
                        g, this)
            }
        } function be(a) { if (a) for (var b in a) if (a.hasOwnProperty(b)) return !1; return !0 } function Hc(a) { a.$formatters.push(function (b) { return a.$isEmpty(b) ? b : b.toString() }) } function Sa(a, b, d, c, e, f) {
            var g = K(b[0].type); if (!e.android) { var k = !1; b.on("compositionstart", function () { k = !0 }); b.on("compositionupdate", function (a) { if (z(a.data) || "" === a.data) k = !1 }); b.on("compositionend", function () { k = !1; l() }) } var h, l = function (a) {
                h && (f.defer.cancel(h), h = null); if (!k) {
                    var e = b.val(); a = a && a.type; "password" === g || d.ngTrim &&
                        "false" === d.ngTrim || (e = U(e)); (c.$viewValue !== e || "" === e && c.$$hasNativeValidators) && c.$setViewValue(e, a)
                }
            }; if (e.hasEvent("input")) b.on("input", l); else { var m = function (a, b, c) { h || (h = f.defer(function () { h = null; b && b.value === c || l(a) })) }; b.on("keydown", function (a) { var b = a.keyCode; 91 === b || 15 < b && 19 > b || 37 <= b && 40 >= b || m(a, this, this.value) }); if (e.hasEvent("paste")) b.on("paste cut drop", m) } b.on("change", l); if (ce[g] && c.$$hasNativeValidators && g === d.type) b.on("keydown wheel mousedown", function (a) {
                if (!h) {
                    var b = this.validity,
                    c = b.badInput, d = b.typeMismatch; h = f.defer(function () { h = null; b.badInput === c && b.typeMismatch === d || l(a) })
                }
            }); c.$render = function () { var a = c.$isEmpty(c.$viewValue) ? "" : c.$viewValue; b.val() !== a && b.val(a) }
        } function Qb(a, b) {
            return function (d, c) {
                var e, f; if (ha(d)) return d; if (A(d)) {
                    '"' === d.charAt(0) && '"' === d.charAt(d.length - 1) && (d = d.substring(1, d.length - 1)); if (hh.test(d)) return new Date(d); a.lastIndex = 0; if (e = a.exec(d)) return e.shift(), f = c ? {
                        yyyy: c.getFullYear(), MM: c.getMonth() + 1, dd: c.getDate(), HH: c.getHours(), mm: c.getMinutes(),
                        ss: c.getSeconds(), sss: c.getMilliseconds() / 1E3
                    } : { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 }, r(e, function (a, c) { c < b.length && (f[b[c]] = +a) }), e = new Date(f.yyyy, f.MM - 1, f.dd, f.HH, f.mm, f.ss || 0, 1E3 * f.sss || 0), 100 > f.yyyy && e.setFullYear(f.yyyy), e
                } return NaN
            }
        } function nb(a, b, d, c) {
            return function (e, f, g, k, h, l, m, p) {
                function n(a) { return a && !(a.getTime && a.getTime() !== a.getTime()) } function s(a) { return w(a) && !ha(a) ? r(a) || void 0 : a } function r(a, b) {
                    var c = k.$options.getOption("timezone"); v && v !== c && (b = Sc(b, ec(v))); var e = d(a,
                        b); !isNaN(e) && c && (e = fc(e, c)); return e
                } Ic(e, f, g, k, a); Sa(e, f, g, k, h, l); var t = "time" === a || "datetimelocal" === a, q, v; k.$parsers.push(function (c) { if (k.$isEmpty(c)) return null; if (b.test(c)) return r(c, q); k.$$parserName = a }); k.$formatters.push(function (a) {
                    if (a && !ha(a)) throw ob("datefmt", a); if (n(a)) {
                        q = a; var b = k.$options.getOption("timezone"); b && (v = b, q = fc(q, b, !0)); var d = c; t && A(k.$options.getOption("timeSecondsFormat")) && (d = c.replace("ss.sss", k.$options.getOption("timeSecondsFormat")).replace(/:$/, "")); a = m("date")(a,
                            d, b); t && k.$options.getOption("timeStripZeroSeconds") && (a = a.replace(/(?::00)?(?:\.000)?$/, "")); return a
                    } v = q = null; return ""
                }); if (w(g.min) || g.ngMin) { var x = g.min || p(g.ngMin)(e), B = s(x); k.$validators.min = function (a) { return !n(a) || z(B) || d(a) >= B }; g.$observe("min", function (a) { a !== x && (B = s(a), x = a, k.$validate()) }) } if (w(g.max) || g.ngMax) { var y = g.max || p(g.ngMax)(e), J = s(y); k.$validators.max = function (a) { return !n(a) || z(J) || d(a) <= J }; g.$observe("max", function (a) { a !== y && (J = s(a), y = a, k.$validate()) }) }
            }
        } function Ic(a, b, d,
            c, e) { (c.$$hasNativeValidators = D(b[0].validity)) && c.$parsers.push(function (a) { var d = b.prop("validity") || {}; if (d.badInput || d.typeMismatch) c.$$parserName = e; else return a }) } function de(a) { a.$parsers.push(function (b) { if (a.$isEmpty(b)) return null; if (ih.test(b)) return parseFloat(b); a.$$parserName = "number" }); a.$formatters.push(function (b) { if (!a.$isEmpty(b)) { if (!W(b)) throw ob("numfmt", b); b = b.toString() } return b }) } function na(a) { w(a) && !W(a) && (a = parseFloat(a)); return X(a) ? void 0 : a } function Jc(a) {
                var b = a.toString(),
                d = b.indexOf("."); return -1 === d ? -1 < a && 1 > a && (a = /e-(\d+)$/.exec(b)) ? Number(a[1]) : 0 : b.length - d - 1
            } function ee(a, b, d) { a = Number(a); var c = (a | 0) !== a, e = (b | 0) !== b, f = (d | 0) !== d; if (c || e || f) { var g = c ? Jc(a) : 0, k = e ? Jc(b) : 0, h = f ? Jc(d) : 0, g = Math.max(g, k, h), g = Math.pow(10, g); a *= g; b *= g; d *= g; c && (a = Math.round(a)); e && (b = Math.round(b)); f && (d = Math.round(d)) } return 0 === (a - b) % d } function fe(a, b, d, c, e) { if (w(c)) { a = a(c); if (!a.constant) throw ob("constexpr", d, c); return a(b) } return e } function Kc(a, b) {
                function d(a, b) {
                    if (!a || !a.length) return [];
                    if (!b || !b.length) return a; var c = [], d = 0; a: for (; d < a.length; d++) { for (var e = a[d], m = 0; m < b.length; m++)if (e === b[m]) continue a; c.push(e) } return c
                } function c(a) { if (!a) return a; var b = a; H(a) ? b = a.map(c).join(" ") : D(a) ? b = Object.keys(a).filter(function (b) { return a[b] }).join(" ") : A(a) || (b = a + ""); return b } a = "ngClass" + a; var e; return ["$parse", function (f) {
                    return {
                        restrict: "AC", link: function (g, k, h) {
                            function l(a, b) { var c = []; r(a, function (a) { if (0 < b || p[a]) p[a] = (p[a] || 0) + b, p[a] === +(0 < b) && c.push(a) }); return c.join(" ") } function m(a) {
                                if (a ===
                                    b) { var c = s, c = l(c && c.split(" "), 1); h.$addClass(c) } else c = s, c = l(c && c.split(" "), -1), h.$removeClass(c); n = a
                            } var p = k.data("$classCounts"), n = !0, s; p || (p = T(), k.data("$classCounts", p)); "ngClass" !== a && (e || (e = f("$index", function (a) { return a & 1 })), g.$watch(e, m)); g.$watch(f(h[a], c), function (a) { if (n === b) { var c = s && s.split(" "), e = a && a.split(" "), f = d(c, e), c = d(e, c), f = l(f, -1), c = l(c, 1); h.$addClass(c); h.$removeClass(f) } s = a })
                        }
                    }
                }]
            } function qd(a, b, d, c, e, f) {
                return {
                    restrict: "A", compile: function (g, k) {
                        var h = a(k[c]); return function (a,
                            c) { c.on(e, function (c) { var e = function () { h(a, { $event: c }) }; if (b.$$phase) if (f) a.$evalAsync(e); else try { e() } catch (g) { d(g) } else a.$apply(e) }) }
                    }
                }
            } function Rb(a, b, d, c, e, f, g, k, h) {
                this.$modelValue = this.$viewValue = Number.NaN; this.$$rawModelValue = void 0; this.$validators = {}; this.$asyncValidators = {}; this.$parsers = []; this.$formatters = []; this.$viewChangeListeners = []; this.$untouched = !0; this.$touched = !1; this.$pristine = !0; this.$dirty = !1; this.$valid = !0; this.$invalid = !1; this.$error = {}; this.$$success = {}; this.$pending =
                    void 0; this.$name = h(d.name || "", !1)(a); this.$$parentForm = lb; this.$options = Sb; this.$$updateEvents = ""; this.$$updateEventHandler = this.$$updateEventHandler.bind(this); this.$$parsedNgModel = e(d.ngModel); this.$$parsedNgModelAssign = this.$$parsedNgModel.assign; this.$$ngModelGet = this.$$parsedNgModel; this.$$ngModelSet = this.$$parsedNgModelAssign; this.$$pendingDebounce = null; this.$$parserValid = void 0; this.$$parserName = "parse"; this.$$currentValidationRunId = 0; this.$$scope = a; this.$$rootScope = a.$root; this.$$attr = d;
                this.$$element = c; this.$$animate = f; this.$$timeout = g; this.$$parse = e; this.$$q = k; this.$$exceptionHandler = b; Zd(this); jh(this)
            } function jh(a) { a.$$scope.$watch(function (b) { b = a.$$ngModelGet(b); b === a.$modelValue || a.$modelValue !== a.$modelValue && b !== b || a.$$setModelValue(b); return b }) } function Lc(a) { this.$$options = a } function ge(a, b) { r(b, function (b, c) { w(a[c]) || (a[c] = b) }) } function Oa(a, b) { a.prop("selected", b); a.attr("selected", b) } function he(a, b, d) {
                if (a) {
                    A(a) && (a = new RegExp("^" + a + "$")); if (!a.test) throw F("ngPattern")("noregexp",
                        b, a, za(d)); return a
                }
            } function Tb(a) { a = fa(a); return X(a) ? -1 : a } var Wb = { objectMaxDepth: 5, urlErrorParamsEnabled: !0 }, ie = /^\/(.+)\/([a-z]*)$/, ta = Object.prototype.hasOwnProperty, K = function (a) { return A(a) ? a.toLowerCase() : a }, ub = function (a) { return A(a) ? a.toUpperCase() : a }, Ca, x, rb, Ha = [].slice, Fg = [].splice, kh = [].push, la = Object.prototype.toString, Pc = Object.getPrototypeOf, pa = F("ng"), ca = C.angular || (C.angular = {}), kc, pb = 0; Ca = C.document.documentMode; var X = Number.isNaN || function (a) { return a !== a }; E.$inject = []; Ta.$inject =
                []; var ve = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/, U = function (a) { return A(a) ? a.trim() : a }, Md = function (a) { return a.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08") }, Aa = function () {
                    if (!w(Aa.rules)) {
                        var a = C.document.querySelector("[ng-csp]") || C.document.querySelector("[data-ng-csp]"); if (a) {
                            var b = a.getAttribute("ng-csp") || a.getAttribute("data-ng-csp"); Aa.rules = {
                                noUnsafeEval: !b || -1 !== b.indexOf("no-unsafe-eval"), noInlineStyle: !b || -1 !==
                                    b.indexOf("no-inline-style")
                            }
                        } else { a = Aa; try { new Function(""), b = !1 } catch (d) { b = !0 } a.rules = { noUnsafeEval: b, noInlineStyle: !1 } }
                    } return Aa.rules
                }, qb = function () { if (w(qb.name_)) return qb.name_; var a, b, d = Qa.length, c, e; for (b = 0; b < d; ++b)if (c = Qa[b], a = C.document.querySelector("[" + c.replace(":", "\\:") + "jq]")) { e = a.getAttribute(c + "jq"); break } return qb.name_ = e }, xe = /:/g, Qa = ["ng-", "data-ng-", "ng:", "x-ng-"], Be = function (a) {
                    var b = a.currentScript; if (!b) return !0; if (!(b instanceof C.HTMLScriptElement || b instanceof C.SVGScriptElement)) return !1;
                    b = b.attributes; return [b.getNamedItem("src"), b.getNamedItem("href"), b.getNamedItem("xlink:href")].every(function (b) { if (!b) return !0; if (!b.value) return !1; var c = a.createElement("a"); c.href = b.value; if (a.location.origin === c.origin) return !0; switch (c.protocol) { case "http:": case "https:": case "ftp:": case "blob:": case "file:": case "data:": return !0; default: return !1 } })
                }(C.document), Ee = /[A-Z]/g, Wc = !1, Pa = 3, Ke = { full: "1.7.8", major: 1, minor: 7, dot: 8, codeName: "enthusiastic-oblation" }; Y.expando = "ng339"; var Ka = Y.cache =
                    {}, pg = 1; Y._data = function (a) { return this.cache[a[this.expando]] || {} }; var lg = /-([a-z])/g, lh = /^-ms-/, Ab = { mouseleave: "mouseout", mouseenter: "mouseover" }, nc = F("jqLite"), og = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, mc = /<|&#?\w+;/, mg = /<([\w:-]+)/, ng = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, oa = {
                        option: [1, '<select multiple="multiple">', "</select>"], thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>",
                            "</tr></tbody></table>"], _default: [0, "", ""]
                    }; oa.optgroup = oa.option; oa.tbody = oa.tfoot = oa.colgroup = oa.caption = oa.thead; oa.th = oa.td; var ug = C.Node.prototype.contains || function (a) { return !!(this.compareDocumentPosition(a) & 16) }, Wa = Y.prototype = { ready: fd, toString: function () { var a = []; r(this, function (b) { a.push("" + b) }); return "[" + a.join(", ") + "]" }, eq: function (a) { return 0 <= a ? x(this[a]) : x(this[this.length + a]) }, length: 0, push: kh, sort: [].sort, splice: [].splice }, Gb = {}; r("multiple selected checked disabled readOnly required open".split(" "),
                        function (a) { Gb[K(a)] = a }); var md = {}; r("input select option textarea button form details".split(" "), function (a) { md[a] = !0 }); var td = { ngMinlength: "minlength", ngMaxlength: "maxlength", ngMin: "min", ngMax: "max", ngPattern: "pattern", ngStep: "step" }; r({ data: rc, removeData: qc, hasData: function (a) { for (var b in Ka[a.ng339]) return !0; return !1 }, cleanData: function (a) { for (var b = 0, d = a.length; b < d; b++)qc(a[b]), id(a[b]) } }, function (a, b) { Y[b] = a }); r({
                            data: rc, inheritedData: Eb, scope: function (a) {
                                return x.data(a, "$scope") || Eb(a.parentNode ||
                                    a, ["$isolateScope", "$scope"])
                            }, isolateScope: function (a) { return x.data(a, "$isolateScope") || x.data(a, "$isolateScopeNoTemplate") }, controller: jd, injector: function (a) { return Eb(a, "$injector") }, removeAttr: function (a, b) { a.removeAttribute(b) }, hasClass: Bb, css: function (a, b, d) { b = xb(b.replace(lh, "ms-")); if (w(d)) a.style[b] = d; else return a.style[b] }, attr: function (a, b, d) {
                                var c = a.nodeType; if (c !== Pa && 2 !== c && 8 !== c && a.getAttribute) {
                                    var c = K(b), e = Gb[c]; if (w(d)) null === d || !1 === d && e ? a.removeAttribute(b) : a.setAttribute(b,
                                        e ? c : d); else return a = a.getAttribute(b), e && null !== a && (a = c), null === a ? void 0 : a
                                }
                            }, prop: function (a, b, d) { if (w(d)) a[b] = d; else return a[b] }, text: function () { function a(a, d) { if (z(d)) { var c = a.nodeType; return 1 === c || c === Pa ? a.textContent : "" } a.textContent = d } a.$dv = ""; return a }(), val: function (a, b) { if (z(b)) { if (a.multiple && "select" === ua(a)) { var d = []; r(a.options, function (a) { a.selected && d.push(a.value || a.text) }); return d } return a.value } a.value = b }, html: function (a, b) { if (z(b)) return a.innerHTML; yb(a, !0); a.innerHTML = b },
                            empty: kd
                        }, function (a, b) { Y.prototype[b] = function (b, c) { var e, f, g = this.length; if (a !== kd && z(2 === a.length && a !== Bb && a !== jd ? b : c)) { if (D(b)) { for (e = 0; e < g; e++)if (a === rc) a(this[e], b); else for (f in b) a(this[e], f, b[f]); return this } e = a.$dv; g = z(e) ? Math.min(g, 1) : g; for (f = 0; f < g; f++) { var k = a(this[f], b, c); e = e ? e + k : k } return e } for (e = 0; e < g; e++)a(this[e], b, c); return this } }); r({
                            removeData: qc, on: function (a, b, d, c) {
                                if (w(c)) throw nc("onargs"); if (lc(a)) {
                                    c = zb(a, !0); var e = c.events, f = c.handle; f || (f = c.handle = rg(a, e)); c = 0 <= b.indexOf(" ") ?
                                        b.split(" ") : [b]; for (var g = c.length, k = function (b, c, g) { var k = e[b]; k || (k = e[b] = [], k.specialHandlerWrapper = c, "$destroy" === b || g || a.addEventListener(b, f)); k.push(d) }; g--;)b = c[g], Ab[b] ? (k(Ab[b], tg), k(b, void 0, !0)) : k(b)
                                }
                            }, off: id, one: function (a, b, d) { a = x(a); a.on(b, function e() { a.off(b, d); a.off(b, e) }); a.on(b, d) }, replaceWith: function (a, b) { var d, c = a.parentNode; yb(a); r(new Y(b), function (b) { d ? c.insertBefore(b, d.nextSibling) : c.replaceChild(b, a); d = b }) }, children: function (a) {
                                var b = []; r(a.childNodes, function (a) {
                                    1 ===
                                    a.nodeType && b.push(a)
                                }); return b
                            }, contents: function (a) { return a.contentDocument || a.childNodes || [] }, append: function (a, b) { var d = a.nodeType; if (1 === d || 11 === d) { b = new Y(b); for (var d = 0, c = b.length; d < c; d++)a.appendChild(b[d]) } }, prepend: function (a, b) { if (1 === a.nodeType) { var d = a.firstChild; r(new Y(b), function (b) { a.insertBefore(b, d) }) } }, wrap: function (a, b) { var d = x(b).eq(0).clone()[0], c = a.parentNode; c && c.replaceChild(d, a); d.appendChild(a) }, remove: Fb, detach: function (a) { Fb(a, !0) }, after: function (a, b) {
                                var d = a, c = a.parentNode;
                                if (c) { b = new Y(b); for (var e = 0, f = b.length; e < f; e++) { var g = b[e]; c.insertBefore(g, d.nextSibling); d = g } }
                            }, addClass: Db, removeClass: Cb, toggleClass: function (a, b, d) { b && r(b.split(" "), function (b) { var e = d; z(e) && (e = !Bb(a, b)); (e ? Db : Cb)(a, b) }) }, parent: function (a) { return (a = a.parentNode) && 11 !== a.nodeType ? a : null }, next: function (a) { return a.nextElementSibling }, find: function (a, b) { return a.getElementsByTagName ? a.getElementsByTagName(b) : [] }, clone: pc, triggerHandler: function (a, b, d) {
                                var c, e, f = b.type || b, g = zb(a); if (g = (g = g && g.events) &&
                                    g[f]) c = { preventDefault: function () { this.defaultPrevented = !0 }, isDefaultPrevented: function () { return !0 === this.defaultPrevented }, stopImmediatePropagation: function () { this.immediatePropagationStopped = !0 }, isImmediatePropagationStopped: function () { return !0 === this.immediatePropagationStopped }, stopPropagation: E, type: f, target: a }, b.type && (c = S(c, b)), b = ja(g), e = d ? [c].concat(d) : [c], r(b, function (b) { c.isImmediatePropagationStopped() || b.apply(a, e) })
                            }
                        }, function (a, b) {
                            Y.prototype[b] = function (b, c, e) {
                                for (var f, g = 0, k = this.length; g <
                                    k; g++)z(f) ? (f = a(this[g], b, c, e), w(f) && (f = x(f))) : oc(f, a(this[g], b, c, e)); return w(f) ? f : this
                            }
                        }); Y.prototype.bind = Y.prototype.on; Y.prototype.unbind = Y.prototype.off; var mh = Object.create(null); nd.prototype = {
                            _idx: function (a) { a !== this._lastKey && (this._lastKey = a, this._lastIndex = this._keys.indexOf(a)); return this._lastIndex }, _transformKey: function (a) { return X(a) ? mh : a }, get: function (a) { a = this._transformKey(a); a = this._idx(a); if (-1 !== a) return this._values[a] }, has: function (a) { a = this._transformKey(a); return -1 !== this._idx(a) },
                            set: function (a, b) { a = this._transformKey(a); var d = this._idx(a); -1 === d && (d = this._lastIndex = this._keys.length); this._keys[d] = a; this._values[d] = b }, delete: function (a) { a = this._transformKey(a); a = this._idx(a); if (-1 === a) return !1; this._keys.splice(a, 1); this._values.splice(a, 1); this._lastKey = NaN; this._lastIndex = -1; return !0 }
                        }; var Hb = nd, jg = [function () { this.$get = [function () { return Hb }] }], wg = /^([^(]+?)=>/, xg = /^[^(]*\(\s*([^)]*)\)/m, nh = /,/, oh = /^\s*(_?)(\S+?)\1\s*$/, vg = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, Ba = F("$injector");
    fb.$$annotate = function (a, b, d) { var c; if ("function" === typeof a) { if (!(c = a.$inject)) { c = []; if (a.length) { if (b) throw A(d) && d || (d = a.name || yg(a)), Ba("strictdi", d); b = od(a); r(b[1].split(nh), function (a) { a.replace(oh, function (a, b, d) { c.push(d) }) }) } a.$inject = c } } else H(a) ? (b = a.length - 1, sb(a[b], "fn"), c = a.slice(0, b)) : sb(a, "fn", !0); return c }; var je = F("$animate"), zf = function () { this.$get = E }, Af = function () {
        var a = new Hb, b = []; this.$get = ["$$AnimateRunner", "$rootScope", function (d, c) {
            function e(a, b, c) {
                var d = !1; b && (b = A(b) ? b.split(" ") :
                    H(b) ? b : [], r(b, function (b) { b && (d = !0, a[b] = c) })); return d
            } function f() { r(b, function (b) { var c = a.get(b); if (c) { var d = zg(b.attr("class")), e = "", f = ""; r(c, function (a, b) { a !== !!d[b] && (a ? e += (e.length ? " " : "") + b : f += (f.length ? " " : "") + b) }); r(b, function (a) { e && Db(a, e); f && Cb(a, f) }); a.delete(b) } }); b.length = 0 } return {
                enabled: E, on: E, off: E, pin: E, push: function (g, k, h, l) {
                    l && l(); h = h || {}; h.from && g.css(h.from); h.to && g.css(h.to); if (h.addClass || h.removeClass) if (k = h.addClass, l = h.removeClass, h = a.get(g) || {}, k = e(h, k, !0), l = e(h, l, !1),
                        k || l) a.set(g, h), b.push(g), 1 === b.length && c.$$postDigest(f); g = new d; g.complete(); return g
                }
            }
        }]
    }, xf = ["$provide", function (a) {
        var b = this, d = null, c = null; this.$$registeredAnimations = Object.create(null); this.register = function (c, d) { if (c && "." !== c.charAt(0)) throw je("notcsel", c); var g = c + "-animation"; b.$$registeredAnimations[c.substr(1)] = g; a.factory(g, d) }; this.customFilter = function (a) { 1 === arguments.length && (c = B(a) ? a : null); return c }; this.classNameFilter = function (a) {
            if (1 === arguments.length && (d = a instanceof RegExp ?
                a : null) && /[(\s|\/)]ng-animate[(\s|\/)]/.test(d.toString())) throw d = null, je("nongcls", "ng-animate"); return d
        }; this.$get = ["$$animateQueue", function (a) {
            function b(a, c, d) { if (d) { var e; a: { for (e = 0; e < d.length; e++) { var f = d[e]; if (1 === f.nodeType) { e = f; break a } } e = void 0 } !e || e.parentNode || e.previousElementSibling || (d = null) } d ? d.after(a) : c.prepend(a) } return {
                on: a.on, off: a.off, pin: a.pin, enabled: a.enabled, cancel: function (a) { a.cancel && a.cancel() }, enter: function (c, d, h, l) {
                    d = d && x(d); h = h && x(h); d = d || h.parent(); b(c, d, h); return a.push(c,
                        "enter", ra(l))
                }, move: function (c, d, h, l) { d = d && x(d); h = h && x(h); d = d || h.parent(); b(c, d, h); return a.push(c, "move", ra(l)) }, leave: function (b, c) { return a.push(b, "leave", ra(c), function () { b.remove() }) }, addClass: function (b, c, d) { d = ra(d); d.addClass = hb(d.addclass, c); return a.push(b, "addClass", d) }, removeClass: function (b, c, d) { d = ra(d); d.removeClass = hb(d.removeClass, c); return a.push(b, "removeClass", d) }, setClass: function (b, c, d, f) {
                    f = ra(f); f.addClass = hb(f.addClass, c); f.removeClass = hb(f.removeClass, d); return a.push(b, "setClass",
                        f)
                }, animate: function (b, c, d, f, m) { m = ra(m); m.from = m.from ? S(m.from, c) : c; m.to = m.to ? S(m.to, d) : d; m.tempClasses = hb(m.tempClasses, f || "ng-inline-animate"); return a.push(b, "animate", m) }
            }
        }]
    }], Cf = function () { this.$get = ["$$rAF", function (a) { function b(b) { d.push(b); 1 < d.length || a(function () { for (var a = 0; a < d.length; a++)d[a](); d = [] }) } var d = []; return function () { var a = !1; b(function () { a = !0 }); return function (d) { a ? d() : b(d) } } }] }, Bf = function () {
        this.$get = ["$q", "$sniffer", "$$animateAsyncRun", "$$isDocumentHidden", "$timeout", function (a,
            b, d, c, e) {
                function f(a) { this.setHost(a); var b = d(); this._doneCallbacks = []; this._tick = function (a) { c() ? e(a, 0, !1) : b(a) }; this._state = 0 } f.chain = function (a, b) { function c() { if (d === a.length) b(!0); else a[d](function (a) { !1 === a ? b(!1) : (d++, c()) }) } var d = 0; c() }; f.all = function (a, b) { function c(f) { e = e && f; ++d === a.length && b(e) } var d = 0, e = !0; r(a, function (a) { a.done(c) }) }; f.prototype = {
                    setHost: function (a) { this.host = a || {} }, done: function (a) { 2 === this._state ? a() : this._doneCallbacks.push(a) }, progress: E, getPromise: function () {
                        if (!this.promise) {
                            var b =
                                this; this.promise = a(function (a, c) { b.done(function (b) { !1 === b ? c() : a() }) })
                        } return this.promise
                    }, then: function (a, b) { return this.getPromise().then(a, b) }, "catch": function (a) { return this.getPromise()["catch"](a) }, "finally": function (a) { return this.getPromise()["finally"](a) }, pause: function () { this.host.pause && this.host.pause() }, resume: function () { this.host.resume && this.host.resume() }, end: function () { this.host.end && this.host.end(); this._resolve(!0) }, cancel: function () { this.host.cancel && this.host.cancel(); this._resolve(!1) },
                    complete: function (a) { var b = this; 0 === b._state && (b._state = 1, b._tick(function () { b._resolve(a) })) }, _resolve: function (a) { 2 !== this._state && (r(this._doneCallbacks, function (b) { b(a) }), this._doneCallbacks.length = 0, this._state = 2) }
                }; return f
        }]
    }, yf = function () {
        this.$get = ["$$rAF", "$q", "$$AnimateRunner", function (a, b, d) {
            return function (b, e) {
                function f() {
                    a(function () {
                        g.addClass && (b.addClass(g.addClass), g.addClass = null); g.removeClass && (b.removeClass(g.removeClass), g.removeClass = null); g.to && (b.css(g.to), g.to = null); k ||
                            h.complete(); k = !0
                    }); return h
                } var g = e || {}; g.$$prepared || (g = Ia(g)); g.cleanupStyles && (g.from = g.to = null); g.from && (b.css(g.from), g.from = null); var k, h = new d; return { start: f, end: f }
            }
        }]
    }, $ = F("$compile"), tc = new function () { }; Xc.$inject = ["$provide", "$$sanitizeUriProvider"]; Jb.prototype.isFirstChange = function () { return this.previousValue === tc }; var pd = /^((?:x|data)[:\-_])/i, Eg = /[:\-_]+(.)/g, vd = F("$controller"), ud = /^(\S+)(\s+as\s+([\w$]+))?$/, Jf = function () {
        this.$get = ["$document", function (a) {
            return function (b) {
                b ? !b.nodeType &&
                    b instanceof x && (b = b[0]) : b = a[0].body; return b.offsetWidth + 1
            }
        }]
    }, wd = "application/json", wc = { "Content-Type": wd + ";charset=utf-8" }, Hg = /^\[|^\{(?!\{)/, Ig = { "[": /]$/, "{": /}$/ }, Gg = /^\)]\}',?\n/, Kb = F("$http"), Ma = ca.$interpolateMinErr = F("$interpolate"); Ma.throwNoconcat = function (a) { throw Ma("noconcat", a); }; Ma.interr = function (a, b) { return Ma("interr", a, b.toString()) }; var Lg = F("$interval"), Sf = function () {
        this.$get = function () {
            function a(a) { var b = function (a) { b.data = a; b.called = !0 }; b.id = a; return b } var b = ca.callbacks,
                d = {}; return { createCallback: function (c) { c = "_" + (b.$$counter++).toString(36); var e = "angular.callbacks." + c, f = a(c); d[e] = b[c] = f; return e }, wasCalled: function (a) { return d[a].called }, getResponse: function (a) { return d[a].data }, removeCallback: function (a) { delete b[d[a].id]; delete d[a] } }
        }
    }, ph = /^([^?#]*)(\?([^#]*))?(#(.*))?$/, Mg = { http: 80, https: 443, ftp: 21 }, jb = F("$location"), Ng = /^\s*[\\/]{2,}/, qh = {
        $$absUrl: "", $$html5: !1, $$replace: !1, $$compose: function () {
            for (var a = this.$$path, b = this.$$hash, d = ye(this.$$search), b = b ?
                "#" + hc(b) : "", a = a.split("/"), c = a.length; c--;)a[c] = hc(a[c].replace(/%2F/g, "/")); this.$$url = a.join("/") + (d ? "?" + d : "") + b; this.$$absUrl = this.$$normalizeUrl(this.$$url); this.$$urlUpdatedByLocation = !0
        }, absUrl: Lb("$$absUrl"), url: function (a) { if (z(a)) return this.$$url; var b = ph.exec(a); (b[1] || "" === a) && this.path(decodeURIComponent(b[1])); (b[2] || b[1] || "" === a) && this.search(b[3] || ""); this.hash(b[5] || ""); return this }, protocol: Lb("$$protocol"), host: Lb("$$host"), port: Lb("$$port"), path: Dd("$$path", function (a) {
            a = null !==
                a ? a.toString() : ""; return "/" === a.charAt(0) ? a : "/" + a
        }), search: function (a, b) { switch (arguments.length) { case 0: return this.$$search; case 1: if (A(a) || W(a)) a = a.toString(), this.$$search = gc(a); else if (D(a)) a = Ia(a, {}), r(a, function (b, c) { null == b && delete a[c] }), this.$$search = a; else throw jb("isrcharg"); break; default: z(b) || null === b ? delete this.$$search[a] : this.$$search[a] = b }this.$$compose(); return this }, hash: Dd("$$hash", function (a) { return null !== a ? a.toString() : "" }), replace: function () { this.$$replace = !0; return this }
    };
    r([Cd, zc, yc], function (a) { a.prototype = Object.create(qh); a.prototype.state = function (b) { if (!arguments.length) return this.$$state; if (a !== yc || !this.$$html5) throw jb("nostate"); this.$$state = z(b) ? null : b; this.$$urlUpdatedByLocation = !0; return this } }); var Ya = F("$parse"), Rg = {}.constructor.prototype.valueOf, Ub = T(); r("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function (a) { Ub[a] = !0 }); var rh = { n: "\n", f: "\f", r: "\r", t: "\t", v: "\v", "'": "'", '"': '"' }, Nb = function (a) { this.options = a }; Nb.prototype = {
        constructor: Nb,
        lex: function (a) {
            this.text = a; this.index = 0; for (this.tokens = []; this.index < this.text.length;)if (a = this.text.charAt(this.index), '"' === a || "'" === a) this.readString(a); else if (this.isNumber(a) || "." === a && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdentifierStart(this.peekMultichar())) this.readIdent(); else if (this.is(a, "(){}[].,;:?")) this.tokens.push({ index: this.index, text: a }), this.index++; else if (this.isWhitespace(a)) this.index++; else {
                var b = a + this.peek(), d = b + this.peek(2), c = Ub[b], e = Ub[d]; Ub[a] ||
                    c || e ? (a = e ? d : c ? b : a, this.tokens.push({ index: this.index, text: a, operator: !0 }), this.index += a.length) : this.throwError("Unexpected next character ", this.index, this.index + 1)
            } return this.tokens
        }, is: function (a, b) { return -1 !== b.indexOf(a) }, peek: function (a) { a = a || 1; return this.index + a < this.text.length ? this.text.charAt(this.index + a) : !1 }, isNumber: function (a) { return "0" <= a && "9" >= a && "string" === typeof a }, isWhitespace: function (a) { return " " === a || "\r" === a || "\t" === a || "\n" === a || "\v" === a || "\u00a0" === a }, isIdentifierStart: function (a) {
            return this.options.isIdentifierStart ?
                this.options.isIdentifierStart(a, this.codePointAt(a)) : this.isValidIdentifierStart(a)
        }, isValidIdentifierStart: function (a) { return "a" <= a && "z" >= a || "A" <= a && "Z" >= a || "_" === a || "$" === a }, isIdentifierContinue: function (a) { return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(a, this.codePointAt(a)) : this.isValidIdentifierContinue(a) }, isValidIdentifierContinue: function (a, b) { return this.isValidIdentifierStart(a, b) || this.isNumber(a) }, codePointAt: function (a) {
            return 1 === a.length ? a.charCodeAt(0) :
                (a.charCodeAt(0) << 10) + a.charCodeAt(1) - 56613888
        }, peekMultichar: function () { var a = this.text.charAt(this.index), b = this.peek(); if (!b) return a; var d = a.charCodeAt(0), c = b.charCodeAt(0); return 55296 <= d && 56319 >= d && 56320 <= c && 57343 >= c ? a + b : a }, isExpOperator: function (a) { return "-" === a || "+" === a || this.isNumber(a) }, throwError: function (a, b, d) { d = d || this.index; b = w(b) ? "s " + b + "-" + this.index + " [" + this.text.substring(b, d) + "]" : " " + d; throw Ya("lexerr", a, b, this.text); }, readNumber: function () {
            for (var a = "", b = this.index; this.index <
                this.text.length;) { var d = K(this.text.charAt(this.index)); if ("." === d || this.isNumber(d)) a += d; else { var c = this.peek(); if ("e" === d && this.isExpOperator(c)) a += d; else if (this.isExpOperator(d) && c && this.isNumber(c) && "e" === a.charAt(a.length - 1)) a += d; else if (!this.isExpOperator(d) || c && this.isNumber(c) || "e" !== a.charAt(a.length - 1)) break; else this.throwError("Invalid exponent") } this.index++ } this.tokens.push({ index: b, text: a, constant: !0, value: Number(a) })
        }, readIdent: function () {
            var a = this.index; for (this.index += this.peekMultichar().length; this.index <
                this.text.length;) { var b = this.peekMultichar(); if (!this.isIdentifierContinue(b)) break; this.index += b.length } this.tokens.push({ index: a, text: this.text.slice(a, this.index), identifier: !0 })
        }, readString: function (a) {
            var b = this.index; this.index++; for (var d = "", c = a, e = !1; this.index < this.text.length;) {
                var f = this.text.charAt(this.index), c = c + f; if (e) "u" === f ? (e = this.text.substring(this.index + 1, this.index + 5), e.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + e + "]"), this.index += 4, d += String.fromCharCode(parseInt(e,
                    16))) : d += rh[f] || f, e = !1; else if ("\\" === f) e = !0; else { if (f === a) { this.index++; this.tokens.push({ index: b, text: c, constant: !0, value: d }); return } d += f } this.index++
            } this.throwError("Unterminated quote", b)
        }
    }; var q = function (a, b) { this.lexer = a; this.options = b }; q.Program = "Program"; q.ExpressionStatement = "ExpressionStatement"; q.AssignmentExpression = "AssignmentExpression"; q.ConditionalExpression = "ConditionalExpression"; q.LogicalExpression = "LogicalExpression"; q.BinaryExpression = "BinaryExpression"; q.UnaryExpression = "UnaryExpression";
    q.CallExpression = "CallExpression"; q.MemberExpression = "MemberExpression"; q.Identifier = "Identifier"; q.Literal = "Literal"; q.ArrayExpression = "ArrayExpression"; q.Property = "Property"; q.ObjectExpression = "ObjectExpression"; q.ThisExpression = "ThisExpression"; q.LocalsExpression = "LocalsExpression"; q.NGValueParameter = "NGValueParameter"; q.prototype = {
        ast: function (a) { this.text = a; this.tokens = this.lexer.lex(a); a = this.program(); 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]); return a },
        program: function () { for (var a = []; ;)if (0 < this.tokens.length && !this.peek("}", ")", ";", "]") && a.push(this.expressionStatement()), !this.expect(";")) return { type: q.Program, body: a } }, expressionStatement: function () { return { type: q.ExpressionStatement, expression: this.filterChain() } }, filterChain: function () { for (var a = this.expression(); this.expect("|");)a = this.filter(a); return a }, expression: function () { return this.assignment() }, assignment: function () {
            var a = this.ternary(); if (this.expect("=")) {
                if (!Hd(a)) throw Ya("lval");
                a = { type: q.AssignmentExpression, left: a, right: this.assignment(), operator: "=" }
            } return a
        }, ternary: function () { var a = this.logicalOR(), b, d; return this.expect("?") && (b = this.expression(), this.consume(":")) ? (d = this.expression(), { type: q.ConditionalExpression, test: a, alternate: b, consequent: d }) : a }, logicalOR: function () { for (var a = this.logicalAND(); this.expect("||");)a = { type: q.LogicalExpression, operator: "||", left: a, right: this.logicalAND() }; return a }, logicalAND: function () {
            for (var a = this.equality(); this.expect("&&");)a =
                { type: q.LogicalExpression, operator: "&&", left: a, right: this.equality() }; return a
        }, equality: function () { for (var a = this.relational(), b; b = this.expect("==", "!=", "===", "!==");)a = { type: q.BinaryExpression, operator: b.text, left: a, right: this.relational() }; return a }, relational: function () { for (var a = this.additive(), b; b = this.expect("<", ">", "<=", ">=");)a = { type: q.BinaryExpression, operator: b.text, left: a, right: this.additive() }; return a }, additive: function () {
            for (var a = this.multiplicative(), b; b = this.expect("+", "-");)a = {
                type: q.BinaryExpression,
                operator: b.text, left: a, right: this.multiplicative()
            }; return a
        }, multiplicative: function () { for (var a = this.unary(), b; b = this.expect("*", "/", "%");)a = { type: q.BinaryExpression, operator: b.text, left: a, right: this.unary() }; return a }, unary: function () { var a; return (a = this.expect("+", "-", "!")) ? { type: q.UnaryExpression, operator: a.text, prefix: !0, argument: this.unary() } : this.primary() }, primary: function () {
            var a; this.expect("(") ? (a = this.filterChain(), this.consume(")")) : this.expect("[") ? a = this.arrayDeclaration() : this.expect("{") ?
                a = this.object() : this.selfReferential.hasOwnProperty(this.peek().text) ? a = Ia(this.selfReferential[this.consume().text]) : this.options.literals.hasOwnProperty(this.peek().text) ? a = { type: q.Literal, value: this.options.literals[this.consume().text] } : this.peek().identifier ? a = this.identifier() : this.peek().constant ? a = this.constant() : this.throwError("not a primary expression", this.peek()); for (var b; b = this.expect("(", "[", ".");)"(" === b.text ? (a = { type: q.CallExpression, callee: a, arguments: this.parseArguments() }, this.consume(")")) :
                    "[" === b.text ? (a = { type: q.MemberExpression, object: a, property: this.expression(), computed: !0 }, this.consume("]")) : "." === b.text ? a = { type: q.MemberExpression, object: a, property: this.identifier(), computed: !1 } : this.throwError("IMPOSSIBLE"); return a
        }, filter: function (a) { a = [a]; for (var b = { type: q.CallExpression, callee: this.identifier(), arguments: a, filter: !0 }; this.expect(":");)a.push(this.expression()); return b }, parseArguments: function () {
            var a = []; if (")" !== this.peekToken().text) {
                do a.push(this.filterChain()); while (this.expect(","))
            } return a
        }, identifier: function () { var a = this.consume(); a.identifier || this.throwError("is not a valid identifier", a); return { type: q.Identifier, name: a.text } }, constant: function () { return { type: q.Literal, value: this.consume().value } }, arrayDeclaration: function () { var a = []; if ("]" !== this.peekToken().text) { do { if (this.peek("]")) break; a.push(this.expression()) } while (this.expect(",")) } this.consume("]"); return { type: q.ArrayExpression, elements: a } }, object: function () {
            var a = [], b; if ("}" !== this.peekToken().text) {
                do {
                    if (this.peek("}")) break;
                    b = { type: q.Property, kind: "init" }; this.peek().constant ? (b.key = this.constant(), b.computed = !1, this.consume(":"), b.value = this.expression()) : this.peek().identifier ? (b.key = this.identifier(), b.computed = !1, this.peek(":") ? (this.consume(":"), b.value = this.expression()) : b.value = b.key) : this.peek("[") ? (this.consume("["), b.key = this.expression(), this.consume("]"), b.computed = !0, this.consume(":"), b.value = this.expression()) : this.throwError("invalid key", this.peek()); a.push(b)
                } while (this.expect(","))
            } this.consume("}");
            return { type: q.ObjectExpression, properties: a }
        }, throwError: function (a, b) { throw Ya("syntax", b.text, a, b.index + 1, this.text, this.text.substring(b.index)); }, consume: function (a) { if (0 === this.tokens.length) throw Ya("ueoe", this.text); var b = this.expect(a); b || this.throwError("is unexpected, expecting [" + a + "]", this.peek()); return b }, peekToken: function () { if (0 === this.tokens.length) throw Ya("ueoe", this.text); return this.tokens[0] }, peek: function (a, b, d, c) { return this.peekAhead(0, a, b, d, c) }, peekAhead: function (a, b, d, c,
            e) { if (this.tokens.length > a) { a = this.tokens[a]; var f = a.text; if (f === b || f === d || f === c || f === e || !(b || d || c || e)) return a } return !1 }, expect: function (a, b, d, c) { return (a = this.peek(a, b, d, c)) ? (this.tokens.shift(), a) : !1 }, selfReferential: { "this": { type: q.ThisExpression }, $locals: { type: q.LocalsExpression } }
    }; var Fd = 2; Jd.prototype = {
        compile: function (a) {
            var b = this; this.state = { nextId: 0, filters: {}, fn: { vars: [], body: [], own: {} }, assign: { vars: [], body: [], own: {} }, inputs: [] }; Z(a, b.$filter); var d = "", c; this.stage = "assign"; if (c = Id(a)) this.state.computing =
                "assign", d = this.nextId(), this.recurse(c, d), this.return_(d), d = "fn.assign=" + this.generateFunction("assign", "s,v,l"); c = Gd(a.body); b.stage = "inputs"; r(c, function (a, c) { var d = "fn" + c; b.state[d] = { vars: [], body: [], own: {} }; b.state.computing = d; var k = b.nextId(); b.recurse(a, k); b.return_(k); b.state.inputs.push({ name: d, isPure: a.isPure }); a.watchId = c }); this.state.computing = "fn"; this.stage = "main"; this.recurse(a); a = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") +
                    d + this.watchFns() + "return fn;"; a = (new Function("$filter", "getStringValue", "ifDefined", "plus", a))(this.$filter, Og, Pg, Ed); this.state = this.stage = void 0; return a
        }, USE: "use", STRICT: "strict", watchFns: function () { var a = [], b = this.state.inputs, d = this; r(b, function (b) { a.push("var " + b.name + "=" + d.generateFunction(b.name, "s")); b.isPure && a.push(b.name, ".isPure=" + JSON.stringify(b.isPure) + ";") }); b.length && a.push("fn.inputs=[" + b.map(function (a) { return a.name }).join(",") + "];"); return a.join("") }, generateFunction: function (a,
            b) { return "function(" + b + "){" + this.varsPrefix(a) + this.body(a) + "};" }, filterPrefix: function () { var a = [], b = this; r(this.state.filters, function (d, c) { a.push(d + "=$filter(" + b.escape(c) + ")") }); return a.length ? "var " + a.join(",") + ";" : "" }, varsPrefix: function (a) { return this.state[a].vars.length ? "var " + this.state[a].vars.join(",") + ";" : "" }, body: function (a) { return this.state[a].body.join("") }, recurse: function (a, b, d, c, e, f) {
                var g, k, h = this, l, m, p; c = c || E; if (!f && w(a.watchId)) b = b || this.nextId(), this.if_("i", this.lazyAssign(b,
                    this.computedMember("i", a.watchId)), this.lazyRecurse(a, b, d, c, e, !0)); else switch (a.type) {
                        case q.Program: r(a.body, function (b, c) { h.recurse(b.expression, void 0, void 0, function (a) { k = a }); c !== a.body.length - 1 ? h.current().body.push(k, ";") : h.return_(k) }); break; case q.Literal: m = this.escape(a.value); this.assign(b, m); c(b || m); break; case q.UnaryExpression: this.recurse(a.argument, void 0, void 0, function (a) { k = a }); m = a.operator + "(" + this.ifDefined(k, 0) + ")"; this.assign(b, m); c(m); break; case q.BinaryExpression: this.recurse(a.left,
                            void 0, void 0, function (a) { g = a }); this.recurse(a.right, void 0, void 0, function (a) { k = a }); m = "+" === a.operator ? this.plus(g, k) : "-" === a.operator ? this.ifDefined(g, 0) + a.operator + this.ifDefined(k, 0) : "(" + g + ")" + a.operator + "(" + k + ")"; this.assign(b, m); c(m); break; case q.LogicalExpression: b = b || this.nextId(); h.recurse(a.left, b); h.if_("&&" === a.operator ? b : h.not(b), h.lazyRecurse(a.right, b)); c(b); break; case q.ConditionalExpression: b = b || this.nextId(); h.recurse(a.test, b); h.if_(b, h.lazyRecurse(a.alternate, b), h.lazyRecurse(a.consequent,
                                b)); c(b); break; case q.Identifier: b = b || this.nextId(); d && (d.context = "inputs" === h.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", a.name) + "?l:s"), d.computed = !1, d.name = a.name); h.if_("inputs" === h.stage || h.not(h.getHasOwnProperty("l", a.name)), function () { h.if_("inputs" === h.stage || "s", function () { e && 1 !== e && h.if_(h.isNull(h.nonComputedMember("s", a.name)), h.lazyAssign(h.nonComputedMember("s", a.name), "{}")); h.assign(b, h.nonComputedMember("s", a.name)) }) }, b && h.lazyAssign(b, h.nonComputedMember("l",
                                    a.name))); c(b); break; case q.MemberExpression: g = d && (d.context = this.nextId()) || this.nextId(); b = b || this.nextId(); h.recurse(a.object, g, void 0, function () {
                                        h.if_(h.notNull(g), function () {
                                            a.computed ? (k = h.nextId(), h.recurse(a.property, k), h.getStringValue(k), e && 1 !== e && h.if_(h.not(h.computedMember(g, k)), h.lazyAssign(h.computedMember(g, k), "{}")), m = h.computedMember(g, k), h.assign(b, m), d && (d.computed = !0, d.name = k)) : (e && 1 !== e && h.if_(h.isNull(h.nonComputedMember(g, a.property.name)), h.lazyAssign(h.nonComputedMember(g,
                                                a.property.name), "{}")), m = h.nonComputedMember(g, a.property.name), h.assign(b, m), d && (d.computed = !1, d.name = a.property.name))
                                        }, function () { h.assign(b, "undefined") }); c(b)
                                    }, !!e); break; case q.CallExpression: b = b || this.nextId(); a.filter ? (k = h.filter(a.callee.name), l = [], r(a.arguments, function (a) { var b = h.nextId(); h.recurse(a, b); l.push(b) }), m = k + "(" + l.join(",") + ")", h.assign(b, m), c(b)) : (k = h.nextId(), g = {}, l = [], h.recurse(a.callee, k, g, function () {
                                        h.if_(h.notNull(k), function () {
                                            r(a.arguments, function (b) {
                                                h.recurse(b, a.constant ?
                                                    void 0 : h.nextId(), void 0, function (a) { l.push(a) })
                                            }); m = g.name ? h.member(g.context, g.name, g.computed) + "(" + l.join(",") + ")" : k + "(" + l.join(",") + ")"; h.assign(b, m)
                                        }, function () { h.assign(b, "undefined") }); c(b)
                                    })); break; case q.AssignmentExpression: k = this.nextId(); g = {}; this.recurse(a.left, void 0, g, function () { h.if_(h.notNull(g.context), function () { h.recurse(a.right, k); m = h.member(g.context, g.name, g.computed) + a.operator + k; h.assign(b, m); c(b || m) }) }, 1); break; case q.ArrayExpression: l = []; r(a.elements, function (b) {
                                        h.recurse(b,
                                            a.constant ? void 0 : h.nextId(), void 0, function (a) { l.push(a) })
                                    }); m = "[" + l.join(",") + "]"; this.assign(b, m); c(b || m); break; case q.ObjectExpression: l = []; p = !1; r(a.properties, function (a) { a.computed && (p = !0) }); p ? (b = b || this.nextId(), this.assign(b, "{}"), r(a.properties, function (a) { a.computed ? (g = h.nextId(), h.recurse(a.key, g)) : g = a.key.type === q.Identifier ? a.key.name : "" + a.key.value; k = h.nextId(); h.recurse(a.value, k); h.assign(h.member(b, g, a.computed), k) })) : (r(a.properties, function (b) {
                                        h.recurse(b.value, a.constant ? void 0 :
                                            h.nextId(), void 0, function (a) { l.push(h.escape(b.key.type === q.Identifier ? b.key.name : "" + b.key.value) + ":" + a) })
                                    }), m = "{" + l.join(",") + "}", this.assign(b, m)); c(b || m); break; case q.ThisExpression: this.assign(b, "s"); c(b || "s"); break; case q.LocalsExpression: this.assign(b, "l"); c(b || "l"); break; case q.NGValueParameter: this.assign(b, "v"), c(b || "v")
                    }
            }, getHasOwnProperty: function (a, b) { var d = a + "." + b, c = this.current().own; c.hasOwnProperty(d) || (c[d] = this.nextId(!1, a + "&&(" + this.escape(b) + " in " + a + ")")); return c[d] }, assign: function (a,
                b) { if (a) return this.current().body.push(a, "=", b, ";"), a }, filter: function (a) { this.state.filters.hasOwnProperty(a) || (this.state.filters[a] = this.nextId(!0)); return this.state.filters[a] }, ifDefined: function (a, b) { return "ifDefined(" + a + "," + this.escape(b) + ")" }, plus: function (a, b) { return "plus(" + a + "," + b + ")" }, return_: function (a) { this.current().body.push("return ", a, ";") }, if_: function (a, b, d) { if (!0 === a) b(); else { var c = this.current().body; c.push("if(", a, "){"); b(); c.push("}"); d && (c.push("else{"), d(), c.push("}")) } },
        not: function (a) { return "!(" + a + ")" }, isNull: function (a) { return a + "==null" }, notNull: function (a) { return a + "!=null" }, nonComputedMember: function (a, b) { var d = /[^$_a-zA-Z0-9]/g; return /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(b) ? a + "." + b : a + '["' + b.replace(d, this.stringEscapeFn) + '"]' }, computedMember: function (a, b) { return a + "[" + b + "]" }, member: function (a, b, d) { return d ? this.computedMember(a, b) : this.nonComputedMember(a, b) }, getStringValue: function (a) { this.assign(a, "getStringValue(" + a + ")") }, lazyRecurse: function (a, b, d, c, e, f) {
            var g =
                this; return function () { g.recurse(a, b, d, c, e, f) }
        }, lazyAssign: function (a, b) { var d = this; return function () { d.assign(a, b) } }, stringEscapeRegex: /[^ a-zA-Z0-9]/g, stringEscapeFn: function (a) { return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4) }, escape: function (a) { if (A(a)) return "'" + a.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'"; if (W(a)) return a.toString(); if (!0 === a) return "true"; if (!1 === a) return "false"; if (null === a) return "null"; if ("undefined" === typeof a) return "undefined"; throw Ya("esc"); }, nextId: function (a,
            b) { var d = "v" + this.state.nextId++; a || this.current().vars.push(d + (b ? "=" + b : "")); return d }, current: function () { return this.state[this.state.computing] }
    }; Kd.prototype = {
        compile: function (a) {
            var b = this; Z(a, b.$filter); var d, c; if (d = Id(a)) c = this.recurse(d); d = Gd(a.body); var e; d && (e = [], r(d, function (a, c) { var d = b.recurse(a); d.isPure = a.isPure; a.input = d; e.push(d); a.watchId = c })); var f = []; r(a.body, function (a) { f.push(b.recurse(a.expression)) }); a = 0 === a.body.length ? E : 1 === a.body.length ? f[0] : function (a, b) {
                var c; r(f, function (d) {
                    c =
                    d(a, b)
                }); return c
            }; c && (a.assign = function (a, b, d) { return c(a, d, b) }); e && (a.inputs = e); return a
        }, recurse: function (a, b, d) {
            var c, e, f = this, g; if (a.input) return this.inputs(a.input, a.watchId); switch (a.type) {
                case q.Literal: return this.value(a.value, b); case q.UnaryExpression: return e = this.recurse(a.argument), this["unary" + a.operator](e, b); case q.BinaryExpression: return c = this.recurse(a.left), e = this.recurse(a.right), this["binary" + a.operator](c, e, b); case q.LogicalExpression: return c = this.recurse(a.left), e = this.recurse(a.right),
                    this["binary" + a.operator](c, e, b); case q.ConditionalExpression: return this["ternary?:"](this.recurse(a.test), this.recurse(a.alternate), this.recurse(a.consequent), b); case q.Identifier: return f.identifier(a.name, b, d); case q.MemberExpression: return c = this.recurse(a.object, !1, !!d), a.computed || (e = a.property.name), a.computed && (e = this.recurse(a.property)), a.computed ? this.computedMember(c, e, b, d) : this.nonComputedMember(c, e, b, d); case q.CallExpression: return g = [], r(a.arguments, function (a) { g.push(f.recurse(a)) }),
                        a.filter && (e = this.$filter(a.callee.name)), a.filter || (e = this.recurse(a.callee, !0)), a.filter ? function (a, c, d, f) { for (var p = [], n = 0; n < g.length; ++n)p.push(g[n](a, c, d, f)); a = e.apply(void 0, p, f); return b ? { context: void 0, name: void 0, value: a } : a } : function (a, c, d, f) { var p = e(a, c, d, f), n; if (null != p.value) { n = []; for (var s = 0; s < g.length; ++s)n.push(g[s](a, c, d, f)); n = p.value.apply(p.context, n) } return b ? { value: n } : n }; case q.AssignmentExpression: return c = this.recurse(a.left, !0, 1), e = this.recurse(a.right), function (a, d, f, g) {
                            var p =
                                c(a, d, f, g); a = e(a, d, f, g); p.context[p.name] = a; return b ? { value: a } : a
                        }; case q.ArrayExpression: return g = [], r(a.elements, function (a) { g.push(f.recurse(a)) }), function (a, c, d, e) { for (var f = [], n = 0; n < g.length; ++n)f.push(g[n](a, c, d, e)); return b ? { value: f } : f }; case q.ObjectExpression: return g = [], r(a.properties, function (a) { a.computed ? g.push({ key: f.recurse(a.key), computed: !0, value: f.recurse(a.value) }) : g.push({ key: a.key.type === q.Identifier ? a.key.name : "" + a.key.value, computed: !1, value: f.recurse(a.value) }) }), function (a,
                            c, d, e) { for (var f = {}, n = 0; n < g.length; ++n)g[n].computed ? f[g[n].key(a, c, d, e)] = g[n].value(a, c, d, e) : f[g[n].key] = g[n].value(a, c, d, e); return b ? { value: f } : f }; case q.ThisExpression: return function (a) { return b ? { value: a } : a }; case q.LocalsExpression: return function (a, c) { return b ? { value: c } : c }; case q.NGValueParameter: return function (a, c, d) { return b ? { value: d } : d }
            }
        }, "unary+": function (a, b) { return function (d, c, e, f) { d = a(d, c, e, f); d = w(d) ? +d : 0; return b ? { value: d } : d } }, "unary-": function (a, b) {
            return function (d, c, e, f) {
                d = a(d, c,
                    e, f); d = w(d) ? -d : -0; return b ? { value: d } : d
            }
        }, "unary!": function (a, b) { return function (d, c, e, f) { d = !a(d, c, e, f); return b ? { value: d } : d } }, "binary+": function (a, b, d) { return function (c, e, f, g) { var k = a(c, e, f, g); c = b(c, e, f, g); k = Ed(k, c); return d ? { value: k } : k } }, "binary-": function (a, b, d) { return function (c, e, f, g) { var k = a(c, e, f, g); c = b(c, e, f, g); k = (w(k) ? k : 0) - (w(c) ? c : 0); return d ? { value: k } : k } }, "binary*": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) * b(c, e, f, g); return d ? { value: c } : c } }, "binary/": function (a, b, d) {
            return function (c,
                e, f, g) { c = a(c, e, f, g) / b(c, e, f, g); return d ? { value: c } : c }
        }, "binary%": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) % b(c, e, f, g); return d ? { value: c } : c } }, "binary===": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) === b(c, e, f, g); return d ? { value: c } : c } }, "binary!==": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) !== b(c, e, f, g); return d ? { value: c } : c } }, "binary==": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) == b(c, e, f, g); return d ? { value: c } : c } }, "binary!=": function (a, b, d) {
            return function (c,
                e, f, g) { c = a(c, e, f, g) != b(c, e, f, g); return d ? { value: c } : c }
        }, "binary<": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) < b(c, e, f, g); return d ? { value: c } : c } }, "binary>": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) > b(c, e, f, g); return d ? { value: c } : c } }, "binary<=": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) <= b(c, e, f, g); return d ? { value: c } : c } }, "binary>=": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) >= b(c, e, f, g); return d ? { value: c } : c } }, "binary&&": function (a, b, d) {
            return function (c, e, f, g) {
                c =
                a(c, e, f, g) && b(c, e, f, g); return d ? { value: c } : c
            }
        }, "binary||": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) || b(c, e, f, g); return d ? { value: c } : c } }, "ternary?:": function (a, b, d, c) { return function (e, f, g, k) { e = a(e, f, g, k) ? b(e, f, g, k) : d(e, f, g, k); return c ? { value: e } : e } }, value: function (a, b) { return function () { return b ? { context: void 0, name: void 0, value: a } : a } }, identifier: function (a, b, d) {
            return function (c, e, f, g) {
                c = e && a in e ? e : c; d && 1 !== d && c && null == c[a] && (c[a] = {}); e = c ? c[a] : void 0; return b ? { context: c, name: a, value: e } :
                    e
            }
        }, computedMember: function (a, b, d, c) { return function (e, f, g, k) { var h = a(e, f, g, k), l, m; null != h && (l = b(e, f, g, k), l += "", c && 1 !== c && h && !h[l] && (h[l] = {}), m = h[l]); return d ? { context: h, name: l, value: m } : m } }, nonComputedMember: function (a, b, d, c) { return function (e, f, g, k) { e = a(e, f, g, k); c && 1 !== c && e && null == e[b] && (e[b] = {}); f = null != e ? e[b] : void 0; return d ? { context: e, name: b, value: f } : f } }, inputs: function (a, b) { return function (d, c, e, f) { return f ? f[b] : a(d, c, e) } }
    }; Mb.prototype = {
        constructor: Mb, parse: function (a) {
            a = this.getAst(a); var b =
                this.astCompiler.compile(a.ast), d = a.ast; b.literal = 0 === d.body.length || 1 === d.body.length && (d.body[0].expression.type === q.Literal || d.body[0].expression.type === q.ArrayExpression || d.body[0].expression.type === q.ObjectExpression); b.constant = a.ast.constant; b.oneTime = a.oneTime; return b
        }, getAst: function (a) { var b = !1; a = a.trim(); ":" === a.charAt(0) && ":" === a.charAt(1) && (b = !0, a = a.substring(2)); return { ast: this.ast.ast(a), oneTime: b } }
    }; var Ea = F("$sce"), V = {
        HTML: "html", CSS: "css", MEDIA_URL: "mediaUrl", URL: "url", RESOURCE_URL: "resourceUrl",
        JS: "js"
    }, Cc = /_([a-z])/g, Ug = F("$templateRequest"), Vg = F("$timeout"), aa = C.document.createElement("a"), Od = ga(C.location.href), Na; aa.href = "http://[::1]"; var Wg = "[::1]" === aa.hostname; Pd.$inject = ["$document"]; dd.$inject = ["$provide"]; var Wd = 22, Vd = ".", Ec = "0"; Qd.$inject = ["$locale"]; Sd.$inject = ["$locale"]; var gh = {
        yyyy: ea("FullYear", 4, 0, !1, !0), yy: ea("FullYear", 2, 0, !0, !0), y: ea("FullYear", 1, 0, !1, !0), MMMM: kb("Month"), MMM: kb("Month", !0), MM: ea("Month", 2, 1), M: ea("Month", 1, 1), LLLL: kb("Month", !1, !0), dd: ea("Date", 2),
        d: ea("Date", 1), HH: ea("Hours", 2), H: ea("Hours", 1), hh: ea("Hours", 2, -12), h: ea("Hours", 1, -12), mm: ea("Minutes", 2), m: ea("Minutes", 1), ss: ea("Seconds", 2), s: ea("Seconds", 1), sss: ea("Milliseconds", 3), EEEE: kb("Day"), EEE: kb("Day", !0), a: function (a, b) { return 12 > a.getHours() ? b.AMPMS[0] : b.AMPMS[1] }, Z: function (a, b, d) { a = -1 * d; return a = (0 <= a ? "+" : "") + (Ob(Math[0 < a ? "floor" : "ceil"](a / 60), 2) + Ob(Math.abs(a % 60), 2)) }, ww: Yd(2), w: Yd(1), G: Fc, GG: Fc, GGG: Fc, GGGG: function (a, b) { return 0 >= a.getFullYear() ? b.ERANAMES[0] : b.ERANAMES[1] }
    },
        fh = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/, eh = /^-?\d+$/; Rd.$inject = ["$locale"]; var $g = ia(K), ah = ia(ub); Td.$inject = ["$parse"]; var Me = ia({ restrict: "E", compile: function (a, b) { if (!b.href && !b.xlinkHref) return function (a, b) { if ("a" === b[0].nodeName.toLowerCase()) { var e = "[object SVGAnimatedString]" === la.call(b.prop("href")) ? "xlink:href" : "href"; b.on("click", function (a) { b.attr(e) || a.preventDefault() }) } } } }), vb = {}; r(Gb, function (a, b) {
            function d(a, d, e) {
                a.$watch(e[c],
                    function (a) { e.$set(b, !!a) })
            } if ("multiple" !== a) { var c = wa("ng-" + b), e = d; "checked" === a && (e = function (a, b, e) { e.ngModel !== e[c] && d(a, b, e) }); vb[c] = function () { return { restrict: "A", priority: 100, link: e } } }
        }); r(td, function (a, b) { vb[b] = function () { return { priority: 100, link: function (a, c, e) { if ("ngPattern" === b && "/" === e.ngPattern.charAt(0) && (c = e.ngPattern.match(ie))) { e.$set("ngPattern", new RegExp(c[1], c[2])); return } a.$watch(e[b], function (a) { e.$set(b, a) }) } } } }); r(["src", "srcset", "href"], function (a) {
            var b = wa("ng-" + a); vb[b] =
                ["$sce", function (d) { return { priority: 99, link: function (c, e, f) { var g = a, k = a; "href" === a && "[object SVGAnimatedString]" === la.call(e.prop("href")) && (k = "xlinkHref", f.$attr[k] = "xlink:href", g = null); f.$set(b, d.getTrustedMediaUrl(f[b])); f.$observe(b, function (b) { b ? (f.$set(k, b), Ca && g && e.prop(g, f[k])) : "href" === a && f.$set(k, null) }) } } }]
        }); var lb = { $addControl: E, $getControls: ia([]), $$renameControl: function (a, b) { a.$name = b }, $removeControl: E, $setValidity: E, $setDirty: E, $setPristine: E, $setSubmitted: E, $$setSubmitted: E }; Pb.$inject =
            ["$element", "$attrs", "$scope", "$animate", "$interpolate"]; Pb.prototype = {
                $rollbackViewValue: function () { r(this.$$controls, function (a) { a.$rollbackViewValue() }) }, $commitViewValue: function () { r(this.$$controls, function (a) { a.$commitViewValue() }) }, $addControl: function (a) { Ja(a.$name, "input"); this.$$controls.push(a); a.$name && (this[a.$name] = a); a.$$parentForm = this }, $getControls: function () { return ja(this.$$controls) }, $$renameControl: function (a, b) { var d = a.$name; this[d] === a && delete this[d]; this[b] = a; a.$name = b }, $removeControl: function (a) {
                    a.$name &&
                    this[a.$name] === a && delete this[a.$name]; r(this.$pending, function (b, d) { this.$setValidity(d, null, a) }, this); r(this.$error, function (b, d) { this.$setValidity(d, null, a) }, this); r(this.$$success, function (b, d) { this.$setValidity(d, null, a) }, this); cb(this.$$controls, a); a.$$parentForm = lb
                }, $setDirty: function () { this.$$animate.removeClass(this.$$element, Za); this.$$animate.addClass(this.$$element, Vb); this.$dirty = !0; this.$pristine = !1; this.$$parentForm.$setDirty() }, $setPristine: function () {
                    this.$$animate.setClass(this.$$element,
                        Za, Vb + " ng-submitted"); this.$dirty = !1; this.$pristine = !0; this.$submitted = !1; r(this.$$controls, function (a) { a.$setPristine() })
                }, $setUntouched: function () { r(this.$$controls, function (a) { a.$setUntouched() }) }, $setSubmitted: function () { for (var a = this; a.$$parentForm && a.$$parentForm !== lb;)a = a.$$parentForm; a.$$setSubmitted() }, $$setSubmitted: function () { this.$$animate.addClass(this.$$element, "ng-submitted"); this.$submitted = !0; r(this.$$controls, function (a) { a.$$setSubmitted && a.$$setSubmitted() }) }
            }; ae({
                clazz: Pb, set: function (a,
                    b, d) { var c = a[b]; c ? -1 === c.indexOf(d) && c.push(d) : a[b] = [d] }, unset: function (a, b, d) { var c = a[b]; c && (cb(c, d), 0 === c.length && delete a[b]) }
            }); var ke = function (a) {
                return ["$timeout", "$parse", function (b, d) {
                    function c(a) { return "" === a ? d('this[""]').assign : d(a).assign || E } return {
                        name: "form", restrict: a ? "EAC" : "E", require: ["form", "^^?form"], controller: Pb, compile: function (d, f) {
                            d.addClass(Za).addClass(mb); var g = f.name ? "name" : a && f.ngForm ? "ngForm" : !1; return {
                                pre: function (a, d, e, f) {
                                    var p = f[0]; if (!("action" in e)) {
                                        var n = function (b) {
                                            a.$apply(function () {
                                                p.$commitViewValue();
                                                p.$setSubmitted()
                                            }); b.preventDefault()
                                        }; d[0].addEventListener("submit", n); d.on("$destroy", function () { b(function () { d[0].removeEventListener("submit", n) }, 0, !1) })
                                    } (f[1] || p.$$parentForm).$addControl(p); var s = g ? c(p.$name) : E; g && (s(a, p), e.$observe(g, function (b) { p.$name !== b && (s(a, void 0), p.$$parentForm.$$renameControl(p, b), s = c(p.$name), s(a, p)) })); d.on("$destroy", function () { p.$$parentForm.$removeControl(p); s(a, void 0); S(p, lb) })
                                }
                            }
                        }
                    }
                }]
            }, Ne = ke(), Ze = ke(!0), hh = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/,
                sh = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i, th = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/, ih = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, le = /^(\d{4,})-(\d{2})-(\d{2})$/, me = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, Mc = /^(\d{4,})-W(\d\d)$/, ne = /^(\d{4,})-(\d\d)$/,
                oe = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, ce = T(); r(["date", "datetime-local", "month", "time", "week"], function (a) { ce[a] = !0 }); var pe = {
                    text: function (a, b, d, c, e, f) { Sa(a, b, d, c, e, f); Hc(c) }, date: nb("date", le, Qb(le, ["yyyy", "MM", "dd"]), "yyyy-MM-dd"), "datetime-local": nb("datetimelocal", me, Qb(me, "yyyy MM dd HH mm ss sss".split(" ")), "yyyy-MM-ddTHH:mm:ss.sss"), time: nb("time", oe, Qb(oe, ["HH", "mm", "ss", "sss"]), "HH:mm:ss.sss"), week: nb("week", Mc, function (a, b) {
                        if (ha(a)) return a; if (A(a)) {
                            Mc.lastIndex = 0; var d = Mc.exec(a);
                            if (d) { var c = +d[1], e = +d[2], f = d = 0, g = 0, k = 0, h = Xd(c), e = 7 * (e - 1); b && (d = b.getHours(), f = b.getMinutes(), g = b.getSeconds(), k = b.getMilliseconds()); return new Date(c, 0, h.getDate() + e, d, f, g, k) }
                        } return NaN
                    }, "yyyy-Www"), month: nb("month", ne, Qb(ne, ["yyyy", "MM"]), "yyyy-MM"), number: function (a, b, d, c, e, f, g, k) {
                        Ic(a, b, d, c, "number"); de(c); Sa(a, b, d, c, e, f); var h; if (w(d.min) || d.ngMin) {
                            var l = d.min || k(d.ngMin)(a); h = na(l); c.$validators.min = function (a, b) { return c.$isEmpty(b) || z(h) || b >= h }; d.$observe("min", function (a) {
                                a !== l && (h = na(a),
                                    l = a, c.$validate())
                            })
                        } if (w(d.max) || d.ngMax) { var m = d.max || k(d.ngMax)(a), p = na(m); c.$validators.max = function (a, b) { return c.$isEmpty(b) || z(p) || b <= p }; d.$observe("max", function (a) { a !== m && (p = na(a), m = a, c.$validate()) }) } if (w(d.step) || d.ngStep) { var n = d.step || k(d.ngStep)(a), s = na(n); c.$validators.step = function (a, b) { return c.$isEmpty(b) || z(s) || ee(b, h || 0, s) }; d.$observe("step", function (a) { a !== n && (s = na(a), n = a, c.$validate()) }) }
                    }, url: function (a, b, d, c, e, f) {
                        Sa(a, b, d, c, e, f); Hc(c); c.$validators.url = function (a, b) {
                            var d =
                                a || b; return c.$isEmpty(d) || sh.test(d)
                        }
                    }, email: function (a, b, d, c, e, f) { Sa(a, b, d, c, e, f); Hc(c); c.$validators.email = function (a, b) { var d = a || b; return c.$isEmpty(d) || th.test(d) } }, radio: function (a, b, d, c) { var e = !d.ngTrim || "false" !== U(d.ngTrim); z(d.name) && b.attr("name", ++pb); b.on("change", function (a) { var g; b[0].checked && (g = d.value, e && (g = U(g)), c.$setViewValue(g, a && a.type)) }); c.$render = function () { var a = d.value; e && (a = U(a)); b[0].checked = a === c.$viewValue }; d.$observe("value", c.$render) }, range: function (a, b, d, c, e, f) {
                        function g(a,
                            c) { b.attr(a, d[a]); var e = d[a]; d.$observe(a, function (a) { a !== e && (e = a, c(a)) }) } function k(a) { p = na(a); X(c.$modelValue) || (m ? (a = b.val(), p > a && (a = p, b.val(a)), c.$setViewValue(a)) : c.$validate()) } function h(a) { n = na(a); X(c.$modelValue) || (m ? (a = b.val(), n < a && (b.val(n), a = n < p ? p : n), c.$setViewValue(a)) : c.$validate()) } function l(a) { s = na(a); X(c.$modelValue) || (m ? c.$viewValue !== b.val() && c.$setViewValue(b.val()) : c.$validate()) } Ic(a, b, d, c, "range"); de(c); Sa(a, b, d, c, e, f); var m = c.$$hasNativeValidators && "range" === b[0].type, p = m ?
                                0 : void 0, n = m ? 100 : void 0, s = m ? 1 : void 0, r = b[0].validity; a = w(d.min); e = w(d.max); f = w(d.step); var q = c.$render; c.$render = m && w(r.rangeUnderflow) && w(r.rangeOverflow) ? function () { q(); c.$setViewValue(b.val()) } : q; a && (p = na(d.min), c.$validators.min = m ? function () { return !0 } : function (a, b) { return c.$isEmpty(b) || z(p) || b >= p }, g("min", k)); e && (n = na(d.max), c.$validators.max = m ? function () { return !0 } : function (a, b) { return c.$isEmpty(b) || z(n) || b <= n }, g("max", h)); f && (s = na(d.step), c.$validators.step = m ? function () { return !r.stepMismatch } :
                                    function (a, b) { return c.$isEmpty(b) || z(s) || ee(b, p || 0, s) }, g("step", l))
                    }, checkbox: function (a, b, d, c, e, f, g, k) { var h = fe(k, a, "ngTrueValue", d.ngTrueValue, !0), l = fe(k, a, "ngFalseValue", d.ngFalseValue, !1); b.on("change", function (a) { c.$setViewValue(b[0].checked, a && a.type) }); c.$render = function () { b[0].checked = c.$viewValue }; c.$isEmpty = function (a) { return !1 === a }; c.$formatters.push(function (a) { return va(a, h) }); c.$parsers.push(function (a) { return a ? h : l }) }, hidden: E, button: E, submit: E, reset: E, file: E
                }, Yc = ["$browser", "$sniffer",
                    "$filter", "$parse", function (a, b, d, c) { return { restrict: "E", require: ["?ngModel"], link: { pre: function (e, f, g, k) { k[0] && (pe[K(g.type)] || pe.text)(e, f, g, k[0], b, a, d, c) } } } }], vf = function () {
                        var a = { configurable: !0, enumerable: !1, get: function () { return this.getAttribute("value") || "" }, set: function (a) { this.setAttribute("value", a) } }; return {
                            restrict: "E", priority: 200, compile: function (b, d) {
                                if ("hidden" === K(d.type)) return {
                                    pre: function (b, d, f, g) {
                                        b = d[0]; b.parentNode && b.parentNode.insertBefore(b, b.nextSibling); Object.defineProperty &&
                                            Object.defineProperty(b, "value", a)
                                    }
                                }
                            }
                        }
                    }, uh = /^(true|false|\d+)$/, sf = function () { function a(a, d, c) { var e = w(c) ? c : 9 === Ca ? "" : null; a.prop("value", e); d.$set("value", c) } return { restrict: "A", priority: 100, compile: function (b, d) { return uh.test(d.ngValue) ? function (b, d, f) { b = b.$eval(f.ngValue); a(d, f, b) } : function (b, d, f) { b.$watch(f.ngValue, function (b) { a(d, f, b) }) } } } }, Re = ["$compile", function (a) {
                        return {
                            restrict: "AC", compile: function (b) {
                                a.$$addBindingClass(b); return function (b, c, e) {
                                    a.$$addBindingInfo(c, e.ngBind); c = c[0];
                                    b.$watch(e.ngBind, function (a) { c.textContent = ic(a) })
                                }
                            }
                        }
                    }], Te = ["$interpolate", "$compile", function (a, b) { return { compile: function (d) { b.$$addBindingClass(d); return function (c, d, f) { c = a(d.attr(f.$attr.ngBindTemplate)); b.$$addBindingInfo(d, c.expressions); d = d[0]; f.$observe("ngBindTemplate", function (a) { d.textContent = z(a) ? "" : a }) } } } }], Se = ["$sce", "$parse", "$compile", function (a, b, d) {
                        return {
                            restrict: "A", compile: function (c, e) {
                                var f = b(e.ngBindHtml), g = b(e.ngBindHtml, function (b) { return a.valueOf(b) }); d.$$addBindingClass(c);
                                return function (b, c, e) { d.$$addBindingInfo(c, e.ngBindHtml); b.$watch(g, function () { var d = f(b); c.html(a.getTrustedHtml(d) || "") }) }
                            }
                        }
                    }], rf = ia({ restrict: "A", require: "ngModel", link: function (a, b, d, c) { c.$viewChangeListeners.push(function () { a.$eval(d.ngChange) }) } }), Ue = Kc("", !0), We = Kc("Odd", 0), Ve = Kc("Even", 1), Xe = Ra({ compile: function (a, b) { b.$set("ngCloak", void 0); a.removeClass("ng-cloak") } }), Ye = [function () { return { restrict: "A", scope: !0, controller: "@", priority: 500 } }], cd = {}, vh = { blur: !0, focus: !0 }; r("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "),
                        function (a) { var b = wa("ng-" + a); cd[b] = ["$parse", "$rootScope", "$exceptionHandler", function (d, c, e) { return qd(d, c, e, b, a, vh[a]) }] }); var af = ["$animate", "$compile", function (a, b) {
                            return {
                                multiElement: !0, transclude: "element", priority: 600, terminal: !0, restrict: "A", $$tlb: !0, link: function (d, c, e, f, g) {
                                    var k, h, l; d.$watch(e.ngIf, function (d) {
                                        d ? h || g(function (d, f) { h = f; d[d.length++] = b.$$createComment("end ngIf", e.ngIf); k = { clone: d }; a.enter(d, c.parent(), c) }) : (l && (l.remove(), l = null), h && (h.$destroy(), h = null), k && (l = tb(k.clone),
                                            a.leave(l).done(function (a) { !1 !== a && (l = null) }), k = null))
                                    })
                                }
                            }
                        }], bf = ["$templateRequest", "$anchorScroll", "$animate", function (a, b, d) {
                            return {
                                restrict: "ECA", priority: 400, terminal: !0, transclude: "element", controller: ca.noop, compile: function (c, e) {
                                    var f = e.ngInclude || e.src, g = e.onload || "", k = e.autoscroll; return function (c, e, m, p, n) {
                                        var r = 0, q, t, x, v = function () { t && (t.remove(), t = null); q && (q.$destroy(), q = null); x && (d.leave(x).done(function (a) { !1 !== a && (t = null) }), t = x, x = null) }; c.$watch(f, function (f) {
                                            var m = function (a) {
                                                !1 ===
                                                a || !w(k) || k && !c.$eval(k) || b()
                                            }, t = ++r; f ? (a(f, !0).then(function (a) { if (!c.$$destroyed && t === r) { var b = c.$new(); p.template = a; a = n(b, function (a) { v(); d.enter(a, null, e).done(m) }); q = b; x = a; q.$emit("$includeContentLoaded", f); c.$eval(g) } }, function () { c.$$destroyed || t !== r || (v(), c.$emit("$includeContentError", f)) }), c.$emit("$includeContentRequested", f)) : (v(), p.template = null)
                                        })
                                    }
                                }
                            }
                        }], uf = ["$compile", function (a) {
                            return {
                                restrict: "ECA", priority: -400, require: "ngInclude", link: function (b, d, c, e) {
                                    la.call(d[0]).match(/SVG/) ?
                                    (d.empty(), a(ed(e.template, C.document).childNodes)(b, function (a) { d.append(a) }, { futureParentElement: d })) : (d.html(e.template), a(d.contents())(b))
                                }
                            }
                        }], cf = Ra({ priority: 450, compile: function () { return { pre: function (a, b, d) { a.$eval(d.ngInit) } } } }), qf = function () {
                            return {
                                restrict: "A", priority: 100, require: "ngModel", link: function (a, b, d, c) {
                                    var e = d.ngList || ", ", f = "false" !== d.ngTrim, g = f ? U(e) : e; c.$parsers.push(function (a) { if (!z(a)) { var b = []; a && r(a.split(g), function (a) { a && b.push(f ? U(a) : a) }); return b } }); c.$formatters.push(function (a) { if (H(a)) return a.join(e) });
                                    c.$isEmpty = function (a) { return !a || !a.length }
                                }
                            }
                        }, mb = "ng-valid", $d = "ng-invalid", Za = "ng-pristine", Vb = "ng-dirty", ob = F("ngModel"); Rb.$inject = "$scope $exceptionHandler $attrs $element $parse $animate $timeout $q $interpolate".split(" "); Rb.prototype = {
                            $$initGetterSetters: function () {
                                if (this.$options.getOption("getterSetter")) {
                                    var a = this.$$parse(this.$$attr.ngModel + "()"), b = this.$$parse(this.$$attr.ngModel + "($$$p)"); this.$$ngModelGet = function (b) { var c = this.$$parsedNgModel(b); B(c) && (c = a(b)); return c }; this.$$ngModelSet =
                                        function (a, c) { B(this.$$parsedNgModel(a)) ? b(a, { $$$p: c }) : this.$$parsedNgModelAssign(a, c) }
                                } else if (!this.$$parsedNgModel.assign) throw ob("nonassign", this.$$attr.ngModel, za(this.$$element));
                            }, $render: E, $isEmpty: function (a) { return z(a) || "" === a || null === a || a !== a }, $$updateEmptyClasses: function (a) {
                                this.$isEmpty(a) ? (this.$$animate.removeClass(this.$$element, "ng-not-empty"), this.$$animate.addClass(this.$$element, "ng-empty")) : (this.$$animate.removeClass(this.$$element, "ng-empty"), this.$$animate.addClass(this.$$element,
                                    "ng-not-empty"))
                            }, $setPristine: function () { this.$dirty = !1; this.$pristine = !0; this.$$animate.removeClass(this.$$element, Vb); this.$$animate.addClass(this.$$element, Za) }, $setDirty: function () { this.$dirty = !0; this.$pristine = !1; this.$$animate.removeClass(this.$$element, Za); this.$$animate.addClass(this.$$element, Vb); this.$$parentForm.$setDirty() }, $setUntouched: function () { this.$touched = !1; this.$untouched = !0; this.$$animate.setClass(this.$$element, "ng-untouched", "ng-touched") }, $setTouched: function () {
                                this.$touched =
                                !0; this.$untouched = !1; this.$$animate.setClass(this.$$element, "ng-touched", "ng-untouched")
                            }, $rollbackViewValue: function () { this.$$timeout.cancel(this.$$pendingDebounce); this.$viewValue = this.$$lastCommittedViewValue; this.$render() }, $validate: function () {
                                if (!X(this.$modelValue)) {
                                    var a = this.$$lastCommittedViewValue, b = this.$$rawModelValue, d = this.$valid, c = this.$modelValue, e = this.$options.getOption("allowInvalid"), f = this; this.$$runValidators(b, a, function (a) {
                                        e || d === a || (f.$modelValue = a ? b : void 0, f.$modelValue !==
                                            c && f.$$writeModelToScope())
                                    })
                                }
                            }, $$runValidators: function (a, b, d) {
                                function c() { var c = !0; r(h.$validators, function (d, e) { var g = Boolean(d(a, b)); c = c && g; f(e, g) }); return c ? !0 : (r(h.$asyncValidators, function (a, b) { f(b, null) }), !1) } function e() { var c = [], d = !0; r(h.$asyncValidators, function (e, g) { var h = e(a, b); if (!h || !B(h.then)) throw ob("nopromise", h); f(g, void 0); c.push(h.then(function () { f(g, !0) }, function () { d = !1; f(g, !1) })) }); c.length ? h.$$q.all(c).then(function () { g(d) }, E) : g(!0) } function f(a, b) {
                                    k === h.$$currentValidationRunId &&
                                    h.$setValidity(a, b)
                                } function g(a) { k === h.$$currentValidationRunId && d(a) } this.$$currentValidationRunId++; var k = this.$$currentValidationRunId, h = this; (function () { var a = h.$$parserName; if (z(h.$$parserValid)) f(a, null); else return h.$$parserValid || (r(h.$validators, function (a, b) { f(b, null) }), r(h.$asyncValidators, function (a, b) { f(b, null) })), f(a, h.$$parserValid), h.$$parserValid; return !0 })() ? c() ? e() : g(!1) : g(!1)
                            }, $commitViewValue: function () {
                                var a = this.$viewValue; this.$$timeout.cancel(this.$$pendingDebounce); if (this.$$lastCommittedViewValue !==
                                    a || "" === a && this.$$hasNativeValidators) this.$$updateEmptyClasses(a), this.$$lastCommittedViewValue = a, this.$pristine && this.$setDirty(), this.$$parseAndValidate()
                            }, $$parseAndValidate: function () {
                                var a = this.$$lastCommittedViewValue, b = this; this.$$parserValid = z(a) ? void 0 : !0; this.$setValidity(this.$$parserName, null); this.$$parserName = "parse"; if (this.$$parserValid) for (var d = 0; d < this.$parsers.length; d++)if (a = this.$parsers[d](a), z(a)) { this.$$parserValid = !1; break } X(this.$modelValue) && (this.$modelValue = this.$$ngModelGet(this.$$scope));
                                var c = this.$modelValue, e = this.$options.getOption("allowInvalid"); this.$$rawModelValue = a; e && (this.$modelValue = a, b.$modelValue !== c && b.$$writeModelToScope()); this.$$runValidators(a, this.$$lastCommittedViewValue, function (d) { e || (b.$modelValue = d ? a : void 0, b.$modelValue !== c && b.$$writeModelToScope()) })
                            }, $$writeModelToScope: function () { this.$$ngModelSet(this.$$scope, this.$modelValue); r(this.$viewChangeListeners, function (a) { try { a() } catch (b) { this.$$exceptionHandler(b) } }, this) }, $setViewValue: function (a, b) {
                                this.$viewValue =
                                a; this.$options.getOption("updateOnDefault") && this.$$debounceViewValueCommit(b)
                            }, $$debounceViewValueCommit: function (a) { var b = this.$options.getOption("debounce"); W(b[a]) ? b = b[a] : W(b["default"]) && -1 === this.$options.getOption("updateOn").indexOf(a) ? b = b["default"] : W(b["*"]) && (b = b["*"]); this.$$timeout.cancel(this.$$pendingDebounce); var d = this; 0 < b ? this.$$pendingDebounce = this.$$timeout(function () { d.$commitViewValue() }, b) : this.$$rootScope.$$phase ? this.$commitViewValue() : this.$$scope.$apply(function () { d.$commitViewValue() }) },
                            $overrideModelOptions: function (a) { this.$options = this.$options.createChild(a); this.$$setUpdateOnEvents() }, $processModelValue: function () { var a = this.$$format(); this.$viewValue !== a && (this.$$updateEmptyClasses(a), this.$viewValue = this.$$lastCommittedViewValue = a, this.$render(), this.$$runValidators(this.$modelValue, this.$viewValue, E)) }, $$format: function () { for (var a = this.$formatters, b = a.length, d = this.$modelValue; b--;)d = a[b](d); return d }, $$setModelValue: function (a) {
                                this.$modelValue = this.$$rawModelValue = a; this.$$parserValid =
                                    void 0; this.$processModelValue()
                            }, $$setUpdateOnEvents: function () { this.$$updateEvents && this.$$element.off(this.$$updateEvents, this.$$updateEventHandler); if (this.$$updateEvents = this.$options.getOption("updateOn")) this.$$element.on(this.$$updateEvents, this.$$updateEventHandler) }, $$updateEventHandler: function (a) { this.$$debounceViewValueCommit(a && a.type) }
                        }; ae({ clazz: Rb, set: function (a, b) { a[b] = !0 }, unset: function (a, b) { delete a[b] } }); var pf = ["$rootScope", function (a) {
                            return {
                                restrict: "A", require: ["ngModel",
                                    "^?form", "^?ngModelOptions"], controller: Rb, priority: 1, compile: function (b) {
                                        b.addClass(Za).addClass("ng-untouched").addClass(mb); return {
                                            pre: function (a, b, e, f) { var g = f[0]; b = f[1] || g.$$parentForm; if (f = f[2]) g.$options = f.$options; g.$$initGetterSetters(); b.$addControl(g); e.$observe("name", function (a) { g.$name !== a && g.$$parentForm.$$renameControl(g, a) }); a.$on("$destroy", function () { g.$$parentForm.$removeControl(g) }) }, post: function (b, c, e, f) {
                                                function g() { k.$setTouched() } var k = f[0]; k.$$setUpdateOnEvents(); c.on("blur",
                                                    function () { k.$touched || (a.$$phase ? b.$evalAsync(g) : b.$apply(g)) })
                                            }
                                        }
                                    }
                            }
                        }], Sb, wh = /(\s+|^)default(\s+|$)/; Lc.prototype = {
                            getOption: function (a) { return this.$$options[a] }, createChild: function (a) {
                                var b = !1; a = S({}, a); r(a, function (d, c) { "$inherit" === d ? "*" === c ? b = !0 : (a[c] = this.$$options[c], "updateOn" === c && (a.updateOnDefault = this.$$options.updateOnDefault)) : "updateOn" === c && (a.updateOnDefault = !1, a[c] = U(d.replace(wh, function () { a.updateOnDefault = !0; return " " }))) }, this); b && (delete a["*"], ge(a, this.$$options)); ge(a, Sb.$$options);
                                return new Lc(a)
                            }
                        }; Sb = new Lc({ updateOn: "", updateOnDefault: !0, debounce: 0, getterSetter: !1, allowInvalid: !1, timezone: null }); var tf = function () { function a(a, d) { this.$$attrs = a; this.$$scope = d } a.$inject = ["$attrs", "$scope"]; a.prototype = { $onInit: function () { var a = this.parentCtrl ? this.parentCtrl.$options : Sb, d = this.$$scope.$eval(this.$$attrs.ngModelOptions); this.$options = a.createChild(d) } }; return { restrict: "A", priority: 10, require: { parentCtrl: "?^^ngModelOptions" }, bindToController: !0, controller: a } }, df = Ra({
                            terminal: !0,
                            priority: 1E3
                        }), xh = F("ngOptions"), yh = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, nf = ["$compile", "$document", "$parse", function (a, b, d) {
                            function c(a, b, c) {
                                function e(a, b, c, d, f) { this.selectValue = a; this.viewValue = b; this.label = c; this.group = d; this.disabled = f } function f(a) {
                                    var b; if (!r && ya(a)) b = a; else {
                                        b = []; for (var c in a) a.hasOwnProperty(c) &&
                                            "$" !== c.charAt(0) && b.push(c)
                                    } return b
                                } var p = a.match(yh); if (!p) throw xh("iexp", a, za(b)); var n = p[5] || p[7], r = p[6]; a = / as /.test(p[0]) && p[1]; var q = p[9]; b = d(p[2] ? p[1] : n); var t = a && d(a) || b, w = q && d(q), v = q ? function (a, b) { return w(c, b) } : function (a) { return La(a) }, x = function (a, b) { return v(a, A(a, b)) }, z = d(p[2] || p[1]), y = d(p[3] || ""), J = d(p[4] || ""), I = d(p[8]), B = {}, A = r ? function (a, b) { B[r] = b; B[n] = a; return B } : function (a) { B[n] = a; return B }; return {
                                    trackBy: q, getTrackByValue: x, getWatchables: d(I, function (a) {
                                        var b = []; a = a || []; for (var d =
                                            f(a), e = d.length, g = 0; g < e; g++) { var k = a === d ? g : d[g], l = a[k], k = A(l, k), l = v(l, k); b.push(l); if (p[2] || p[1]) l = z(c, k), b.push(l); p[4] && (k = J(c, k), b.push(k)) } return b
                                    }), getOptions: function () { for (var a = [], b = {}, d = I(c) || [], g = f(d), k = g.length, n = 0; n < k; n++) { var p = d === g ? n : g[n], r = A(d[p], p), s = t(c, r), p = v(s, r), w = z(c, r), B = y(c, r), r = J(c, r), s = new e(p, s, w, B, r); a.push(s); b[p] = s } return { items: a, selectValueMap: b, getOptionFromViewValue: function (a) { return b[x(a)] }, getViewValueFromOption: function (a) { return q ? Ia(a.viewValue) : a.viewValue } } }
                                }
                            }
                            var e = C.document.createElement("option"), f = C.document.createElement("optgroup"); return {
                                restrict: "A", terminal: !0, require: ["select", "ngModel"], link: {
                                    pre: function (a, b, c, d) { d[0].registerOption = E }, post: function (d, k, h, l) {
                                        function m(a) { var b = (a = v.getOptionFromViewValue(a)) && a.element; b && !b.selected && (b.selected = !0); return a } function p(a, b) { a.element = b; b.disabled = a.disabled; a.label !== b.label && (b.label = a.label, b.textContent = a.label); b.value = a.selectValue } var n = l[0], q = l[1], z = h.multiple; l = 0; for (var t = k.children(),
                                            B = t.length; l < B; l++)if ("" === t[l].value) { n.hasEmptyOption = !0; n.emptyOption = t.eq(l); break } k.empty(); l = !!n.emptyOption; x(e.cloneNode(!1)).val("?"); var v, A = c(h.ngOptions, k, d), C = b[0].createDocumentFragment(); n.generateUnknownOptionValue = function (a) { return "?" }; z ? (n.writeValue = function (a) { if (v) { var b = a && a.map(m) || []; v.items.forEach(function (a) { a.element.selected && -1 === Array.prototype.indexOf.call(b, a) && (a.element.selected = !1) }) } }, n.readValue = function () {
                                                var a = k.val() || [], b = []; r(a, function (a) {
                                                    (a = v.selectValueMap[a]) &&
                                                    !a.disabled && b.push(v.getViewValueFromOption(a))
                                                }); return b
                                            }, A.trackBy && d.$watchCollection(function () { if (H(q.$viewValue)) return q.$viewValue.map(function (a) { return A.getTrackByValue(a) }) }, function () { q.$render() })) : (n.writeValue = function (a) { if (v) { var b = k[0].options[k[0].selectedIndex], c = v.getOptionFromViewValue(a); b && b.removeAttribute("selected"); c ? (k[0].value !== c.selectValue && (n.removeUnknownOption(), k[0].value = c.selectValue, c.element.selected = !0), c.element.setAttribute("selected", "selected")) : n.selectUnknownOrEmptyOption(a) } },
                                                n.readValue = function () { var a = v.selectValueMap[k.val()]; return a && !a.disabled ? (n.unselectEmptyOption(), n.removeUnknownOption(), v.getViewValueFromOption(a)) : null }, A.trackBy && d.$watch(function () { return A.getTrackByValue(q.$viewValue) }, function () { q.$render() })); l && (a(n.emptyOption)(d), k.prepend(n.emptyOption), 8 === n.emptyOption[0].nodeType ? (n.hasEmptyOption = !1, n.registerOption = function (a, b) {
                                                    "" === b.val() && (n.hasEmptyOption = !0, n.emptyOption = b, n.emptyOption.removeClass("ng-scope"), q.$render(), b.on("$destroy",
                                                        function () { var a = n.$isEmptyOptionSelected(); n.hasEmptyOption = !1; n.emptyOption = void 0; a && q.$render() }))
                                                }) : n.emptyOption.removeClass("ng-scope")); d.$watchCollection(A.getWatchables, function () {
                                                    var a = v && n.readValue(); if (v) for (var b = v.items.length - 1; 0 <= b; b--) { var c = v.items[b]; w(c.group) ? Fb(c.element.parentNode) : Fb(c.element) } v = A.getOptions(); var d = {}; v.items.forEach(function (a) {
                                                        var b; if (w(a.group)) {
                                                            b = d[a.group]; b || (b = f.cloneNode(!1), C.appendChild(b), b.label = null === a.group ? "null" : a.group, d[a.group] = b);
                                                            var c = e.cloneNode(!1); b.appendChild(c); p(a, c)
                                                        } else b = e.cloneNode(!1), C.appendChild(b), p(a, b)
                                                    }); k[0].appendChild(C); q.$render(); q.$isEmpty(a) || (b = n.readValue(), (A.trackBy || z ? va(a, b) : a === b) || (q.$setViewValue(b), q.$render()))
                                                })
                                    }
                                }
                            }
                        }], ef = ["$locale", "$interpolate", "$log", function (a, b, d) {
                            var c = /{}/g, e = /^when(Minus)?(.+)$/; return {
                                link: function (f, g, k) {
                                    function h(a) { g.text(a || "") } var l = k.count, m = k.$attr.when && g.attr(k.$attr.when), p = k.offset || 0, n = f.$eval(m) || {}, q = {}, w = b.startSymbol(), t = b.endSymbol(), x = w + l + "-" +
                                        p + t, v = ca.noop, A; r(k, function (a, b) { var c = e.exec(b); c && (c = (c[1] ? "-" : "") + K(c[2]), n[c] = g.attr(k.$attr[b])) }); r(n, function (a, d) { q[d] = b(a.replace(c, x)) }); f.$watch(l, function (b) { var c = parseFloat(b), e = X(c); e || c in n || (c = a.pluralCat(c - p)); c === A || e && X(A) || (v(), e = q[c], z(e) ? (null != b && d.debug("ngPluralize: no rule defined for '" + c + "' in " + m), v = E, h()) : v = f.$watch(e, h), A = c) })
                                }
                            }
                        }], qe = F("ngRef"), ff = ["$parse", function (a) {
                            return {
                                priority: -1, restrict: "A", compile: function (b, d) {
                                    var c = wa(ua(b)), e = a(d.ngRef), f = e.assign ||
                                        function () { throw qe("nonassign", d.ngRef); }; return function (a, b, h) { var l; if (h.hasOwnProperty("ngRefRead")) if ("$element" === h.ngRefRead) l = b; else { if (l = b.data("$" + h.ngRefRead + "Controller"), !l) throw qe("noctrl", h.ngRefRead, d.ngRef); } else l = b.data("$" + c + "Controller"); l = l || b; f(a, l); b.on("$destroy", function () { e(a) === l && f(a, null) }) }
                                }
                            }
                        }], gf = ["$parse", "$animate", "$compile", function (a, b, d) {
                            var c = F("ngRepeat"), e = function (a, b, c, d, e, f, g) {
                                a[c] = d; e && (a[e] = f); a.$index = b; a.$first = 0 === b; a.$last = b === g - 1; a.$middle = !(a.$first ||
                                    a.$last); a.$odd = !(a.$even = 0 === (b & 1))
                            }, f = function (a, b, c) { return La(c) }, g = function (a, b) { return b }; return {
                                restrict: "A", multiElement: !0, transclude: "element", priority: 1E3, terminal: !0, $$tlb: !0, compile: function (k, h) {
                                    var l = h.ngRepeat, m = d.$$createComment("end ngRepeat", l), p = l.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/); if (!p) throw c("iexp", l); var n = p[1], q = p[2], w = p[3], t = p[4], p = n.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/); if (!p) throw c("iidexp",
                                        n); var x = p[3] || p[1], v = p[2]; if (w && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(w) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(w))) throw c("badident", w); var z; if (t) { var A = { $id: La }, y = a(t); z = function (a, b, c, d) { v && (A[v] = b); A[x] = c; A.$index = d; return y(a, A) } } return function (a, d, h, k, n) {
                                            var p = T(); a.$watchCollection(q, function (h) {
                                                var k, q, t = d[0], s, y = T(), B, C, E, D, H, F, K; w && (a[w] = h); if (ya(h)) H = h, q = z || f; else for (K in q = z || g, H = [], h) ta.call(h, K) && "$" !== K.charAt(0) && H.push(K);
                                                B = H.length; K = Array(B); for (k = 0; k < B; k++)if (C = h === H ? k : H[k], E = h[C], D = q(a, C, E, k), p[D]) F = p[D], delete p[D], y[D] = F, K[k] = F; else { if (y[D]) throw r(K, function (a) { a && a.scope && (p[a.id] = a) }), c("dupes", l, D, E); K[k] = { id: D, scope: void 0, clone: void 0 }; y[D] = !0 } A && (A[x] = void 0); for (s in p) { F = p[s]; D = tb(F.clone); b.leave(D); if (D[0].parentNode) for (k = 0, q = D.length; k < q; k++)D[k].$$NG_REMOVED = !0; F.scope.$destroy() } for (k = 0; k < B; k++)if (C = h === H ? k : H[k], E = h[C], F = K[k], F.scope) {
                                                    s = t; do s = s.nextSibling; while (s && s.$$NG_REMOVED); F.clone[0] !==
                                                        s && b.move(tb(F.clone), null, t); t = F.clone[F.clone.length - 1]; e(F.scope, k, x, E, v, C, B)
                                                } else n(function (a, c) { F.scope = c; var d = m.cloneNode(!1); a[a.length++] = d; b.enter(a, null, t); t = d; F.clone = a; y[F.id] = F; e(F.scope, k, x, E, v, C, B) }); p = y
                                            })
                                        }
                                }
                            }
                        }], hf = ["$animate", function (a) { return { restrict: "A", multiElement: !0, link: function (b, d, c) { b.$watch(c.ngShow, function (b) { a[b ? "removeClass" : "addClass"](d, "ng-hide", { tempClasses: "ng-hide-animate" }) }) } } }], $e = ["$animate", function (a) {
                            return {
                                restrict: "A", multiElement: !0, link: function (b,
                                    d, c) { b.$watch(c.ngHide, function (b) { a[b ? "addClass" : "removeClass"](d, "ng-hide", { tempClasses: "ng-hide-animate" }) }) }
                            }
                        }], jf = Ra(function (a, b, d) { a.$watchCollection(d.ngStyle, function (a, d) { d && a !== d && (a || (a = {}), r(d, function (b, d) { null == a[d] && (a[d] = "") })); a && b.css(a) }) }), kf = ["$animate", "$compile", function (a, b) {
                            return {
                                require: "ngSwitch", controller: ["$scope", function () { this.cases = {} }], link: function (d, c, e, f) {
                                    var g = [], k = [], h = [], l = [], m = function (a, b) { return function (c) { !1 !== c && a.splice(b, 1) } }; d.$watch(e.ngSwitch ||
                                        e.on, function (c) { for (var d, e; h.length;)a.cancel(h.pop()); d = 0; for (e = l.length; d < e; ++d) { var q = tb(k[d].clone); l[d].$destroy(); (h[d] = a.leave(q)).done(m(h, d)) } k.length = 0; l.length = 0; (g = f.cases["!" + c] || f.cases["?"]) && r(g, function (c) { c.transclude(function (d, e) { l.push(e); var f = c.element; d[d.length++] = b.$$createComment("end ngSwitchWhen"); k.push({ clone: d }); a.enter(d, f.parent(), f) }) }) })
                                }
                            }
                        }], lf = Ra({
                            transclude: "element", priority: 1200, require: "^ngSwitch", multiElement: !0, link: function (a, b, d, c, e) {
                                a = d.ngSwitchWhen.split(d.ngSwitchWhenSeparator).sort().filter(function (a,
                                    b, c) { return c[b - 1] !== a }); r(a, function (a) { c.cases["!" + a] = c.cases["!" + a] || []; c.cases["!" + a].push({ transclude: e, element: b }) })
                            }
                        }), mf = Ra({ transclude: "element", priority: 1200, require: "^ngSwitch", multiElement: !0, link: function (a, b, d, c, e) { c.cases["?"] = c.cases["?"] || []; c.cases["?"].push({ transclude: e, element: b }) } }), zh = F("ngTransclude"), of = ["$compile", function (a) {
                            return {
                                restrict: "EAC", compile: function (b) {
                                    var d = a(b.contents()); b.empty(); return function (a, b, f, g, k) {
                                        function h() { d(a, function (a) { b.append(a) }) } if (!k) throw zh("orphan",
                                            za(b)); f.ngTransclude === f.$attr.ngTransclude && (f.ngTransclude = ""); f = f.ngTransclude || f.ngTranscludeSlot; k(function (a, c) { var d; if (d = a.length) a: { d = 0; for (var f = a.length; d < f; d++) { var g = a[d]; if (g.nodeType !== Pa || g.nodeValue.trim()) { d = !0; break a } } d = void 0 } d ? b.append(a) : (h(), c.$destroy()) }, null, f); f && !k.isSlotFilled(f) && h()
                                    }
                                }
                            }
                        }], Oe = ["$templateCache", function (a) { return { restrict: "E", terminal: !0, compile: function (b, d) { "text/ng-template" === d.type && a.put(d.id, b[0].text) } } }], Ah = { $setViewValue: E, $render: E }, Bh = ["$element",
                            "$scope", function (a, b) {
                                function d() { g || (g = !0, b.$$postDigest(function () { g = !1; e.ngModelCtrl.$render() })) } function c(a) { k || (k = !0, b.$$postDigest(function () { b.$$destroyed || (k = !1, e.ngModelCtrl.$setViewValue(e.readValue()), a && e.ngModelCtrl.$render()) })) } var e = this, f = new Hb; e.selectValueMap = {}; e.ngModelCtrl = Ah; e.multiple = !1; e.unknownOption = x(C.document.createElement("option")); e.hasEmptyOption = !1; e.emptyOption = void 0; e.renderUnknownOption = function (b) {
                                    b = e.generateUnknownOptionValue(b); e.unknownOption.val(b);
                                    a.prepend(e.unknownOption); Oa(e.unknownOption, !0); a.val(b)
                                }; e.updateUnknownOption = function (b) { b = e.generateUnknownOptionValue(b); e.unknownOption.val(b); Oa(e.unknownOption, !0); a.val(b) }; e.generateUnknownOptionValue = function (a) { return "? " + La(a) + " ?" }; e.removeUnknownOption = function () { e.unknownOption.parent() && e.unknownOption.remove() }; e.selectEmptyOption = function () { e.emptyOption && (a.val(""), Oa(e.emptyOption, !0)) }; e.unselectEmptyOption = function () { e.hasEmptyOption && Oa(e.emptyOption, !1) }; b.$on("$destroy",
                                    function () { e.renderUnknownOption = E }); e.readValue = function () { var b = a.val(), b = b in e.selectValueMap ? e.selectValueMap[b] : b; return e.hasOption(b) ? b : null }; e.writeValue = function (b) { var c = a[0].options[a[0].selectedIndex]; c && Oa(x(c), !1); e.hasOption(b) ? (e.removeUnknownOption(), c = La(b), a.val(c in e.selectValueMap ? c : b), Oa(x(a[0].options[a[0].selectedIndex]), !0)) : e.selectUnknownOrEmptyOption(b) }; e.addOption = function (a, b) {
                                        if (8 !== b[0].nodeType) {
                                            Ja(a, '"option value"'); "" === a && (e.hasEmptyOption = !0, e.emptyOption =
                                                b); var c = f.get(a) || 0; f.set(a, c + 1); d()
                                        }
                                    }; e.removeOption = function (a) { var b = f.get(a); b && (1 === b ? (f.delete(a), "" === a && (e.hasEmptyOption = !1, e.emptyOption = void 0)) : f.set(a, b - 1)) }; e.hasOption = function (a) { return !!f.get(a) }; e.$hasEmptyOption = function () { return e.hasEmptyOption }; e.$isUnknownOptionSelected = function () { return a[0].options[0] === e.unknownOption[0] }; e.$isEmptyOptionSelected = function () { return e.hasEmptyOption && a[0].options[a[0].selectedIndex] === e.emptyOption[0] }; e.selectUnknownOrEmptyOption = function (a) {
                                        null ==
                                        a && e.emptyOption ? (e.removeUnknownOption(), e.selectEmptyOption()) : e.unknownOption.parent().length ? e.updateUnknownOption(a) : e.renderUnknownOption(a)
                                    }; var g = !1, k = !1; e.registerOption = function (a, b, f, g, k) {
                                        if (f.$attr.ngValue) { var q, r; f.$observe("value", function (a) { var d, f = b.prop("selected"); w(r) && (e.removeOption(q), delete e.selectValueMap[r], d = !0); r = La(a); q = a; e.selectValueMap[r] = a; e.addOption(a, b); b.attr("value", r); d && f && c() }) } else g ? f.$observe("value", function (a) {
                                            e.readValue(); var d, f = b.prop("selected");
                                            w(q) && (e.removeOption(q), d = !0); q = a; e.addOption(a, b); d && f && c()
                                        }) : k ? a.$watch(k, function (a, d) { f.$set("value", a); var g = b.prop("selected"); d !== a && e.removeOption(d); e.addOption(a, b); d && g && c() }) : e.addOption(f.value, b); f.$observe("disabled", function (a) { if ("true" === a || a && b.prop("selected")) e.multiple ? c(!0) : (e.ngModelCtrl.$setViewValue(null), e.ngModelCtrl.$render()) }); b.on("$destroy", function () { var a = e.readValue(), b = f.value; e.removeOption(b); d(); (e.multiple && a && -1 !== a.indexOf(b) || a === b) && c(!0) })
                                    }
                            }], Pe = function () {
                                return {
                                    restrict: "E",
                                    require: ["select", "?ngModel"], controller: Bh, priority: 1, link: {
                                        pre: function (a, b, d, c) {
                                            var e = c[0], f = c[1]; if (f) {
                                                if (e.ngModelCtrl = f, b.on("change", function () { e.removeUnknownOption(); a.$apply(function () { f.$setViewValue(e.readValue()) }) }), d.multiple) {
                                                    e.multiple = !0; e.readValue = function () { var a = []; r(b.find("option"), function (b) { b.selected && !b.disabled && (b = b.value, a.push(b in e.selectValueMap ? e.selectValueMap[b] : b)) }); return a }; e.writeValue = function (a) {
                                                        r(b.find("option"), function (b) {
                                                            var c = !!a && (-1 !== Array.prototype.indexOf.call(a,
                                                                b.value) || -1 !== Array.prototype.indexOf.call(a, e.selectValueMap[b.value])); c !== b.selected && Oa(x(b), c)
                                                        })
                                                    }; var g, k = NaN; a.$watch(function () { k !== f.$viewValue || va(g, f.$viewValue) || (g = ja(f.$viewValue), f.$render()); k = f.$viewValue }); f.$isEmpty = function (a) { return !a || 0 === a.length }
                                                }
                                            } else e.registerOption = E
                                        }, post: function (a, b, d, c) { var e = c[1]; if (e) { var f = c[0]; e.$render = function () { f.writeValue(e.$viewValue) } } }
                                    }
                                }
                            }, Qe = ["$interpolate", function (a) {
                                return {
                                    restrict: "E", priority: 100, compile: function (b, d) {
                                        var c, e; w(d.ngValue) ||
                                            (w(d.value) ? c = a(d.value, !0) : (e = a(b.text(), !0)) || d.$set("value", b.text())); return function (a, b, d) { var h = b.parent(); (h = h.data("$selectController") || h.parent().data("$selectController")) && h.registerOption(a, b, d, c, e) }
                                    }
                                }
                            }], $c = ["$parse", function (a) {
                                return {
                                    restrict: "A", require: "?ngModel", link: function (b, d, c, e) {
                                        if (e) {
                                            var f = c.hasOwnProperty("required") || a(c.ngRequired)(b); c.ngRequired || (c.required = !0); e.$validators.required = function (a, b) { return !f || !e.$isEmpty(b) }; c.$observe("required", function (a) {
                                                f !== a && (f =
                                                    a, e.$validate())
                                            })
                                        }
                                    }
                                }
                            }], Zc = ["$parse", function (a) {
                                return {
                                    restrict: "A", require: "?ngModel", compile: function (b, d) {
                                        var c, e; d.ngPattern && (c = d.ngPattern, e = "/" === d.ngPattern.charAt(0) && ie.test(d.ngPattern) ? function () { return d.ngPattern } : a(d.ngPattern)); return function (a, b, d, h) {
                                            if (h) {
                                                var l = d.pattern; d.ngPattern ? l = e(a) : c = d.pattern; var m = he(l, c, b); d.$observe("pattern", function (a) { var d = m; m = he(a, c, b); (d && d.toString()) !== (m && m.toString()) && h.$validate() }); h.$validators.pattern = function (a, b) {
                                                    return h.$isEmpty(b) ||
                                                        z(m) || m.test(b)
                                                }
                                            }
                                        }
                                    }
                                }
                            }], bd = ["$parse", function (a) { return { restrict: "A", require: "?ngModel", link: function (b, d, c, e) { if (e) { var f = c.maxlength || a(c.ngMaxlength)(b), g = Tb(f); c.$observe("maxlength", function (a) { f !== a && (g = Tb(a), f = a, e.$validate()) }); e.$validators.maxlength = function (a, b) { return 0 > g || e.$isEmpty(b) || b.length <= g } } } } }], ad = ["$parse", function (a) {
                                return {
                                    restrict: "A", require: "?ngModel", link: function (b, d, c, e) {
                                        if (e) {
                                            var f = c.minlength || a(c.ngMinlength)(b), g = Tb(f) || -1; c.$observe("minlength", function (a) {
                                                f !==
                                                a && (g = Tb(a) || -1, f = a, e.$validate())
                                            }); e.$validators.minlength = function (a, b) { return e.$isEmpty(b) || b.length >= g }
                                        }
                                    }
                                }
                            }]; C.angular.bootstrap ? C.console && console.log("WARNING: Tried to load AngularJS more than once.") : (Fe(), Je(ca), ca.module("ngLocale", [], ["$provide", function (a) {
                                function b(a) { a += ""; var b = a.indexOf("."); return -1 == b ? 0 : a.length - b - 1 } a.value("$locale", {
                                    DATETIME_FORMATS: {
                                        AMPMS: ["AM", "PM"], DAY: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), ERANAMES: ["Before Christ", "Anno Domini"],
                                        ERAS: ["BC", "AD"], FIRSTDAYOFWEEK: 6, MONTH: "January February March April May June July August September October November December".split(" "), SHORTDAY: "Sun Mon Tue Wed Thu Fri Sat".split(" "), SHORTMONTH: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), STANDALONEMONTH: "January February March April May June July August September October November December".split(" "), WEEKENDRANGE: [5, 6], fullDate: "EEEE, MMMM d, y", longDate: "MMMM d, y", medium: "MMM d, y h:mm:ss a", mediumDate: "MMM d, y", mediumTime: "h:mm:ss a",
                                        "short": "M/d/yy h:mm a", shortDate: "M/d/yy", shortTime: "h:mm a"
                                    }, NUMBER_FORMATS: { CURRENCY_SYM: "$", DECIMAL_SEP: ".", GROUP_SEP: ",", PATTERNS: [{ gSize: 3, lgSize: 3, maxFrac: 3, minFrac: 0, minInt: 1, negPre: "-", negSuf: "", posPre: "", posSuf: "" }, { gSize: 3, lgSize: 3, maxFrac: 2, minFrac: 2, minInt: 1, negPre: "-\u00a4", negSuf: "", posPre: "\u00a4", posSuf: "" }] }, id: "en-us", localeID: "en_US", pluralCat: function (a, c) { var e = a | 0, f = c; void 0 === f && (f = Math.min(b(a), 3)); Math.pow(10, f); return 1 == e && 0 == f ? "one" : "other" }
                                })
                            }]), x(function () {
                                Ae(C.document,
                                    Uc)
                            }))
})(window); !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
//# sourceMappingURL=angular.min.js.map

// lz-string
var LZString = function () { function o(o, r) { if (!t[o]) { t[o] = {}; for (var n = 0; n < o.length; n++)t[o][o.charAt(n)] = n } return t[o][r] } var r = String.fromCharCode, n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", t = {}, i = { compressToBase64: function (o) { if (null == o) return ""; var r = i._compress(o, 6, function (o) { return n.charAt(o) }); switch (r.length % 4) { default: case 0: return r; case 1: return r + "==="; case 2: return r + "=="; case 3: return r + "=" } }, decompressFromBase64: function (r) { return null == r ? "" : "" == r ? null : i._decompress(r.length, 32, function (e) { return o(n, r.charAt(e)) }) }, compressToUTF16: function (o) { return null == o ? "" : i._compress(o, 15, function (o) { return r(o + 32) }) + " " }, decompressFromUTF16: function (o) { return null == o ? "" : "" == o ? null : i._decompress(o.length, 16384, function (r) { return o.charCodeAt(r) - 32 }) }, compressToUint8Array: function (o) { for (var r = i.compress(o), n = new Uint8Array(2 * r.length), e = 0, t = r.length; t > e; e++) { var s = r.charCodeAt(e); n[2 * e] = s >>> 8, n[2 * e + 1] = s % 256 } return n }, decompressFromUint8Array: function (o) { if (null === o || void 0 === o) return i.decompress(o); for (var n = new Array(o.length / 2), e = 0, t = n.length; t > e; e++)n[e] = 256 * o[2 * e] + o[2 * e + 1]; var s = []; return n.forEach(function (o) { s.push(r(o)) }), i.decompress(s.join("")) }, compressToEncodedURIComponent: function (o) { return null == o ? "" : i._compress(o, 6, function (o) { return e.charAt(o) }) }, decompressFromEncodedURIComponent: function (r) { return null == r ? "" : "" == r ? null : (r = r.replace(/ /g, "+"), i._decompress(r.length, 32, function (n) { return o(e, r.charAt(n)) })) }, compress: function (o) { return i._compress(o, 16, function (o) { return r(o) }) }, _compress: function (o, r, n) { if (null == o) return ""; var e, t, i, s = {}, p = {}, u = "", c = "", a = "", l = 2, f = 3, h = 2, d = [], m = 0, v = 0; for (i = 0; i < o.length; i += 1)if (u = o.charAt(i), Object.prototype.hasOwnProperty.call(s, u) || (s[u] = f++, p[u] = !0), c = a + u, Object.prototype.hasOwnProperty.call(s, c)) a = c; else { if (Object.prototype.hasOwnProperty.call(p, a)) { if (a.charCodeAt(0) < 256) { for (e = 0; h > e; e++)m <<= 1, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++; for (t = a.charCodeAt(0), e = 0; 8 > e; e++)m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1 } else { for (t = 1, e = 0; h > e; e++)m = m << 1 | t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t = 0; for (t = a.charCodeAt(0), e = 0; 16 > e; e++)m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1 } l--, 0 == l && (l = Math.pow(2, h), h++), delete p[a] } else for (t = s[a], e = 0; h > e; e++)m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1; l--, 0 == l && (l = Math.pow(2, h), h++), s[c] = f++, a = String(u) } if ("" !== a) { if (Object.prototype.hasOwnProperty.call(p, a)) { if (a.charCodeAt(0) < 256) { for (e = 0; h > e; e++)m <<= 1, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++; for (t = a.charCodeAt(0), e = 0; 8 > e; e++)m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1 } else { for (t = 1, e = 0; h > e; e++)m = m << 1 | t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t = 0; for (t = a.charCodeAt(0), e = 0; 16 > e; e++)m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1 } l--, 0 == l && (l = Math.pow(2, h), h++), delete p[a] } else for (t = s[a], e = 0; h > e; e++)m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1; l--, 0 == l && (l = Math.pow(2, h), h++) } for (t = 2, e = 0; h > e; e++)m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1; for (; ;) { if (m <<= 1, v == r - 1) { d.push(n(m)); break } v++ } return d.join("") }, decompress: function (o) { return null == o ? "" : "" == o ? null : i._decompress(o.length, 32768, function (r) { return o.charCodeAt(r) }) }, _decompress: function (o, n, e) { var t, i, s, p, u, c, a, l, f = [], h = 4, d = 4, m = 3, v = "", w = [], A = { val: e(0), position: n, index: 1 }; for (i = 0; 3 > i; i += 1)f[i] = i; for (p = 0, c = Math.pow(2, 2), a = 1; a != c;)u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1; switch (t = p) { case 0: for (p = 0, c = Math.pow(2, 8), a = 1; a != c;)u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1; l = r(p); break; case 1: for (p = 0, c = Math.pow(2, 16), a = 1; a != c;)u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1; l = r(p); break; case 2: return "" }for (f[3] = l, s = l, w.push(l); ;) { if (A.index > o) return ""; for (p = 0, c = Math.pow(2, m), a = 1; a != c;)u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1; switch (l = p) { case 0: for (p = 0, c = Math.pow(2, 8), a = 1; a != c;)u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1; f[d++] = r(p), l = d - 1, h--; break; case 1: for (p = 0, c = Math.pow(2, 16), a = 1; a != c;)u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1; f[d++] = r(p), l = d - 1, h--; break; case 2: return w.join("") }if (0 == h && (h = Math.pow(2, m), m++), f[l]) v = f[l]; else { if (l !== d) return null; v = s + s.charAt(0) } w.push(v), f[d++] = s + v.charAt(0), h--, s = v, 0 == h && (h = Math.pow(2, m), m++) } } }; return i }(); "function" == typeof define && define.amd ? define(function () { return LZString }) : "undefined" != typeof module && null != module && (module.exports = LZString);

// PixiJS
/*!
 * pixi.js-legacy - v5.3.8
 * Compiled Sat, 20 Feb 2021 22:31:43 UTC
 *
 * pixi.js-legacy is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var PIXI = function (t) { "use strict"; var e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function r(t, e) { return t(e = { exports: {} }, e.exports), e.exports } var i = r(function (t, r) { !function (t) { var e = t.Promise, i = e && "resolve" in e && "reject" in e && "all" in e && "race" in e && function () { var t; return new e(function (e) { t = e }), "function" == typeof t }(); r ? (r.Promise = i ? e : T, r.Polyfill = T) : i || (t.Promise = T); var n = "pending", o = "sealed", s = "fulfilled", a = "rejected", h = function () { }; function u(t) { return "[object Array]" === Object.prototype.toString.call(t) } var l, c = "undefined" != typeof setImmediate ? setImmediate : setTimeout, d = []; function p() { for (var t = 0; t < d.length; t++)d[t][0](d[t][1]); d = [], l = !1 } function f(t, e) { d.push([t, e]), l || (l = !0, c(p, 0)) } function m(t) { var e = t.owner, r = e.state_, i = e.data_, n = t[r], o = t.then; if ("function" == typeof n) { r = s; try { i = n(i) } catch (t) { _(o, t) } } v(o, i) || (r === s && g(o, i), r === a && _(o, i)) } function v(t, e) { var r; try { if (t === e) throw new TypeError("A promises callback cannot return that same promise."); if (e && ("function" == typeof e || "object" == typeof e)) { var i = e.then; if ("function" == typeof i) return i.call(e, function (i) { r || (r = !0, e !== i ? g(t, i) : y(t, i)) }, function (e) { r || (r = !0, _(t, e)) }), !0 } } catch (e) { return r || _(t, e), !0 } return !1 } function g(t, e) { t !== e && v(t, e) || y(t, e) } function y(t, e) { t.state_ === n && (t.state_ = o, t.data_ = e, f(b, t)) } function _(t, e) { t.state_ === n && (t.state_ = o, t.data_ = e, f(E, t)) } function x(t) { var e = t.then_; t.then_ = void 0; for (var r = 0; r < e.length; r++)m(e[r]) } function b(t) { t.state_ = s, x(t) } function E(t) { t.state_ = a, x(t) } function T(t) { if ("function" != typeof t) throw new TypeError("Promise constructor takes a function argument"); if (this instanceof T == !1) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function."); this.then_ = [], function (t, e) { function r(t) { _(e, t) } try { t(function (t) { g(e, t) }, r) } catch (t) { r(t) } }(t, this) } T.prototype = { constructor: T, state_: n, then_: null, data_: void 0, then: function (t, e) { var r = { owner: this, then: new this.constructor(h), fulfilled: t, rejected: e }; return this.state_ === s || this.state_ === a ? f(m, r) : this.then_.push(r), r.then }, catch: function (t) { return this.then(null, t) } }, T.all = function (t) { if (!u(t)) throw new TypeError("You must pass an array to Promise.all()."); return new this(function (e, r) { var i = [], n = 0; function o(t) { return n++, function (r) { i[t] = r, --n || e(i) } } for (var s, a = 0; a < t.length; a++)(s = t[a]) && "function" == typeof s.then ? s.then(o(a), r) : i[a] = s; n || e(i) }) }, T.race = function (t) { if (!u(t)) throw new TypeError("You must pass an array to Promise.race()."); return new this(function (e, r) { for (var i, n = 0; n < t.length; n++)(i = t[n]) && "function" == typeof i.then ? i.then(e, r) : e(i) }) }, T.resolve = function (t) { return t && "object" == typeof t && t.constructor === this ? t : new this(function (e) { e(t) }) }, T.reject = function (t) { return new this(function (e, r) { r(t) }) } }("undefined" != typeof window ? window : void 0 !== e ? e : "undefined" != typeof self ? self : e) }), n = (i.Promise, i.Polyfill), o = Object.getOwnPropertySymbols, s = Object.prototype.hasOwnProperty, a = Object.prototype.propertyIsEnumerable; var h = function () { try { if (!Object.assign) return !1; var t = new String("abc"); if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1; for (var e = {}, r = 0; r < 10; r++)e["_" + String.fromCharCode(r)] = r; if ("0123456789" !== Object.getOwnPropertyNames(e).map(function (t) { return e[t] }).join("")) return !1; var i = {}; return "abcdefghijklmnopqrst".split("").forEach(function (t) { i[t] = t }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, i)).join("") } catch (t) { return !1 } }() ? Object.assign : function (t, e) { for (var r, i, n = arguments, h = function (t) { if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined"); return Object(t) }(t), u = 1; u < arguments.length; u++) { for (var l in r = Object(n[u])) s.call(r, l) && (h[l] = r[l]); if (o) { i = o(r); for (var c = 0; c < i.length; c++)a.call(r, i[c]) && (h[i[c]] = r[i[c]]) } } return h }; window.Promise || (window.Promise = n), Object.assign || (Object.assign = h); if (Date.now && Date.prototype.getTime || (Date.now = function () { return (new Date).getTime() }), !window.performance || !window.performance.now) { var u = Date.now(); window.performance || (window.performance = {}), window.performance.now = function () { return Date.now() - u } } for (var l = Date.now(), c = ["ms", "moz", "webkit", "o"], d = 0; d < c.length && !window.requestAnimationFrame; ++d) { var p = c[d]; window.requestAnimationFrame = window[p + "RequestAnimationFrame"], window.cancelAnimationFrame = window[p + "CancelAnimationFrame"] || window[p + "CancelRequestAnimationFrame"] } window.requestAnimationFrame || (window.requestAnimationFrame = function (t) { if ("function" != typeof t) throw new TypeError(t + "is not a function"); var e = Date.now(), r = 16 + l - e; return r < 0 && (r = 0), l = e, window.setTimeout(function () { l = Date.now(), t(performance.now()) }, r) }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function (t) { return clearTimeout(t) }), Math.sign || (Math.sign = function (t) { return 0 === (t = Number(t)) || isNaN(t) ? t : t > 0 ? 1 : -1 }), Number.isInteger || (Number.isInteger = function (t) { return "number" == typeof t && isFinite(t) && Math.floor(t) === t }), window.ArrayBuffer || (window.ArrayBuffer = Array), window.Float32Array || (window.Float32Array = Array), window.Uint32Array || (window.Uint32Array = Array), window.Uint16Array || (window.Uint16Array = Array), window.Uint8Array || (window.Uint8Array = Array), window.Int32Array || (window.Int32Array = Array); var f = /iPhone/i, m = /iPod/i, v = /iPad/i, g = /\biOS-universal(?:.+)Mac\b/i, y = /\bAndroid(?:.+)Mobile\b/i, _ = /Android/i, x = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, b = /Silk/i, E = /Windows Phone/i, T = /\bWindows(?:.+)ARM\b/i, S = /BlackBerry/i, w = /BB10/i, P = /Opera Mini/i, I = /\b(CriOS|Chrome)(?:.+)Mobile/i, A = /Mobile(?:.+)Firefox\b/i, O = function (t) { return void 0 !== t && "MacIntel" === t.platform && "number" == typeof t.maxTouchPoints && t.maxTouchPoints > 1 && "undefined" == typeof MSStream }; var M = function (t) { var e = { userAgent: "", platform: "", maxTouchPoints: 0 }; t || "undefined" == typeof navigator ? "string" == typeof t ? e.userAgent = t : t && t.userAgent && (e = { userAgent: t.userAgent, platform: t.platform, maxTouchPoints: t.maxTouchPoints || 0 }) : e = { userAgent: navigator.userAgent, platform: navigator.platform, maxTouchPoints: navigator.maxTouchPoints || 0 }; var r = e.userAgent, i = r.split("[FBAN"); void 0 !== i[1] && (r = i[0]), void 0 !== (i = r.split("Twitter"))[1] && (r = i[0]); var n = function (t) { return function (e) { return e.test(t) } }(r), o = { apple: { phone: n(f) && !n(E), ipod: n(m), tablet: !n(f) && (n(v) || O(e)) && !n(E), universal: n(g), device: (n(f) || n(m) || n(v) || n(g) || O(e)) && !n(E) }, amazon: { phone: n(x), tablet: !n(x) && n(b), device: n(x) || n(b) }, android: { phone: !n(E) && n(x) || !n(E) && n(y), tablet: !n(E) && !n(x) && !n(y) && (n(b) || n(_)), device: !n(E) && (n(x) || n(b) || n(y) || n(_)) || n(/\bokhttp\b/i) }, windows: { phone: n(E), tablet: n(T), device: n(E) || n(T) }, other: { blackberry: n(S), blackberry10: n(w), opera: n(P), firefox: n(A), chrome: n(I), device: n(S) || n(w) || n(P) || n(A) || n(I) }, any: !1, phone: !1, tablet: !1 }; return o.any = o.apple.device || o.android.device || o.windows.device || o.other.device, o.phone = o.apple.phone || o.android.phone || o.windows.phone, o.tablet = o.apple.tablet || o.android.tablet || o.windows.tablet, o }(window.navigator); var D = { MIPMAP_TEXTURES: 1, ANISOTROPIC_LEVEL: 0, RESOLUTION: 1, FILTER_RESOLUTION: 1, SPRITE_MAX_TEXTURES: function (t) { var e = !0; if (M.tablet || M.phone) { var r; M.apple.device && (r = navigator.userAgent.match(/OS (\d+)_(\d+)?/)) && parseInt(r[1], 10) < 11 && (e = !1), M.android.device && (r = navigator.userAgent.match(/Android\s([0-9.]*)/)) && parseInt(r[1], 10) < 7 && (e = !1) } return e ? t : 4 }(32), SPRITE_BATCH_SIZE: 4096, RENDER_OPTIONS: { view: null, antialias: !1, autoDensity: !1, transparent: !1, backgroundColor: 0, clearBeforeRender: !0, preserveDrawingBuffer: !1, width: 800, height: 600, legacy: !1 }, GC_MODE: 0, GC_MAX_IDLE: 3600, GC_MAX_CHECK_COUNT: 600, WRAP_MODE: 33071, SCALE_MODE: 1, PRECISION_VERTEX: "highp", PRECISION_FRAGMENT: M.apple.device ? "highp" : "mediump", CAN_UPLOAD_SAME_BUFFER: !M.apple.device, CREATE_IMAGE_BITMAP: !1, ROUND_PIXELS: !1 }, C = r(function (t) { var e = Object.prototype.hasOwnProperty, r = "~"; function i() { } function n(t, e, r) { this.fn = t, this.context = e, this.once = r || !1 } function o(t, e, i, o, s) { if ("function" != typeof i) throw new TypeError("The listener must be a function"); var a = new n(i, o || t, s), h = r ? r + e : e; return t._events[h] ? t._events[h].fn ? t._events[h] = [t._events[h], a] : t._events[h].push(a) : (t._events[h] = a, t._eventsCount++), t } function s(t, e) { 0 == --t._eventsCount ? t._events = new i : delete t._events[e] } function a() { this._events = new i, this._eventsCount = 0 } Object.create && (i.prototype = Object.create(null), (new i).__proto__ || (r = !1)), a.prototype.eventNames = function () { var t, i, n = []; if (0 === this._eventsCount) return n; for (i in t = this._events) e.call(t, i) && n.push(r ? i.slice(1) : i); return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(t)) : n }, a.prototype.listeners = function (t) { var e = r ? r + t : t, i = this._events[e]; if (!i) return []; if (i.fn) return [i.fn]; for (var n = 0, o = i.length, s = new Array(o); n < o; n++)s[n] = i[n].fn; return s }, a.prototype.listenerCount = function (t) { var e = r ? r + t : t, i = this._events[e]; return i ? i.fn ? 1 : i.length : 0 }, a.prototype.emit = function (t, e, i, n, o, s) { var a = arguments, h = r ? r + t : t; if (!this._events[h]) return !1; var u, l, c = this._events[h], d = arguments.length; if (c.fn) { switch (c.once && this.removeListener(t, c.fn, void 0, !0), d) { case 1: return c.fn.call(c.context), !0; case 2: return c.fn.call(c.context, e), !0; case 3: return c.fn.call(c.context, e, i), !0; case 4: return c.fn.call(c.context, e, i, n), !0; case 5: return c.fn.call(c.context, e, i, n, o), !0; case 6: return c.fn.call(c.context, e, i, n, o, s), !0 }for (l = 1, u = new Array(d - 1); l < d; l++)u[l - 1] = a[l]; c.fn.apply(c.context, u) } else { var p, f = c.length; for (l = 0; l < f; l++)switch (c[l].once && this.removeListener(t, c[l].fn, void 0, !0), d) { case 1: c[l].fn.call(c[l].context); break; case 2: c[l].fn.call(c[l].context, e); break; case 3: c[l].fn.call(c[l].context, e, i); break; case 4: c[l].fn.call(c[l].context, e, i, n); break; default: if (!u) for (p = 1, u = new Array(d - 1); p < d; p++)u[p - 1] = a[p]; c[l].fn.apply(c[l].context, u) } } return !0 }, a.prototype.on = function (t, e, r) { return o(this, t, e, r, !1) }, a.prototype.once = function (t, e, r) { return o(this, t, e, r, !0) }, a.prototype.removeListener = function (t, e, i, n) { var o = r ? r + t : t; if (!this._events[o]) return this; if (!e) return s(this, o), this; var a = this._events[o]; if (a.fn) a.fn !== e || n && !a.once || i && a.context !== i || s(this, o); else { for (var h = 0, u = [], l = a.length; h < l; h++)(a[h].fn !== e || n && !a[h].once || i && a[h].context !== i) && u.push(a[h]); u.length ? this._events[o] = 1 === u.length ? u[0] : u : s(this, o) } return this }, a.prototype.removeAllListeners = function (t) { var e; return t ? (e = r ? r + t : t, this._events[e] && s(this, e)) : (this._events = new i, this._eventsCount = 0), this }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, t.exports = a }), R = N, L = N; function N(t, e, r) { r = r || 2; var i, n, o, s, a, h, u, l = e && e.length, c = l ? e[0] * r : t.length, d = F(t, 0, c, r, !0), p = []; if (!d || d.next === d.prev) return p; if (l && (d = function (t, e, r, i) { var n, o, s, a, h, u = []; for (n = 0, o = e.length; n < o; n++)s = e[n] * i, a = n < o - 1 ? e[n + 1] * i : t.length, (h = F(t, s, a, i, !1)) === h.next && (h.steiner = !0), u.push(W(h)); for (u.sort(G), n = 0; n < u.length; n++)Y(u[n], r), r = B(r, r.next); return r }(t, e, d, r)), t.length > 80 * r) { i = o = t[0], n = s = t[1]; for (var f = r; f < c; f += r)(a = t[f]) < i && (i = a), (h = t[f + 1]) < n && (n = h), a > o && (o = a), h > s && (s = h); u = 0 !== (u = Math.max(o - i, s - n)) ? 1 / u : 0 } return U(d, p, r, i, n, u), p } function F(t, e, r, i, n) { var o, s; if (n === st(t, e, r, i) > 0) for (o = e; o < r; o += i)s = it(o, t[o], t[o + 1], s); else for (o = r - i; o >= e; o -= i)s = it(o, t[o], t[o + 1], s); return s && J(s, s.next) && (nt(s), s = s.next), s } function B(t, e) { if (!t) return t; e || (e = t); var r, i = t; do { if (r = !1, i.steiner || !J(i, i.next) && 0 !== Z(i.prev, i, i.next)) i = i.next; else { if (nt(i), (i = e = i.prev) === i.next) break; r = !0 } } while (r || i !== e); return e } function U(t, e, r, i, n, o, s) { if (t) { !s && o && function (t, e, r, i) { var n = t; do { null === n.z && (n.z = V(n.x, n.y, e, r, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next } while (n !== t); n.prevZ.nextZ = null, n.prevZ = null, function (t) { var e, r, i, n, o, s, a, h, u = 1; do { for (r = t, t = null, o = null, s = 0; r;) { for (s++, i = r, a = 0, e = 0; e < u && (a++, i = i.nextZ); e++); for (h = u; a > 0 || h > 0 && i;)0 !== a && (0 === h || !i || r.z <= i.z) ? (n = r, r = r.nextZ, a--) : (n = i, i = i.nextZ, h--), o ? o.nextZ = n : t = n, n.prevZ = o, o = n; r = i } o.nextZ = null, u *= 2 } while (s > 1) }(n) }(t, i, n, o); for (var a, h, u = t; t.prev !== t.next;)if (a = t.prev, h = t.next, o ? X(t, i, n, o) : k(t)) e.push(a.i / r), e.push(t.i / r), e.push(h.i / r), nt(t), t = h.next, u = h.next; else if ((t = h) === u) { s ? 1 === s ? U(t = j(B(t), e, r), e, r, i, n, o, 2) : 2 === s && H(t, e, r, i, n, o) : U(B(t), e, r, i, n, o, 1); break } } } function k(t) { var e = t.prev, r = t, i = t.next; if (Z(e, r, i) >= 0) return !1; for (var n = t.next.next; n !== t.prev;) { if (q(e.x, e.y, r.x, r.y, i.x, i.y, n.x, n.y) && Z(n.prev, n, n.next) >= 0) return !1; n = n.next } return !0 } function X(t, e, r, i) { var n = t.prev, o = t, s = t.next; if (Z(n, o, s) >= 0) return !1; for (var a = n.x < o.x ? n.x < s.x ? n.x : s.x : o.x < s.x ? o.x : s.x, h = n.y < o.y ? n.y < s.y ? n.y : s.y : o.y < s.y ? o.y : s.y, u = n.x > o.x ? n.x > s.x ? n.x : s.x : o.x > s.x ? o.x : s.x, l = n.y > o.y ? n.y > s.y ? n.y : s.y : o.y > s.y ? o.y : s.y, c = V(a, h, e, r, i), d = V(u, l, e, r, i), p = t.prevZ, f = t.nextZ; p && p.z >= c && f && f.z <= d;) { if (p !== t.prev && p !== t.next && q(n.x, n.y, o.x, o.y, s.x, s.y, p.x, p.y) && Z(p.prev, p, p.next) >= 0) return !1; if (p = p.prevZ, f !== t.prev && f !== t.next && q(n.x, n.y, o.x, o.y, s.x, s.y, f.x, f.y) && Z(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } for (; p && p.z >= c;) { if (p !== t.prev && p !== t.next && q(n.x, n.y, o.x, o.y, s.x, s.y, p.x, p.y) && Z(p.prev, p, p.next) >= 0) return !1; p = p.prevZ } for (; f && f.z <= d;) { if (f !== t.prev && f !== t.next && q(n.x, n.y, o.x, o.y, s.x, s.y, f.x, f.y) && Z(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } return !0 } function j(t, e, r) { var i = t; do { var n = i.prev, o = i.next.next; !J(n, o) && Q(n, i, i.next, o) && et(n, o) && et(o, n) && (e.push(n.i / r), e.push(i.i / r), e.push(o.i / r), nt(i), nt(i.next), i = t = o), i = i.next } while (i !== t); return B(i) } function H(t, e, r, i, n, o) { var s = t; do { for (var a = s.next.next; a !== s.prev;) { if (s.i !== a.i && K(s, a)) { var h = rt(s, a); return s = B(s, s.next), h = B(h, h.next), U(s, e, r, i, n, o), void U(h, e, r, i, n, o) } a = a.next } s = s.next } while (s !== t) } function G(t, e) { return t.x - e.x } function Y(t, e) { if (e = function (t, e) { var r, i = e, n = t.x, o = t.y, s = -1 / 0; do { if (o <= i.y && o >= i.next.y && i.next.y !== i.y) { var a = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y); if (a <= n && a > s) { if (s = a, a === n) { if (o === i.y) return i; if (o === i.next.y) return i.next } r = i.x < i.next.x ? i : i.next } } i = i.next } while (i !== e); if (!r) return null; if (n === s) return r; var h, u = r, l = r.x, c = r.y, d = 1 / 0; i = r; do { n >= i.x && i.x >= l && n !== i.x && q(o < c ? n : s, o, l, c, o < c ? s : n, o, i.x, i.y) && (h = Math.abs(o - i.y) / (n - i.x), et(i, t) && (h < d || h === d && (i.x > r.x || i.x === r.x && z(r, i))) && (r = i, d = h)), i = i.next } while (i !== u); return r }(t, e)) { var r = rt(e, t); B(e, e.next), B(r, r.next) } } function z(t, e) { return Z(t.prev, t, e.prev) < 0 && Z(e.next, t, t.next) < 0 } function V(t, e, r, i, n) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * n) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * n) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function W(t) { var e = t, r = t; do { (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next } while (e !== t); return r } function q(t, e, r, i, n, o, s, a) { return (n - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (i - a) - (r - s) * (e - a) >= 0 && (r - s) * (o - a) - (n - s) * (i - a) >= 0 } function K(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) { var r = t; do { if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && Q(r, r.next, t, e)) return !0; r = r.next } while (r !== t); return !1 }(t, e) && (et(t, e) && et(e, t) && function (t, e) { var r = t, i = !1, n = (t.x + e.x) / 2, o = (t.y + e.y) / 2; do { r.y > o != r.next.y > o && r.next.y !== r.y && n < (r.next.x - r.x) * (o - r.y) / (r.next.y - r.y) + r.x && (i = !i), r = r.next } while (r !== t); return i }(t, e) && (Z(t.prev, t, e.prev) || Z(t, e.prev, e)) || J(t, e) && Z(t.prev, t, t.next) > 0 && Z(e.prev, e, e.next) > 0) } function Z(t, e, r) { return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y) } function J(t, e) { return t.x === e.x && t.y === e.y } function Q(t, e, r, i) { var n = tt(Z(t, e, r)), o = tt(Z(t, e, i)), s = tt(Z(r, i, t)), a = tt(Z(r, i, e)); return n !== o && s !== a || (!(0 !== n || !$(t, r, e)) || (!(0 !== o || !$(t, i, e)) || (!(0 !== s || !$(r, t, i)) || !(0 !== a || !$(r, e, i))))) } function $(t, e, r) { return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y) } function tt(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function et(t, e) { return Z(t.prev, t, t.next) < 0 ? Z(t, e, t.next) >= 0 && Z(t, t.prev, e) >= 0 : Z(t, e, t.prev) < 0 || Z(t, t.next, e) < 0 } function rt(t, e) { var r = new ot(t.i, t.x, t.y), i = new ot(e.i, e.x, e.y), n = t.next, o = e.prev; return t.next = e, e.prev = t, r.next = n, n.prev = r, i.next = r, r.prev = i, o.next = i, i.prev = o, i } function it(t, e, r, i) { var n = new ot(t, e, r); return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n } function nt(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function ot(t, e, r) { this.i = t, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function st(t, e, r, i) { for (var n = 0, o = e, s = r - i; o < r; o += i)n += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o; return n } N.deviation = function (t, e, r, i) { var n = e && e.length, o = n ? e[0] * r : t.length, s = Math.abs(st(t, 0, o, r)); if (n) for (var a = 0, h = e.length; a < h; a++) { var u = e[a] * r, l = a < h - 1 ? e[a + 1] * r : t.length; s -= Math.abs(st(t, u, l, r)) } var c = 0; for (a = 0; a < i.length; a += 3) { var d = i[a] * r, p = i[a + 1] * r, f = i[a + 2] * r; c += Math.abs((t[d] - t[f]) * (t[p + 1] - t[d + 1]) - (t[d] - t[p]) * (t[f + 1] - t[d + 1])) } return 0 === s && 0 === c ? 0 : Math.abs((c - s) / s) }, N.flatten = function (t) { for (var e = t[0][0].length, r = { vertices: [], holes: [], dimensions: e }, i = 0, n = 0; n < t.length; n++) { for (var o = 0; o < t[n].length; o++)for (var s = 0; s < e; s++)r.vertices.push(t[n][o][s]); n > 0 && (i += t[n - 1].length, r.holes.push(i)) } return r }, R.default = L; var at = r(function (t, r) { !function (i) { var n = r && !r.nodeType && r, o = t && !t.nodeType && t, s = "object" == typeof e && e; s.global !== s && s.window !== s && s.self !== s || (i = s); var a, h, u = 2147483647, l = 36, c = 1, d = 26, p = 38, f = 700, m = 72, v = 128, g = "-", y = /^xn--/, _ = /[^\x20-\x7E]/, x = /[\x2E\u3002\uFF0E\uFF61]/g, b = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, E = l - c, T = Math.floor, S = String.fromCharCode; function w(t) { throw RangeError(b[t]) } function P(t, e) { for (var r = t.length, i = []; r--;)i[r] = e(t[r]); return i } function I(t, e) { var r = t.split("@"), i = ""; return r.length > 1 && (i = r[0] + "@", t = r[1]), i + P((t = t.replace(x, ".")).split("."), e).join(".") } function A(t) { for (var e, r, i = [], n = 0, o = t.length; n < o;)(e = t.charCodeAt(n++)) >= 55296 && e <= 56319 && n < o ? 56320 == (64512 & (r = t.charCodeAt(n++))) ? i.push(((1023 & e) << 10) + (1023 & r) + 65536) : (i.push(e), n--) : i.push(e); return i } function O(t) { return P(t, function (t) { var e = ""; return t > 65535 && (e += S((t -= 65536) >>> 10 & 1023 | 55296), t = 56320 | 1023 & t), e += S(t) }).join("") } function M(t, e) { return t + 22 + 75 * (t < 26) - ((0 != e) << 5) } function D(t, e, r) { var i = 0; for (t = r ? T(t / f) : t >> 1, t += T(t / e); t > E * d >> 1; i += l)t = T(t / E); return T(i + (E + 1) * t / (t + p)) } function C(t) { var e, r, i, n, o, s, a, h, p, f, y, _ = [], x = t.length, b = 0, E = v, S = m; for ((r = t.lastIndexOf(g)) < 0 && (r = 0), i = 0; i < r; ++i)t.charCodeAt(i) >= 128 && w("not-basic"), _.push(t.charCodeAt(i)); for (n = r > 0 ? r + 1 : 0; n < x;) { for (o = b, s = 1, a = l; n >= x && w("invalid-input"), ((h = (y = t.charCodeAt(n++)) - 48 < 10 ? y - 22 : y - 65 < 26 ? y - 65 : y - 97 < 26 ? y - 97 : l) >= l || h > T((u - b) / s)) && w("overflow"), b += h * s, !(h < (p = a <= S ? c : a >= S + d ? d : a - S)); a += l)s > T(u / (f = l - p)) && w("overflow"), s *= f; S = D(b - o, e = _.length + 1, 0 == o), T(b / e) > u - E && w("overflow"), E += T(b / e), b %= e, _.splice(b++, 0, E) } return O(_) } function R(t) { var e, r, i, n, o, s, a, h, p, f, y, _, x, b, E, P = []; for (_ = (t = A(t)).length, e = v, r = 0, o = m, s = 0; s < _; ++s)(y = t[s]) < 128 && P.push(S(y)); for (i = n = P.length, n && P.push(g); i < _;) { for (a = u, s = 0; s < _; ++s)(y = t[s]) >= e && y < a && (a = y); for (a - e > T((u - r) / (x = i + 1)) && w("overflow"), r += (a - e) * x, e = a, s = 0; s < _; ++s)if ((y = t[s]) < e && ++r > u && w("overflow"), y == e) { for (h = r, p = l; !(h < (f = p <= o ? c : p >= o + d ? d : p - o)); p += l)E = h - f, b = l - f, P.push(S(M(f + E % b, 0))), h = T(E / b); P.push(S(M(h, 0))), o = D(r, x, i == n), r = 0, ++i } ++r, ++e } return P.join("") } if (a = { version: "1.3.2", ucs2: { decode: A, encode: O }, decode: C, encode: R, toASCII: function (t) { return I(t, function (t) { return _.test(t) ? "xn--" + R(t) : t }) }, toUnicode: function (t) { return I(t, function (t) { return y.test(t) ? C(t.slice(4).toLowerCase()) : t }) } }, n && o) if (t.exports == n) o.exports = a; else for (h in a) a.hasOwnProperty(h) && (n[h] = a[h]); else i.punycode = a }(e) }), ht = { isString: function (t) { return "string" == typeof t }, isObject: function (t) { return "object" == typeof t && null !== t }, isNull: function (t) { return null === t }, isNullOrUndefined: function (t) { return null == t } }; ht.isString, ht.isObject, ht.isNull, ht.isNullOrUndefined; function ut(t, e) { return Object.prototype.hasOwnProperty.call(t, e) } var lt = function (t, e, r, i) { e = e || "&", r = r || "="; var n = {}; if ("string" != typeof t || 0 === t.length) return n; var o = /\+/g; t = t.split(e); var s = 1e3; i && "number" == typeof i.maxKeys && (s = i.maxKeys); var a = t.length; s > 0 && a > s && (a = s); for (var h = 0; h < a; ++h) { var u, l, c, d, p = t[h].replace(o, "%20"), f = p.indexOf(r); f >= 0 ? (u = p.substr(0, f), l = p.substr(f + 1)) : (u = p, l = ""), c = decodeURIComponent(u), d = decodeURIComponent(l), ut(n, c) ? Array.isArray(n[c]) ? n[c].push(d) : n[c] = [n[c], d] : n[c] = d } return n }, ct = function (t) { switch (typeof t) { case "string": return t; case "boolean": return t ? "true" : "false"; case "number": return isFinite(t) ? t : ""; default: return "" } }, dt = function (t, e, r, i) { return e = e || "&", r = r || "=", null === t && (t = void 0), "object" == typeof t ? Object.keys(t).map(function (i) { var n = encodeURIComponent(ct(i)) + r; return Array.isArray(t[i]) ? t[i].map(function (t) { return n + encodeURIComponent(ct(t)) }).join(e) : n + encodeURIComponent(ct(t[i])) }).join(e) : i ? encodeURIComponent(ct(i)) + r + encodeURIComponent(ct(t)) : "" }, pt = r(function (t, e) { e.decode = e.parse = lt, e.encode = e.stringify = dt }), ft = (pt.decode, pt.parse, pt.encode, pt.stringify, Ct), mt = function (t, e) { return Ct(t, !1, !0).resolve(e) }, vt = function (t, e) { if (!t) return e; return Ct(t, !1, !0).resolveObject(e) }, gt = function (t) { ht.isString(t) && (t = Ct(t)); if (!(t instanceof _t)) return _t.prototype.format.call(t); return t.format() }, yt = _t; function _t() { this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null } var xt = /^([a-z0-9.+-]+:)/i, bt = /:[0-9]*$/, Et = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, Tt = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"]), St = ["'"].concat(Tt), wt = ["%", "/", "?", ";", "#"].concat(St), Pt = ["/", "?", "#"], It = /^[+a-z0-9A-Z_-]{0,63}$/, At = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, Ot = { javascript: !0, "javascript:": !0 }, Mt = { javascript: !0, "javascript:": !0 }, Dt = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, "http:": !0, "https:": !0, "ftp:": !0, "gopher:": !0, "file:": !0 }; function Ct(t, e, r) { if (t && ht.isObject(t) && t instanceof _t) return t; var i = new _t; return i.parse(t, e, r), i } _t.prototype.parse = function (t, e, r) { if (!ht.isString(t)) throw new TypeError("Parameter 'url' must be a string, not " + typeof t); var i = t.indexOf("?"), n = -1 !== i && i < t.indexOf("#") ? "?" : "#", o = t.split(n); o[0] = o[0].replace(/\\/g, "/"); var s = t = o.join(n); if (s = s.trim(), !r && 1 === t.split("#").length) { var a = Et.exec(s); if (a) return this.path = s, this.href = s, this.pathname = a[1], a[2] ? (this.search = a[2], this.query = e ? pt.parse(this.search.substr(1)) : this.search.substr(1)) : e && (this.search = "", this.query = {}), this } var h = xt.exec(s); if (h) { var u = (h = h[0]).toLowerCase(); this.protocol = u, s = s.substr(h.length) } if (r || h || s.match(/^\/\/[^@\/]+@[^@\/]+/)) { var l = "//" === s.substr(0, 2); !l || h && Mt[h] || (s = s.substr(2), this.slashes = !0) } if (!Mt[h] && (l || h && !Dt[h])) { for (var c, d, p = -1, f = 0; f < Pt.length; f++) { -1 !== (m = s.indexOf(Pt[f])) && (-1 === p || m < p) && (p = m) } -1 !== (d = -1 === p ? s.lastIndexOf("@") : s.lastIndexOf("@", p)) && (c = s.slice(0, d), s = s.slice(d + 1), this.auth = decodeURIComponent(c)), p = -1; for (f = 0; f < wt.length; f++) { var m; -1 !== (m = s.indexOf(wt[f])) && (-1 === p || m < p) && (p = m) } -1 === p && (p = s.length), this.host = s.slice(0, p), s = s.slice(p), this.parseHost(), this.hostname = this.hostname || ""; var v = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1]; if (!v) for (var g = this.hostname.split(/\./), y = (f = 0, g.length); f < y; f++) { var _ = g[f]; if (_ && !_.match(It)) { for (var x = "", b = 0, E = _.length; b < E; b++)_.charCodeAt(b) > 127 ? x += "x" : x += _[b]; if (!x.match(It)) { var T = g.slice(0, f), S = g.slice(f + 1), w = _.match(At); w && (T.push(w[1]), S.unshift(w[2])), S.length && (s = "/" + S.join(".") + s), this.hostname = T.join("."); break } } } this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), v || (this.hostname = at.toASCII(this.hostname)); var P = this.port ? ":" + this.port : "", I = this.hostname || ""; this.host = I + P, this.href += this.host, v && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== s[0] && (s = "/" + s)) } if (!Ot[u]) for (f = 0, y = St.length; f < y; f++) { var A = St[f]; if (-1 !== s.indexOf(A)) { var O = encodeURIComponent(A); O === A && (O = escape(A)), s = s.split(A).join(O) } } var M = s.indexOf("#"); -1 !== M && (this.hash = s.substr(M), s = s.slice(0, M)); var D = s.indexOf("?"); if (-1 !== D ? (this.search = s.substr(D), this.query = s.substr(D + 1), e && (this.query = pt.parse(this.query)), s = s.slice(0, D)) : e && (this.search = "", this.query = {}), s && (this.pathname = s), Dt[u] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) { P = this.pathname || ""; var C = this.search || ""; this.path = P + C } return this.href = this.format(), this }, _t.prototype.format = function () { var t = this.auth || ""; t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, ":"), t += "@"); var e = this.protocol || "", r = this.pathname || "", i = this.hash || "", n = !1, o = ""; this.host ? n = t + this.host : this.hostname && (n = t + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (n += ":" + this.port)), this.query && ht.isObject(this.query) && Object.keys(this.query).length && (o = pt.stringify(this.query)); var s = this.search || o && "?" + o || ""; return e && ":" !== e.substr(-1) && (e += ":"), this.slashes || (!e || Dt[e]) && !1 !== n ? (n = "//" + (n || ""), r && "/" !== r.charAt(0) && (r = "/" + r)) : n || (n = ""), i && "#" !== i.charAt(0) && (i = "#" + i), s && "?" !== s.charAt(0) && (s = "?" + s), e + n + (r = r.replace(/[?#]/g, function (t) { return encodeURIComponent(t) })) + (s = s.replace("#", "%23")) + i }, _t.prototype.resolve = function (t) { return this.resolveObject(Ct(t, !1, !0)).format() }, _t.prototype.resolveObject = function (t) { if (ht.isString(t)) { var e = new _t; e.parse(t, !1, !0), t = e } for (var r = new _t, i = Object.keys(this), n = 0; n < i.length; n++) { var o = i[n]; r[o] = this[o] } if (r.hash = t.hash, "" === t.href) return r.href = r.format(), r; if (t.slashes && !t.protocol) { for (var s = Object.keys(t), a = 0; a < s.length; a++) { var h = s[a]; "protocol" !== h && (r[h] = t[h]) } return Dt[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r } if (t.protocol && t.protocol !== r.protocol) { if (!Dt[t.protocol]) { for (var u = Object.keys(t), l = 0; l < u.length; l++) { var c = u[l]; r[c] = t[c] } return r.href = r.format(), r } if (r.protocol = t.protocol, t.host || Mt[t.protocol]) r.pathname = t.pathname; else { for (var d = (t.pathname || "").split("/"); d.length && !(t.host = d.shift());); t.host || (t.host = ""), t.hostname || (t.hostname = ""), "" !== d[0] && d.unshift(""), d.length < 2 && d.unshift(""), r.pathname = d.join("/") } if (r.search = t.search, r.query = t.query, r.host = t.host || "", r.auth = t.auth, r.hostname = t.hostname || t.host, r.port = t.port, r.pathname || r.search) { var p = r.pathname || "", f = r.search || ""; r.path = p + f } return r.slashes = r.slashes || t.slashes, r.href = r.format(), r } var m = r.pathname && "/" === r.pathname.charAt(0), v = t.host || t.pathname && "/" === t.pathname.charAt(0), g = v || m || r.host && t.pathname, y = g, _ = r.pathname && r.pathname.split("/") || [], x = (d = t.pathname && t.pathname.split("/") || [], r.protocol && !Dt[r.protocol]); if (x && (r.hostname = "", r.port = null, r.host && ("" === _[0] ? _[0] = r.host : _.unshift(r.host)), r.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && ("" === d[0] ? d[0] = t.host : d.unshift(t.host)), t.host = null), g = g && ("" === d[0] || "" === _[0])), v) r.host = t.host || "" === t.host ? t.host : r.host, r.hostname = t.hostname || "" === t.hostname ? t.hostname : r.hostname, r.search = t.search, r.query = t.query, _ = d; else if (d.length) _ || (_ = []), _.pop(), _ = _.concat(d), r.search = t.search, r.query = t.query; else if (!ht.isNullOrUndefined(t.search)) { if (x) r.hostname = r.host = _.shift(), (w = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = w.shift(), r.host = r.hostname = w.shift()); return r.search = t.search, r.query = t.query, ht.isNull(r.pathname) && ht.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r } if (!_.length) return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r; for (var b = _.slice(-1)[0], E = (r.host || t.host || _.length > 1) && ("." === b || ".." === b) || "" === b, T = 0, S = _.length; S >= 0; S--)"." === (b = _[S]) ? _.splice(S, 1) : ".." === b ? (_.splice(S, 1), T++) : T && (_.splice(S, 1), T--); if (!g && !y) for (; T--; T)_.unshift(".."); !g || "" === _[0] || _[0] && "/" === _[0].charAt(0) || _.unshift(""), E && "/" !== _.join("/").substr(-1) && _.push(""); var w, P = "" === _[0] || _[0] && "/" === _[0].charAt(0); x && (r.hostname = r.host = P ? "" : _.length ? _.shift() : "", (w = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = w.shift(), r.host = r.hostname = w.shift())); return (g = g || r.host && _.length) && !P && _.unshift(""), _.length ? r.pathname = _.join("/") : (r.pathname = null, r.path = null), ht.isNull(r.pathname) && ht.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = t.auth || r.auth, r.slashes = r.slashes || t.slashes, r.href = r.format(), r }, _t.prototype.parseHost = function () { var t = this.host, e = bt.exec(t); e && (":" !== (e = e[0]) && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t) }; var Rt = { parse: ft, resolve: mt, resolveObject: vt, format: gt, Url: yt }; !function (t) { t[t.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t[t.WEBGL = 1] = "WEBGL", t[t.WEBGL2 = 2] = "WEBGL2" }(t.ENV || (t.ENV = {})), function (t) { t[t.UNKNOWN = 0] = "UNKNOWN", t[t.WEBGL = 1] = "WEBGL", t[t.CANVAS = 2] = "CANVAS" }(t.RENDERER_TYPE || (t.RENDERER_TYPE = {})), function (t) { t[t.COLOR = 16384] = "COLOR", t[t.DEPTH = 256] = "DEPTH", t[t.STENCIL = 1024] = "STENCIL" }(t.BUFFER_BITS || (t.BUFFER_BITS = {})), function (t) { t[t.NORMAL = 0] = "NORMAL", t[t.ADD = 1] = "ADD", t[t.MULTIPLY = 2] = "MULTIPLY", t[t.SCREEN = 3] = "SCREEN", t[t.OVERLAY = 4] = "OVERLAY", t[t.DARKEN = 5] = "DARKEN", t[t.LIGHTEN = 6] = "LIGHTEN", t[t.COLOR_DODGE = 7] = "COLOR_DODGE", t[t.COLOR_BURN = 8] = "COLOR_BURN", t[t.HARD_LIGHT = 9] = "HARD_LIGHT", t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT", t[t.DIFFERENCE = 11] = "DIFFERENCE", t[t.EXCLUSION = 12] = "EXCLUSION", t[t.HUE = 13] = "HUE", t[t.SATURATION = 14] = "SATURATION", t[t.COLOR = 15] = "COLOR", t[t.LUMINOSITY = 16] = "LUMINOSITY", t[t.NORMAL_NPM = 17] = "NORMAL_NPM", t[t.ADD_NPM = 18] = "ADD_NPM", t[t.SCREEN_NPM = 19] = "SCREEN_NPM", t[t.NONE = 20] = "NONE", t[t.SRC_OVER = 0] = "SRC_OVER", t[t.SRC_IN = 21] = "SRC_IN", t[t.SRC_OUT = 22] = "SRC_OUT", t[t.SRC_ATOP = 23] = "SRC_ATOP", t[t.DST_OVER = 24] = "DST_OVER", t[t.DST_IN = 25] = "DST_IN", t[t.DST_OUT = 26] = "DST_OUT", t[t.DST_ATOP = 27] = "DST_ATOP", t[t.ERASE = 26] = "ERASE", t[t.SUBTRACT = 28] = "SUBTRACT", t[t.XOR = 29] = "XOR" }(t.BLEND_MODES || (t.BLEND_MODES = {})), function (t) { t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN" }(t.DRAW_MODES || (t.DRAW_MODES = {})), function (t) { t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL" }(t.FORMATS || (t.FORMATS = {})), function (t) { t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z" }(t.TARGETS || (t.TARGETS = {})), function (t) { t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.FLOAT = 5126] = "FLOAT", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT" }(t.TYPES || (t.TYPES = {})), function (t) { t[t.NEAREST = 0] = "NEAREST", t[t.LINEAR = 1] = "LINEAR" }(t.SCALE_MODES || (t.SCALE_MODES = {})), function (t) { t[t.CLAMP = 33071] = "CLAMP", t[t.REPEAT = 10497] = "REPEAT", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT" }(t.WRAP_MODES || (t.WRAP_MODES = {})), function (t) { t[t.OFF = 0] = "OFF", t[t.POW2 = 1] = "POW2", t[t.ON = 2] = "ON" }(t.MIPMAP_MODES || (t.MIPMAP_MODES = {})), function (t) { t[t.NPM = 0] = "NPM", t[t.UNPACK = 1] = "UNPACK", t[t.PMA = 2] = "PMA", t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t[t.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA" }(t.ALPHA_MODES || (t.ALPHA_MODES = {})), function (t) { t[t.NO = 0] = "NO", t[t.YES = 1] = "YES", t[t.AUTO = 2] = "AUTO", t[t.BLEND = 0] = "BLEND", t[t.CLEAR = 1] = "CLEAR", t[t.BLIT = 2] = "BLIT" }(t.CLEAR_MODES || (t.CLEAR_MODES = {})), function (t) { t[t.AUTO = 0] = "AUTO", t[t.MANUAL = 1] = "MANUAL" }(t.GC_MODES || (t.GC_MODES = {})), function (t) { t.LOW = "lowp", t.MEDIUM = "mediump", t.HIGH = "highp" }(t.PRECISION || (t.PRECISION = {})), function (t) { t[t.NONE = 0] = "NONE", t[t.SCISSOR = 1] = "SCISSOR", t[t.STENCIL = 2] = "STENCIL", t[t.SPRITE = 3] = "SPRITE" }(t.MASK_TYPES || (t.MASK_TYPES = {})), function (t) { t[t.NONE = 0] = "NONE", t[t.LOW = 2] = "LOW", t[t.MEDIUM = 4] = "MEDIUM", t[t.HIGH = 8] = "HIGH" }(t.MSAA_QUALITY || (t.MSAA_QUALITY = {})), D.RETINA_PREFIX = /@([0-9\.]+)x/, D.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !0; var Lt, Nt = !1, Ft = "5.3.8"; function Bt(t) { var e; if (!Nt) { if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) { var r = ["\n %c %c %c PixiJS " + Ft + " - ✰ " + t + " ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n", "background: #ff66a5; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff66a5; background: #030307; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "background: #ffc3dc; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;"]; (e = window.console).log.apply(e, r) } else window.console && window.console.log("PixiJS " + Ft + " - " + t + " - http://www.pixijs.com/"); Nt = !0 } } function Ut() { return void 0 === Lt && (Lt = function () { var t = { stencil: !0, failIfMajorPerformanceCaveat: D.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT }; try { if (!window.WebGLRenderingContext) return !1; var e = document.createElement("canvas"), r = e.getContext("webgl", t) || e.getContext("experimental-webgl", t), i = !(!r || !r.getContextAttributes().stencil); if (r) { var n = r.getExtension("WEBGL_lose_context"); n && n.loseContext() } return r = null, i } catch (t) { return !1 } }()), Lt } function kt(t, e) { return void 0 === e && (e = []), e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (255 & t) / 255, e } function Xt(t) { var e = t.toString(16); return "#" + (e = "000000".substr(0, 6 - e.length) + e) } function jt(t) { return "string" == typeof t && "#" === t[0] && (t = t.substr(1)), parseInt(t, 16) } function Ht(t) { return (255 * t[0] << 16) + (255 * t[1] << 8) + (255 * t[2] | 0) } var Gt = function () { for (var e = [], r = [], i = 0; i < 32; i++)e[i] = i, r[i] = i; e[t.BLEND_MODES.NORMAL_NPM] = t.BLEND_MODES.NORMAL, e[t.BLEND_MODES.ADD_NPM] = t.BLEND_MODES.ADD, e[t.BLEND_MODES.SCREEN_NPM] = t.BLEND_MODES.SCREEN, r[t.BLEND_MODES.NORMAL] = t.BLEND_MODES.NORMAL_NPM, r[t.BLEND_MODES.ADD] = t.BLEND_MODES.ADD_NPM, r[t.BLEND_MODES.SCREEN] = t.BLEND_MODES.SCREEN_NPM; var n = []; return n.push(r), n.push(e), n }(); function Yt(t, e) { return Gt[e ? 1 : 0][t] } function zt(t, e, r, i) { return r = r || new Float32Array(4), i || void 0 === i ? (r[0] = t[0] * e, r[1] = t[1] * e, r[2] = t[2] * e) : (r[0] = t[0], r[1] = t[1], r[2] = t[2]), r[3] = e, r } function Vt(t, e) { if (1 === e) return (255 * e << 24) + t; if (0 === e) return 0; var r = t >> 16 & 255, i = t >> 8 & 255, n = 255 & t; return (255 * e << 24) + ((r = r * e + .5 | 0) << 16) + ((i = i * e + .5 | 0) << 8) + (n = n * e + .5 | 0) } function Wt(t, e, r, i) { return (r = r || new Float32Array(4))[0] = (t >> 16 & 255) / 255, r[1] = (t >> 8 & 255) / 255, r[2] = (255 & t) / 255, (i || void 0 === i) && (r[0] *= e, r[1] *= e, r[2] *= e), r[3] = e, r } function qt(t, e) { void 0 === e && (e = null); var r = 6 * t; if ((e = e || new Uint16Array(r)).length !== r) throw new Error("Out buffer length is incorrect, got " + e.length + " and expected " + r); for (var i = 0, n = 0; i < r; i += 6, n += 4)e[i + 0] = n + 0, e[i + 1] = n + 1, e[i + 2] = n + 2, e[i + 3] = n + 0, e[i + 4] = n + 2, e[i + 5] = n + 3; return e } function Kt(t) { if (4 === t.BYTES_PER_ELEMENT) return t instanceof Float32Array ? "Float32Array" : t instanceof Uint32Array ? "Uint32Array" : "Int32Array"; if (2 === t.BYTES_PER_ELEMENT) { if (t instanceof Uint16Array) return "Uint16Array" } else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array) return "Uint8Array"; return null } var Zt = { Float32Array: Float32Array, Uint32Array: Uint32Array, Int32Array: Int32Array, Uint8Array: Uint8Array }; function Jt(t) { return t += 0 === t ? 1 : 0, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, (t |= t >>> 16) + 1 } function Qt(t) { return !(t & t - 1 || !t) } function $t(t) { var e = (t > 65535 ? 1 : 0) << 4, r = ((t >>>= e) > 255 ? 1 : 0) << 3; return e |= r, e |= r = ((t >>>= r) > 15 ? 1 : 0) << 2, (e |= r = ((t >>>= r) > 3 ? 1 : 0) << 1) | (t >>>= r) >> 1 } function te(t, e, r) { var i, n = t.length; if (!(e >= n || 0 === r)) { var o = n - (r = e + r > n ? n - e : r); for (i = e; i < o; ++i)t[i] = t[i + r]; t.length = o } } function ee(t) { return 0 === t ? 0 : t < 0 ? -1 : 1 } var re = 0; function ie() { return ++re } var ne = {}; function oe(t, e, r) { if (void 0 === r && (r = 3), !ne[e]) { var i = (new Error).stack; void 0 === i ? console.warn("PixiJS Deprecation Warning: ", e + "\nDeprecated since v" + t) : (i = i.split("\n").splice(r).join("\n"), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", e + "\nDeprecated since v" + t), console.warn(i), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", e + "\nDeprecated since v" + t), console.warn(i))), ne[e] = !0 } } var se = {}, ae = Object.create(null), he = Object.create(null); var ue = function () { function t(t, e, r) { this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.resolution = r || D.RESOLUTION, this.resize(t, e) } return t.prototype.clear = function () { this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height) }, t.prototype.resize = function (t, e) { this.canvas.width = t * this.resolution, this.canvas.height = e * this.resolution }, t.prototype.destroy = function () { this.context = null, this.canvas = null }, Object.defineProperty(t.prototype, "width", { get: function () { return this.canvas.width }, set: function (t) { this.canvas.width = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "height", { get: function () { return this.canvas.height }, set: function (t) { this.canvas.height = t }, enumerable: !1, configurable: !0 }), t }(); function le(t) { var e, r, i, n = t.width, o = t.height, s = t.getContext("2d"), a = s.getImageData(0, 0, n, o).data, h = a.length, u = { top: null, left: null, right: null, bottom: null }, l = null; for (e = 0; e < h; e += 4)0 !== a[e + 3] && (r = e / 4 % n, i = ~~(e / 4 / n), null === u.top && (u.top = i), null === u.left ? u.left = r : r < u.left && (u.left = r), null === u.right ? u.right = r + 1 : u.right < r && (u.right = r + 1), null === u.bottom ? u.bottom = i : u.bottom < i && (u.bottom = i)); return null !== u.top && (n = u.right - u.left, o = u.bottom - u.top + 1, l = s.getImageData(u.left, u.top, n, o)), { height: o, width: n, data: l } } var ce, de = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i; function pe(t, e) { if (void 0 === e && (e = window.location), 0 === t.indexOf("data:")) return ""; e = e || window.location, ce || (ce = document.createElement("a")), ce.href = t; var r = ft(ce.href), i = !r.port && "" === e.port || r.port === e.port; return r.hostname === e.hostname && i && r.protocol === e.protocol ? "" : "anonymous" } function fe(t, e) { var r = D.RETINA_PREFIX.exec(t); return r ? parseFloat(r[1]) : void 0 !== e ? e : 1 } var me, ve = { BaseTextureCache: he, CanvasRenderTarget: ue, DATA_URI: de, ProgramCache: se, TextureCache: ae, clearTextureCache: function () { var t; for (t in ae) delete ae[t]; for (t in he) delete he[t] }, correctBlendMode: Yt, createIndicesForQuads: qt, decomposeDataUri: function (t) { var e = de.exec(t); if (e) return { mediaType: e[1] ? e[1].toLowerCase() : void 0, subType: e[2] ? e[2].toLowerCase() : void 0, charset: e[3] ? e[3].toLowerCase() : void 0, encoding: e[4] ? e[4].toLowerCase() : void 0, data: e[5] } }, deprecation: oe, destroyTextureCache: function () { var t; for (t in ae) ae[t].destroy(); for (t in he) he[t].destroy() }, determineCrossOrigin: pe, getBufferType: Kt, getResolutionOfUrl: fe, hex2rgb: kt, hex2string: Xt, interleaveTypedArrays: function (t, e) { for (var r = 0, i = 0, n = {}, o = 0; o < t.length; o++)i += e[o], r += t[o].length; var s = new ArrayBuffer(4 * r), a = null, h = 0; for (o = 0; o < t.length; o++) { var u = e[o], l = t[o], c = Kt(l); n[c] || (n[c] = new Zt[c](s)), a = n[c]; for (var d = 0; d < l.length; d++)a[(d / u | 0) * i + h + d % u] = l[d]; h += u } return new Float32Array(s) }, isPow2: Qt, isWebGLSupported: Ut, log2: $t, nextPow2: Jt, premultiplyBlendMode: Gt, premultiplyRgba: zt, premultiplyTint: Vt, premultiplyTintToRgba: Wt, removeItems: te, rgb2hex: Ht, sayHello: Bt, sign: ee, skipHello: function () { Nt = !0 }, string2hex: jt, trimCanvas: le, uid: ie, isMobile: M, EventEmitter: C, earcut: R, url: Rt }, ge = 2 * Math.PI, ye = 180 / Math.PI, _e = Math.PI / 180; (me = t.SHAPES || (t.SHAPES = {}))[me.POLY = 0] = "POLY", me[me.RECT = 1] = "RECT", me[me.CIRC = 2] = "CIRC", me[me.ELIP = 3] = "ELIP", me[me.RREC = 4] = "RREC"; var xe = function () { function e(e, r, i, n) { void 0 === e && (e = 0), void 0 === r && (r = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = Number(e), this.y = Number(r), this.width = Number(i), this.height = Number(n), this.type = t.SHAPES.RECT } return Object.defineProperty(e.prototype, "left", { get: function () { return this.x }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "right", { get: function () { return this.x + this.width }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "top", { get: function () { return this.y }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "bottom", { get: function () { return this.y + this.height }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "EMPTY", { get: function () { return new e(0, 0, 0, 0) }, enumerable: !1, configurable: !0 }), e.prototype.clone = function () { return new e(this.x, this.y, this.width, this.height) }, e.prototype.copyFrom = function (t) { return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this }, e.prototype.copyTo = function (t) { return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t }, e.prototype.contains = function (t, e) { return !(this.width <= 0 || this.height <= 0) && (t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height) }, e.prototype.pad = function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.x -= t, this.y -= e, this.width += 2 * t, this.height += 2 * e, this }, e.prototype.fit = function (t) { var e = Math.max(this.x, t.x), r = Math.min(this.x + this.width, t.x + t.width), i = Math.max(this.y, t.y), n = Math.min(this.y + this.height, t.y + t.height); return this.x = e, this.width = Math.max(r - e, 0), this.y = i, this.height = Math.max(n - i, 0), this }, e.prototype.ceil = function (t, e) { void 0 === t && (t = 1), void 0 === e && (e = .001); var r = Math.ceil((this.x + this.width - e) * t) / t, i = Math.ceil((this.y + this.height - e) * t) / t; return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = r - this.x, this.height = i - this.y, this }, e.prototype.enlarge = function (t) { var e = Math.min(this.x, t.x), r = Math.max(this.x + this.width, t.x + t.width), i = Math.min(this.y, t.y), n = Math.max(this.y + this.height, t.y + t.height); return this.x = e, this.width = r - e, this.y = i, this.height = n - i, this }, e }(), be = function () { function e(e, r, i) { void 0 === e && (e = 0), void 0 === r && (r = 0), void 0 === i && (i = 0), this.x = e, this.y = r, this.radius = i, this.type = t.SHAPES.CIRC } return e.prototype.clone = function () { return new e(this.x, this.y, this.radius) }, e.prototype.contains = function (t, e) { if (this.radius <= 0) return !1; var r = this.radius * this.radius, i = this.x - t, n = this.y - e; return (i *= i) + (n *= n) <= r }, e.prototype.getBounds = function () { return new xe(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius) }, e }(), Ee = function () { function e(e, r, i, n) { void 0 === e && (e = 0), void 0 === r && (r = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = e, this.y = r, this.width = i, this.height = n, this.type = t.SHAPES.ELIP } return e.prototype.clone = function () { return new e(this.x, this.y, this.width, this.height) }, e.prototype.contains = function (t, e) { if (this.width <= 0 || this.height <= 0) return !1; var r = (t - this.x) / this.width, i = (e - this.y) / this.height; return (r *= r) + (i *= i) <= 1 }, e.prototype.getBounds = function () { return new xe(this.x - this.width, this.y - this.height, this.width, this.height) }, e }(), Te = function () { function e() { for (var e = arguments, r = [], i = 0; i < arguments.length; i++)r[i] = e[i]; var n = Array.isArray(r[0]) ? r[0] : r; if ("number" != typeof n[0]) { for (var o = [], s = 0, a = n.length; s < a; s++)o.push(n[s].x, n[s].y); n = o } this.points = n, this.type = t.SHAPES.POLY, this.closeStroke = !0 } return e.prototype.clone = function () { var t = new e(this.points.slice()); return t.closeStroke = this.closeStroke, t }, e.prototype.contains = function (t, e) { for (var r = !1, i = this.points.length / 2, n = 0, o = i - 1; n < i; o = n++) { var s = this.points[2 * n], a = this.points[2 * n + 1], h = this.points[2 * o], u = this.points[2 * o + 1]; a > e != u > e && t < (e - a) / (u - a) * (h - s) + s && (r = !r) } return r }, e }(), Se = function () { function e(e, r, i, n, o) { void 0 === e && (e = 0), void 0 === r && (r = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === o && (o = 20), this.x = e, this.y = r, this.width = i, this.height = n, this.radius = o, this.type = t.SHAPES.RREC } return e.prototype.clone = function () { return new e(this.x, this.y, this.width, this.height, this.radius) }, e.prototype.contains = function (t, e) { if (this.width <= 0 || this.height <= 0) return !1; if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) { if (e >= this.y + this.radius && e <= this.y + this.height - this.radius || t >= this.x + this.radius && t <= this.x + this.width - this.radius) return !0; var r = t - (this.x + this.radius), i = e - (this.y + this.radius), n = this.radius * this.radius; if (r * r + i * i <= n) return !0; if ((r = t - (this.x + this.width - this.radius)) * r + i * i <= n) return !0; if (r * r + (i = e - (this.y + this.height - this.radius)) * i <= n) return !0; if ((r = t - (this.x + this.radius)) * r + i * i <= n) return !0 } return !1 }, e }(), we = function () { function t(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e } return t.prototype.clone = function () { return new t(this.x, this.y) }, t.prototype.copyFrom = function (t) { return this.set(t.x, t.y), this }, t.prototype.copyTo = function (t) { return t.set(this.x, this.y), t }, t.prototype.equals = function (t) { return t.x === this.x && t.y === this.y }, t.prototype.set = function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this }, t }(), Pe = function () { function t(t, e, r, i) { void 0 === r && (r = 0), void 0 === i && (i = 0), this._x = r, this._y = i, this.cb = t, this.scope = e } return t.prototype.clone = function (e, r) { return void 0 === e && (e = this.cb), void 0 === r && (r = this.scope), new t(e, r, this._x, this._y) }, t.prototype.set = function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this._x === t && this._y === e || (this._x = t, this._y = e, this.cb.call(this.scope)), this }, t.prototype.copyFrom = function (t) { return this._x === t.x && this._y === t.y || (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this }, t.prototype.copyTo = function (t) { return t.set(this._x, this._y), t }, t.prototype.equals = function (t) { return t.x === this._x && t.y === this._y }, Object.defineProperty(t.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x !== t && (this._x = t, this.cb.call(this.scope)) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y !== t && (this._y = t, this.cb.call(this.scope)) }, enumerable: !1, configurable: !0 }), t }(), Ie = function () { function t(t, e, r, i, n, o) { void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === r && (r = 0), void 0 === i && (i = 1), void 0 === n && (n = 0), void 0 === o && (o = 0), this.array = null, this.a = t, this.b = e, this.c = r, this.d = i, this.tx = n, this.ty = o } return t.prototype.fromArray = function (t) { this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5] }, t.prototype.set = function (t, e, r, i, n, o) { return this.a = t, this.b = e, this.c = r, this.d = i, this.tx = n, this.ty = o, this }, t.prototype.toArray = function (t, e) { this.array || (this.array = new Float32Array(9)); var r = e || this.array; return t ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r }, t.prototype.apply = function (t, e) { e = e || new we; var r = t.x, i = t.y; return e.x = this.a * r + this.c * i + this.tx, e.y = this.b * r + this.d * i + this.ty, e }, t.prototype.applyInverse = function (t, e) { e = e || new we; var r = 1 / (this.a * this.d + this.c * -this.b), i = t.x, n = t.y; return e.x = this.d * r * i + -this.c * r * n + (this.ty * this.c - this.tx * this.d) * r, e.y = this.a * r * n + -this.b * r * i + (-this.ty * this.a + this.tx * this.b) * r, e }, t.prototype.translate = function (t, e) { return this.tx += t, this.ty += e, this }, t.prototype.scale = function (t, e) { return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this }, t.prototype.rotate = function (t) { var e = Math.cos(t), r = Math.sin(t), i = this.a, n = this.c, o = this.tx; return this.a = i * e - this.b * r, this.b = i * r + this.b * e, this.c = n * e - this.d * r, this.d = n * r + this.d * e, this.tx = o * e - this.ty * r, this.ty = o * r + this.ty * e, this }, t.prototype.append = function (t) { var e = this.a, r = this.b, i = this.c, n = this.d; return this.a = t.a * e + t.b * i, this.b = t.a * r + t.b * n, this.c = t.c * e + t.d * i, this.d = t.c * r + t.d * n, this.tx = t.tx * e + t.ty * i + this.tx, this.ty = t.tx * r + t.ty * n + this.ty, this }, t.prototype.setTransform = function (t, e, r, i, n, o, s, a, h) { return this.a = Math.cos(s + h) * n, this.b = Math.sin(s + h) * n, this.c = -Math.sin(s - a) * o, this.d = Math.cos(s - a) * o, this.tx = t - (r * this.a + i * this.c), this.ty = e - (r * this.b + i * this.d), this }, t.prototype.prepend = function (t) { var e = this.tx; if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) { var r = this.a, i = this.c; this.a = r * t.a + this.b * t.c, this.b = r * t.b + this.b * t.d, this.c = i * t.a + this.d * t.c, this.d = i * t.b + this.d * t.d } return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this }, t.prototype.decompose = function (t) { var e = this.a, r = this.b, i = this.c, n = this.d, o = -Math.atan2(-i, n), s = Math.atan2(r, e), a = Math.abs(o + s); return a < 1e-5 || Math.abs(ge - a) < 1e-5 ? (t.rotation = s, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = o, t.skew.y = s), t.scale.x = Math.sqrt(e * e + r * r), t.scale.y = Math.sqrt(i * i + n * n), t.position.x = this.tx, t.position.y = this.ty, t }, t.prototype.invert = function () { var t = this.a, e = this.b, r = this.c, i = this.d, n = this.tx, o = t * i - e * r; return this.a = i / o, this.b = -e / o, this.c = -r / o, this.d = t / o, this.tx = (r * this.ty - i * n) / o, this.ty = -(t * this.ty - e * n) / o, this }, t.prototype.identity = function () { return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this }, t.prototype.clone = function () { var e = new t; return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e }, t.prototype.copyTo = function (t) { return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t }, t.prototype.copyFrom = function (t) { return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this }, Object.defineProperty(t, "IDENTITY", { get: function () { return new t }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "TEMP_MATRIX", { get: function () { return new t }, enumerable: !1, configurable: !0 }), t }(), Ae = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], Oe = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], Me = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], De = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], Ce = [], Re = [], Le = Math.sign; !function () { for (var t = 0; t < 16; t++) { var e = []; Ce.push(e); for (var r = 0; r < 16; r++)for (var i = Le(Ae[t] * Ae[r] + Me[t] * Oe[r]), n = Le(Oe[t] * Ae[r] + De[t] * Oe[r]), o = Le(Ae[t] * Me[r] + Me[t] * De[r]), s = Le(Oe[t] * Me[r] + De[t] * De[r]), a = 0; a < 16; a++)if (Ae[a] === i && Oe[a] === n && Me[a] === o && De[a] === s) { e.push(a); break } } for (t = 0; t < 16; t++) { var h = new Ie; h.set(Ae[t], Oe[t], Me[t], De[t], 0, 0), Re.push(h) } }(); var Ne = { E: 0, SE: 1, S: 2, SW: 3, W: 4, NW: 5, N: 6, NE: 7, MIRROR_VERTICAL: 8, MAIN_DIAGONAL: 10, MIRROR_HORIZONTAL: 12, REVERSE_DIAGONAL: 14, uX: function (t) { return Ae[t] }, uY: function (t) { return Oe[t] }, vX: function (t) { return Me[t] }, vY: function (t) { return De[t] }, inv: function (t) { return 8 & t ? 15 & t : 7 & -t }, add: function (t, e) { return Ce[t][e] }, sub: function (t, e) { return Ce[t][Ne.inv(e)] }, rotate180: function (t) { return 4 ^ t }, isVertical: function (t) { return 2 == (3 & t) }, byDirection: function (t, e) { return 2 * Math.abs(t) <= Math.abs(e) ? e >= 0 ? Ne.S : Ne.N : 2 * Math.abs(e) <= Math.abs(t) ? t > 0 ? Ne.E : Ne.W : e > 0 ? t > 0 ? Ne.SE : Ne.SW : t > 0 ? Ne.NE : Ne.NW }, matrixAppendRotationInv: function (t, e, r, i) { void 0 === r && (r = 0), void 0 === i && (i = 0); var n = Re[Ne.inv(e)]; n.tx = r, n.ty = i, t.append(n) } }, Fe = function () { function t() { this.worldTransform = new Ie, this.localTransform = new Ie, this.position = new Pe(this.onChange, this, 0, 0), this.scale = new Pe(this.onChange, this, 1, 1), this.pivot = new Pe(this.onChange, this, 0, 0), this.skew = new Pe(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0 } return t.prototype.onChange = function () { this._localID++ }, t.prototype.updateSkew = function () { this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++ }, t.prototype.updateLocalTransform = function () { var t = this.localTransform; this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1) }, t.prototype.updateTransform = function (t) { var e = this.localTransform; if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) { var r = t.worldTransform, i = this.worldTransform; i.a = e.a * r.a + e.b * r.c, i.b = e.a * r.b + e.b * r.d, i.c = e.c * r.a + e.d * r.c, i.d = e.c * r.b + e.d * r.d, i.tx = e.tx * r.a + e.ty * r.c + r.tx, i.ty = e.tx * r.b + e.ty * r.d + r.ty, this._parentID = t._worldID, this._worldID++ } }, t.prototype.setFromMatrix = function (t) { t.decompose(this), this._localID++ }, Object.defineProperty(t.prototype, "rotation", { get: function () { return this._rotation }, set: function (t) { this._rotation !== t && (this._rotation = t, this.updateSkew()) }, enumerable: !1, configurable: !0 }), t.IDENTITY = new t, t }(); D.SORTABLE_CHILDREN = !1; var Be = function () { function t() { this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1 } return t.prototype.isEmpty = function () { return this.minX > this.maxX || this.minY > this.maxY }, t.prototype.clear = function () { this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0 }, t.prototype.getRectangle = function (t) { return this.minX > this.maxX || this.minY > this.maxY ? xe.EMPTY : ((t = t || new xe(0, 0, 1, 1)).x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t) }, t.prototype.addPoint = function (t) { this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y) }, t.prototype.addQuad = function (t) { var e = this.minX, r = this.minY, i = this.maxX, n = this.maxY, o = t[0], s = t[1]; e = o < e ? o : e, r = s < r ? s : r, i = o > i ? o : i, n = s > n ? s : n, e = (o = t[2]) < e ? o : e, r = (s = t[3]) < r ? s : r, i = o > i ? o : i, n = s > n ? s : n, e = (o = t[4]) < e ? o : e, r = (s = t[5]) < r ? s : r, i = o > i ? o : i, n = s > n ? s : n, e = (o = t[6]) < e ? o : e, r = (s = t[7]) < r ? s : r, i = o > i ? o : i, n = s > n ? s : n, this.minX = e, this.minY = r, this.maxX = i, this.maxY = n }, t.prototype.addFrame = function (t, e, r, i, n) { this.addFrameMatrix(t.worldTransform, e, r, i, n) }, t.prototype.addFrameMatrix = function (t, e, r, i, n) { var o = t.a, s = t.b, a = t.c, h = t.d, u = t.tx, l = t.ty, c = this.minX, d = this.minY, p = this.maxX, f = this.maxY, m = o * e + a * r + u, v = s * e + h * r + l; c = m < c ? m : c, d = v < d ? v : d, p = m > p ? m : p, f = v > f ? v : f, c = (m = o * i + a * r + u) < c ? m : c, d = (v = s * i + h * r + l) < d ? v : d, p = m > p ? m : p, f = v > f ? v : f, c = (m = o * e + a * n + u) < c ? m : c, d = (v = s * e + h * n + l) < d ? v : d, p = m > p ? m : p, f = v > f ? v : f, c = (m = o * i + a * n + u) < c ? m : c, d = (v = s * i + h * n + l) < d ? v : d, p = m > p ? m : p, f = v > f ? v : f, this.minX = c, this.minY = d, this.maxX = p, this.maxY = f }, t.prototype.addVertexData = function (t, e, r) { for (var i = this.minX, n = this.minY, o = this.maxX, s = this.maxY, a = e; a < r; a += 2) { var h = t[a], u = t[a + 1]; i = h < i ? h : i, n = u < n ? u : n, o = h > o ? h : o, s = u > s ? u : s } this.minX = i, this.minY = n, this.maxX = o, this.maxY = s }, t.prototype.addVertices = function (t, e, r, i) { this.addVerticesMatrix(t.worldTransform, e, r, i) }, t.prototype.addVerticesMatrix = function (t, e, r, i, n, o) { void 0 === n && (n = 0), void 0 === o && (o = n); for (var s = t.a, a = t.b, h = t.c, u = t.d, l = t.tx, c = t.ty, d = this.minX, p = this.minY, f = this.maxX, m = this.maxY, v = r; v < i; v += 2) { var g = e[v], y = e[v + 1], _ = s * g + h * y + l, x = u * y + a * g + c; d = Math.min(d, _ - n), f = Math.max(f, _ + n), p = Math.min(p, x - o), m = Math.max(m, x + o) } this.minX = d, this.minY = p, this.maxX = f, this.maxY = m }, t.prototype.addBounds = function (t) { var e = this.minX, r = this.minY, i = this.maxX, n = this.maxY; this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < r ? t.minY : r, this.maxX = t.maxX > i ? t.maxX : i, this.maxY = t.maxY > n ? t.maxY : n }, t.prototype.addBoundsMask = function (t, e) { var r = t.minX > e.minX ? t.minX : e.minX, i = t.minY > e.minY ? t.minY : e.minY, n = t.maxX < e.maxX ? t.maxX : e.maxX, o = t.maxY < e.maxY ? t.maxY : e.maxY; if (r <= n && i <= o) { var s = this.minX, a = this.minY, h = this.maxX, u = this.maxY; this.minX = r < s ? r : s, this.minY = i < a ? i : a, this.maxX = n > h ? n : h, this.maxY = o > u ? o : u } }, t.prototype.addBoundsMatrix = function (t, e) { this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY) }, t.prototype.addBoundsArea = function (t, e) { var r = t.minX > e.x ? t.minX : e.x, i = t.minY > e.y ? t.minY : e.y, n = t.maxX < e.x + e.width ? t.maxX : e.x + e.width, o = t.maxY < e.y + e.height ? t.maxY : e.y + e.height; if (r <= n && i <= o) { var s = this.minX, a = this.minY, h = this.maxX, u = this.maxY; this.minX = r < s ? r : s, this.minY = i < a ? i : a, this.maxX = n > h ? n : h, this.maxY = o > u ? o : u } }, t.prototype.pad = function (t, e) { void 0 === t && (t = 0), void 0 === e && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e) }, t.prototype.addFramePad = function (t, e, r, i, n, o) { t -= n, e -= o, r += n, i += o, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > r ? this.maxX : r, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > i ? this.maxY : i }, t }(), Ue = function (t, e) { return (Ue = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; function ke(t, e) { function r() { this.constructor = t } Ue(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var Xe = function (t) { function e() { var e = t.call(this) || this; return e.tempDisplayObjectParent = null, e.transform = new Fe, e.alpha = 1, e.visible = !0, e.renderable = !0, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new Be, e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e } return ke(e, t), e.mixin = function (t) { for (var r = Object.keys(t), i = 0; i < r.length; ++i) { var n = r[i]; Object.defineProperty(e.prototype, n, Object.getOwnPropertyDescriptor(t, n)) } }, e.prototype._recursivePostUpdateTransform = function () { this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform) }, e.prototype.updateTransform = function () { this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha }, e.prototype.getBounds = function (t, e) { return t || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), e || (this._boundsRect || (this._boundsRect = new xe), e = this._boundsRect), this._bounds.getRectangle(e) }, e.prototype.getLocalBounds = function (t) { t || (this._localBoundsRect || (this._localBoundsRect = new xe), t = this._localBoundsRect), this._localBounds || (this._localBounds = new Be); var e = this.transform, r = this.parent; this.parent = null, this.transform = this._tempDisplayObjectParent.transform; var i = this._bounds, n = this._boundsID; this._bounds = this._localBounds; var o = this.getBounds(!1, t); return this.parent = r, this.transform = e, this._bounds = i, this._bounds.updateID += this._boundsID - n, o }, e.prototype.toGlobal = function (t, e, r) { return void 0 === r && (r = !1), r || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t, e) }, e.prototype.toLocal = function (t, e, r, i) { return e && (t = e.toGlobal(t, r, i)), i || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t, r) }, e.prototype.setParent = function (t) { if (!t || !t.addChild) throw new Error("setParent: Argument must be a Container"); return t.addChild(this), t }, e.prototype.setTransform = function (t, e, r, i, n, o, s, a, h) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === r && (r = 1), void 0 === i && (i = 1), void 0 === n && (n = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === a && (a = 0), void 0 === h && (h = 0), this.position.x = t, this.position.y = e, this.scale.x = r || 1, this.scale.y = i || 1, this.rotation = n, this.skew.x = o, this.skew.y = s, this.pivot.x = a, this.pivot.y = h, this }, e.prototype.destroy = function (t) { this.parent && this.parent.removeChild(this), this.removeAllListeners(), this.transform = null, this.parent = null, this._bounds = null, this._mask = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this._destroyed = !0 }, Object.defineProperty(e.prototype, "_tempDisplayObjectParent", { get: function () { return null === this.tempDisplayObjectParent && (this.tempDisplayObjectParent = new je), this.tempDisplayObjectParent }, enumerable: !1, configurable: !0 }), e.prototype.enableTempParent = function () { var t = this.parent; return this.parent = this._tempDisplayObjectParent, t }, e.prototype.disableTempParent = function (t) { this.parent = t }, Object.defineProperty(e.prototype, "x", { get: function () { return this.position.x }, set: function (t) { this.transform.position.x = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "y", { get: function () { return this.position.y }, set: function (t) { this.transform.position.y = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "worldTransform", { get: function () { return this.transform.worldTransform }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "localTransform", { get: function () { return this.transform.localTransform }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "position", { get: function () { return this.transform.position }, set: function (t) { this.transform.position.copyFrom(t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "scale", { get: function () { return this.transform.scale }, set: function (t) { this.transform.scale.copyFrom(t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "pivot", { get: function () { return this.transform.pivot }, set: function (t) { this.transform.pivot.copyFrom(t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "skew", { get: function () { return this.transform.skew }, set: function (t) { this.transform.skew.copyFrom(t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "rotation", { get: function () { return this.transform.rotation }, set: function (t) { this.transform.rotation = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "angle", { get: function () { return this.transform.rotation * ye }, set: function (t) { this.transform.rotation = t * _e }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "zIndex", { get: function () { return this._zIndex }, set: function (t) { this._zIndex = t, this.parent && (this.parent.sortDirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "worldVisible", { get: function () { var t = this; do { if (!t.visible) return !1; t = t.parent } while (t); return !0 }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "mask", { get: function () { return this._mask }, set: function (t) { var e; this._mask && ((e = this._mask.maskObject || this._mask).renderable = !0, e.isMask = !1); (this._mask = t, this._mask) && ((e = this._mask.maskObject || this._mask).renderable = !1, e.isMask = !0) }, enumerable: !1, configurable: !0 }), e }(C), je = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.sortDirty = null, e } return ke(e, t), e }(Xe); function He(t, e) { return t.zIndex === e.zIndex ? t._lastSortedIndex - e._lastSortedIndex : t.zIndex - e.zIndex } Xe.prototype.displayObjectUpdateTransform = Xe.prototype.updateTransform; var Ge = function (t) { function e() { var e = t.call(this) || this; return e.children = [], e.sortableChildren = D.SORTABLE_CHILDREN, e.sortDirty = !1, e } return ke(e, t), e.prototype.onChildrenChange = function (t) { }, e.prototype.addChild = function () { for (var t = arguments, e = [], r = 0; r < arguments.length; r++)e[r] = t[r]; if (e.length > 1) for (var i = 0; i < e.length; i++)this.addChild(e[i]); else { var n = e[0]; n.parent && n.parent.removeChild(n), n.parent = this, this.sortDirty = !0, n.transform._parentID = -1, this.children.push(n), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", n, this, this.children.length - 1), n.emit("added", this) } return e[0] }, e.prototype.addChildAt = function (t, e) { if (e < 0 || e > this.children.length) throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length); return t.parent && t.parent.removeChild(t), t.parent = this, this.sortDirty = !0, t.transform._parentID = -1, this.children.splice(e, 0, t), this._boundsID++, this.onChildrenChange(e), t.emit("added", this), this.emit("childAdded", t, this, e), t }, e.prototype.swapChildren = function (t, e) { if (t !== e) { var r = this.getChildIndex(t), i = this.getChildIndex(e); this.children[r] = e, this.children[i] = t, this.onChildrenChange(r < i ? r : i) } }, e.prototype.getChildIndex = function (t) { var e = this.children.indexOf(t); if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller"); return e }, e.prototype.setChildIndex = function (t, e) { if (e < 0 || e >= this.children.length) throw new Error("The index " + e + " supplied is out of bounds " + this.children.length); var r = this.getChildIndex(t); te(this.children, r, 1), this.children.splice(e, 0, t), this.onChildrenChange(e) }, e.prototype.getChildAt = function (t) { if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Index (" + t + ") does not exist."); return this.children[t] }, e.prototype.removeChild = function () { for (var t = arguments, e = [], r = 0; r < arguments.length; r++)e[r] = t[r]; if (e.length > 1) for (var i = 0; i < e.length; i++)this.removeChild(e[i]); else { var n = e[0], o = this.children.indexOf(n); if (-1 === o) return null; n.parent = null, n.transform._parentID = -1, te(this.children, o, 1), this._boundsID++, this.onChildrenChange(o), n.emit("removed", this), this.emit("childRemoved", n, this, o) } return e[0] }, e.prototype.removeChildAt = function (t) { var e = this.getChildAt(t); return e.parent = null, e.transform._parentID = -1, te(this.children, t, 1), this._boundsID++, this.onChildrenChange(t), e.emit("removed", this), this.emit("childRemoved", e, this, t), e }, e.prototype.removeChildren = function (t, e) { void 0 === t && (t = 0), void 0 === e && (e = this.children.length); var r, i = t, n = e - i; if (n > 0 && n <= e) { r = this.children.splice(i, n); for (var o = 0; o < r.length; ++o)r[o].parent = null, r[o].transform && (r[o].transform._parentID = -1); this._boundsID++, this.onChildrenChange(t); for (o = 0; o < r.length; ++o)r[o].emit("removed", this), this.emit("childRemoved", r[o], this, o); return r } if (0 === n && 0 === this.children.length) return []; throw new RangeError("removeChildren: numeric values are outside the acceptable range.") }, e.prototype.sortChildren = function () { for (var t = !1, e = 0, r = this.children.length; e < r; ++e) { var i = this.children[e]; i._lastSortedIndex = e, t || 0 === i.zIndex || (t = !0) } t && this.children.length > 1 && this.children.sort(He), this.sortDirty = !1 }, e.prototype.updateTransform = function () { this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha; for (var t = 0, e = this.children.length; t < e; ++t) { var r = this.children[t]; r.visible && r.updateTransform() } }, e.prototype.calculateBounds = function () { this._bounds.clear(), this._calculateBounds(); for (var t = 0; t < this.children.length; t++) { var e = this.children[t]; if (e.visible && e.renderable) if (e.calculateBounds(), e._mask) { var r = e._mask.maskObject || e._mask; r.calculateBounds(), this._bounds.addBoundsMask(e._bounds, r._bounds) } else e.filterArea ? this._bounds.addBoundsArea(e._bounds, e.filterArea) : this._bounds.addBounds(e._bounds) } this._bounds.updateID = this._boundsID }, e.prototype.getLocalBounds = function (e, r) { void 0 === r && (r = !1); var i = t.prototype.getLocalBounds.call(this, e); if (!r) for (var n = 0, o = this.children.length; n < o; ++n) { var s = this.children[n]; s.visible && s.updateTransform() } return i }, e.prototype._calculateBounds = function () { }, e.prototype.render = function (t) { if (this.visible && !(this.worldAlpha <= 0) && this.renderable) if (this._mask || this.filters && this.filters.length) this.renderAdvanced(t); else { this._render(t); for (var e = 0, r = this.children.length; e < r; ++e)this.children[e].render(t) } }, e.prototype.renderAdvanced = function (t) { t.batch.flush(); var e = this.filters, r = this._mask; if (e) { this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0; for (var i = 0; i < e.length; i++)e[i].enabled && this._enabledFilters.push(e[i]); this._enabledFilters.length && t.filter.push(this, this._enabledFilters) } r && t.mask.push(this, this._mask), this._render(t); i = 0; for (var n = this.children.length; i < n; i++)this.children[i].render(t); t.batch.flush(), r && t.mask.pop(this), e && this._enabledFilters && this._enabledFilters.length && t.filter.pop() }, e.prototype._render = function (t) { }, e.prototype.destroy = function (e) { t.prototype.destroy.call(this), this.sortDirty = !1; var r = "boolean" == typeof e ? e : e && e.children, i = this.removeChildren(0, this.children.length); if (r) for (var n = 0; n < i.length; ++n)i[n].destroy(e) }, Object.defineProperty(e.prototype, "width", { get: function () { return this.scale.x * this.getLocalBounds().width }, set: function (t) { var e = this.getLocalBounds().width; this.scale.x = 0 !== e ? t / e : 1, this._width = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "height", { get: function () { return this.scale.y * this.getLocalBounds().height }, set: function (t) { var e = this.getLocalBounds().height; this.scale.y = 0 !== e ? t / e : 1, this._height = t }, enumerable: !1, configurable: !0 }), e }(Xe); Ge.prototype.containerUpdateTransform = Ge.prototype.updateTransform; var Ye = { accessible: !1, accessibleTitle: null, accessibleHint: null, tabIndex: 0, _accessibleActive: !1, _accessibleDiv: null, accessibleType: "button", accessiblePointerEvents: "auto", accessibleChildren: !0, renderId: -1 }; Xe.mixin(Ye); var ze, Ve = 100, We = 0, qe = 0, Ke = 2, Ze = function () { function t(t) { this._hookDiv = null, (M.tablet || M.phone) && this.createTouchHook(); var e = document.createElement("div"); e.style.width = Ve + "px", e.style.height = Ve + "px", e.style.position = "absolute", e.style.top = We + "px", e.style.left = qe + "px", e.style.zIndex = Ke.toString(), this.div = e, this.pool = [], this.renderId = 0, this.debug = !1, this.renderer = t, this.children = [], this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this._isActive = !1, this._isMobileAccessibility = !1, this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, window.addEventListener("keydown", this._onKeyDown, !1) } return Object.defineProperty(t.prototype, "isActive", { get: function () { return this._isActive }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "isMobileAccessibility", { get: function () { return this._isMobileAccessibility }, enumerable: !1, configurable: !0 }), t.prototype.createTouchHook = function () { var t = this, e = document.createElement("button"); e.style.width = "1px", e.style.height = "1px", e.style.position = "absolute", e.style.top = "-1000px", e.style.left = "-1000px", e.style.zIndex = 2..toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessability for this content", e.addEventListener("focus", function () { t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook() }), document.body.appendChild(e), this._hookDiv = e }, t.prototype.destroyTouchHook = function () { this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null) }, t.prototype.activate = function () { this._isActive || (this._isActive = !0, window.document.addEventListener("mousemove", this._onMouseMove, !0), window.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), this.renderer.view.parentNode && this.renderer.view.parentNode.appendChild(this.div)) }, t.prototype.deactivate = function () { this._isActive && !this._isMobileAccessibility && (this._isActive = !1, window.document.removeEventListener("mousemove", this._onMouseMove, !0), window.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), this.div.parentNode && this.div.parentNode.removeChild(this.div)) }, t.prototype.updateAccessibleObjects = function (t) { if (t.visible && t.accessibleChildren) { t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId); for (var e = t.children, r = 0; r < e.length; r++)this.updateAccessibleObjects(e[r]) } }, t.prototype.update = function () { var t = performance.now(); if (!(M.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, this.renderer.renderingToScreen)) { this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered); var e = this.renderer.view.getBoundingClientRect(), r = this.renderer.resolution, i = e.width / this.renderer.width * r, n = e.height / this.renderer.height * r, o = this.div; o.style.left = e.left + "px", o.style.top = e.top + "px", o.style.width = this.renderer.width + "px", o.style.height = this.renderer.height + "px"; for (var s = 0; s < this.children.length; s++) { var a = this.children[s]; if (a.renderId !== this.renderId) a._accessibleActive = !1, te(this.children, s, 1), this.div.removeChild(a._accessibleDiv), this.pool.push(a._accessibleDiv), a._accessibleDiv = null, s--; else { o = a._accessibleDiv; var h = a.hitArea, u = a.worldTransform; a.hitArea ? (o.style.left = (u.tx + h.x * u.a) * i + "px", o.style.top = (u.ty + h.y * u.d) * n + "px", o.style.width = h.width * u.a * i + "px", o.style.height = h.height * u.d * n + "px") : (h = a.getBounds(), this.capHitArea(h), o.style.left = h.x * i + "px", o.style.top = h.y * n + "px", o.style.width = h.width * i + "px", o.style.height = h.height * n + "px", o.title !== a.accessibleTitle && null !== a.accessibleTitle && (o.title = a.accessibleTitle), o.getAttribute("aria-label") !== a.accessibleHint && null !== a.accessibleHint && o.setAttribute("aria-label", a.accessibleHint)), a.accessibleTitle === o.title && a.tabIndex === o.tabIndex || (o.title = a.accessibleTitle, o.tabIndex = a.tabIndex, this.debug && this.updateDebugHTML(o)) } } this.renderId++ } }, t.prototype.updateDebugHTML = function (t) { t.innerHTML = "type: " + t.type + "</br> title : " + t.title + "</br> tabIndex: " + t.tabIndex }, t.prototype.capHitArea = function (t) { t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0), t.x + t.width > this.renderer.width && (t.width = this.renderer.width - t.x), t.y + t.height > this.renderer.height && (t.height = this.renderer.height - t.y) }, t.prototype.addChild = function (t) { var e = this.pool.pop(); e || ((e = document.createElement("button")).style.width = Ve + "px", e.style.height = Ve + "px", e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = Ke.toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && null !== t.accessibleTitle ? e.title = t.accessibleTitle : t.accessibleHint && null !== t.accessibleHint || (e.title = "displayObject " + t.tabIndex), t.accessibleHint && null !== t.accessibleHint && e.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex }, t.prototype._onClick = function (t) { var e = this.renderer.plugins.interaction; e.dispatchEvent(t.target.displayObject, "click", e.eventData), e.dispatchEvent(t.target.displayObject, "pointertap", e.eventData), e.dispatchEvent(t.target.displayObject, "tap", e.eventData) }, t.prototype._onFocus = function (t) { t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"); var e = this.renderer.plugins.interaction; e.dispatchEvent(t.target.displayObject, "mouseover", e.eventData) }, t.prototype._onFocusOut = function (t) { t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"); var e = this.renderer.plugins.interaction; e.dispatchEvent(t.target.displayObject, "mouseout", e.eventData) }, t.prototype._onKeyDown = function (t) { 9 === t.keyCode && this.activate() }, t.prototype._onMouseMove = function (t) { 0 === t.movementX && 0 === t.movementY || this.deactivate() }, t.prototype.destroy = function () { this.destroyTouchHook(), this.div = null, window.document.removeEventListener("mousemove", this._onMouseMove, !0), window.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null }, t }(); D.TARGET_FPMS = .06, (ze = t.UPDATE_PRIORITY || (t.UPDATE_PRIORITY = {}))[ze.INTERACTION = 50] = "INTERACTION", ze[ze.HIGH = 25] = "HIGH", ze[ze.NORMAL = 0] = "NORMAL", ze[ze.LOW = -25] = "LOW", ze[ze.UTILITY = -50] = "UTILITY"; var Je = function () { function t(t, e, r, i) { void 0 === e && (e = null), void 0 === r && (r = 0), void 0 === i && (i = !1), this.fn = t, this.context = e, this.priority = r, this.once = i, this.next = null, this.previous = null, this._destroyed = !1 } return t.prototype.match = function (t, e) { return void 0 === e && (e = null), this.fn === t && this.context === e }, t.prototype.emit = function (t) { this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t)); var e = this.next; return this.once && this.destroy(!0), this._destroyed && (this.next = null), e }, t.prototype.connect = function (t) { this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this }, t.prototype.destroy = function (t) { void 0 === t && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous); var e = this.next; return this.next = t ? null : e, this.previous = null, e }, t }(), Qe = function () { function e() { var t = this; this._head = new Je(null, null, 1 / 0), this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this.autoStart = !1, this.deltaTime = 1, this.deltaMS = 1 / D.TARGET_FPMS, this.elapsedMS = 1 / D.TARGET_FPMS, this.lastTime = -1, this.speed = 1, this.started = !1, this._protected = !1, this._lastFrame = -1, this._tick = function (e) { t._requestId = null, t.started && (t.update(e), t.started && null === t._requestId && t._head.next && (t._requestId = requestAnimationFrame(t._tick))) } } return e.prototype._requestIfNeeded = function () { null === this._requestId && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick)) }, e.prototype._cancelIfNeeded = function () { null !== this._requestId && (cancelAnimationFrame(this._requestId), this._requestId = null) }, e.prototype._startIfPossible = function () { this.started ? this._requestIfNeeded() : this.autoStart && this.start() }, e.prototype.add = function (e, r, i) { return void 0 === i && (i = t.UPDATE_PRIORITY.NORMAL), this._addListener(new Je(e, r, i)) }, e.prototype.addOnce = function (e, r, i) { return void 0 === i && (i = t.UPDATE_PRIORITY.NORMAL), this._addListener(new Je(e, r, i, !0)) }, e.prototype._addListener = function (t) { var e = this._head.next, r = this._head; if (e) { for (; e;) { if (t.priority > e.priority) { t.connect(r); break } r = e, e = e.next } t.previous || t.connect(r) } else t.connect(r); return this._startIfPossible(), this }, e.prototype.remove = function (t, e) { for (var r = this._head.next; r;)r = r.match(t, e) ? r.destroy() : r.next; return this._head.next || this._cancelIfNeeded(), this }, Object.defineProperty(e.prototype, "count", { get: function () { if (!this._head) return 0; for (var t = 0, e = this._head; e = e.next;)t++; return t }, enumerable: !1, configurable: !0 }), e.prototype.start = function () { this.started || (this.started = !0, this._requestIfNeeded()) }, e.prototype.stop = function () { this.started && (this.started = !1, this._cancelIfNeeded()) }, e.prototype.destroy = function () { if (!this._protected) { this.stop(); for (var t = this._head.next; t;)t = t.destroy(!0); this._head.destroy(), this._head = null } }, e.prototype.update = function (t) { var e; if (void 0 === t && (t = performance.now()), t > this.lastTime) { if ((e = this.elapsedMS = t - this.lastTime) > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) { var r = t - this._lastFrame | 0; if (r < this._minElapsedMS) return; this._lastFrame = t - r % this._minElapsedMS } this.deltaMS = e, this.deltaTime = this.deltaMS * D.TARGET_FPMS; for (var i = this._head, n = i.next; n;)n = n.emit(this.deltaTime); i.next || this._cancelIfNeeded() } else this.deltaTime = this.deltaMS = this.elapsedMS = 0; this.lastTime = t }, Object.defineProperty(e.prototype, "FPS", { get: function () { return 1e3 / this.elapsedMS }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "minFPS", { get: function () { return 1e3 / this._maxElapsedMS }, set: function (t) { var e = Math.min(this.maxFPS, t), r = Math.min(Math.max(0, e) / 1e3, D.TARGET_FPMS); this._maxElapsedMS = 1 / r }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "maxFPS", { get: function () { return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0 }, set: function (t) { if (0 === t) this._minElapsedMS = 0; else { var e = Math.max(this.minFPS, t); this._minElapsedMS = 1 / (e / 1e3) } }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "shared", { get: function () { if (!e._shared) { var t = e._shared = new e; t.autoStart = !0, t._protected = !0 } return e._shared }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "system", { get: function () { if (!e._system) { var t = e._system = new e; t.autoStart = !0, t._protected = !0 } return e._system }, enumerable: !1, configurable: !0 }), e }(), $e = function () { function e() { } return e.init = function (e) { var r = this; e = Object.assign({ autoStart: !0, sharedTicker: !1 }, e), Object.defineProperty(this, "ticker", { set: function (e) { this._ticker && this._ticker.remove(this.render, this), this._ticker = e, e && e.add(this.render, this, t.UPDATE_PRIORITY.LOW) }, get: function () { return this._ticker } }), this.stop = function () { r._ticker.stop() }, this.start = function () { r._ticker.start() }, this._ticker = null, this.ticker = e.sharedTicker ? Qe.shared : new Qe, e.autoStart && this.start() }, e.destroy = function () { if (this._ticker) { var t = this._ticker; this.ticker = null, t.destroy() } }, e }(), tr = function () { function t() { this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new we, this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0 } return Object.defineProperty(t.prototype, "pointerId", { get: function () { return this.identifier }, enumerable: !1, configurable: !0 }), t.prototype.getLocalPosition = function (t, e, r) { return t.worldTransform.applyInverse(r || this.global, e) }, t.prototype.copyEvent = function (t) { "isPrimary" in t && t.isPrimary && (this.isPrimary = !0), this.button = "button" in t && t.button; var e = "buttons" in t && t.buttons; this.buttons = Number.isInteger(e) ? e : "which" in t && t.which, this.width = "width" in t && t.width, this.height = "height" in t && t.height, this.tiltX = "tiltX" in t && t.tiltX, this.tiltY = "tiltY" in t && t.tiltY, this.pointerType = "pointerType" in t && t.pointerType, this.pressure = "pressure" in t && t.pressure, this.rotationAngle = "rotationAngle" in t && t.rotationAngle, this.twist = "twist" in t && t.twist || 0, this.tangentialPressure = "tangentialPressure" in t && t.tangentialPressure || 0 }, t.prototype.reset = function () { this.isPrimary = !1 }, t }(), er = function (t, e) { return (er = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; var rr = function () { function t() { this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null } return t.prototype.stopPropagation = function () { this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget }, t.prototype.reset = function () { this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null }, t }(), ir = function () { function t(e) { this._pointerId = e, this._flags = t.FLAGS.NONE } return t.prototype._doSet = function (t, e) { this._flags = e ? this._flags | t : this._flags & ~t }, Object.defineProperty(t.prototype, "pointerId", { get: function () { return this._pointerId }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "flags", { get: function () { return this._flags }, set: function (t) { this._flags = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "none", { get: function () { return this._flags === t.FLAGS.NONE }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "over", { get: function () { return 0 != (this._flags & t.FLAGS.OVER) }, set: function (e) { this._doSet(t.FLAGS.OVER, e) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "rightDown", { get: function () { return 0 != (this._flags & t.FLAGS.RIGHT_DOWN) }, set: function (e) { this._doSet(t.FLAGS.RIGHT_DOWN, e) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "leftDown", { get: function () { return 0 != (this._flags & t.FLAGS.LEFT_DOWN) }, set: function (e) { this._doSet(t.FLAGS.LEFT_DOWN, e) }, enumerable: !1, configurable: !0 }), t.FLAGS = Object.freeze({ NONE: 0, OVER: 1, LEFT_DOWN: 2, RIGHT_DOWN: 4 }), t }(), nr = function () { function t() { this._tempPoint = new we } return t.prototype.recursiveFindHit = function (t, e, r, i, n) { if (!e || !e.visible) return !1; var o = t.data.global, s = !1, a = n = e.interactive || n, h = !0; if (e.hitArea ? (i && (e.worldTransform.applyInverse(o, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? s = !0 : (i = !1, h = !1)), a = !1) : e._mask && i && (e._mask.containsPoint && e._mask.containsPoint(o) || (i = !1)), h && e.interactiveChildren && e.children) for (var u = e.children, l = u.length - 1; l >= 0; l--) { var c = u[l], d = this.recursiveFindHit(t, c, r, i, a); if (d) { if (!c.parent) continue; a = !1, d && (t.target && (i = !1), s = !0) } } return n && (i && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(o) && (s = !0), e.interactive && (s && !t.target && (t.target = e), r && r(t, e, !!s))), s }, t.prototype.findHit = function (t, e, r, i) { this.recursiveFindHit(t, e, r, i, !1) }, t }(), or = { interactive: !1, interactiveChildren: !0, hitArea: null, get buttonMode() { return "pointer" === this.cursor }, set buttonMode(t) { t ? this.cursor = "pointer" : "pointer" === this.cursor && (this.cursor = null) }, cursor: null, get trackedPointers() { return void 0 === this._trackedPointers && (this._trackedPointers = {}), this._trackedPointers }, _trackedPointers: void 0 }; Xe.mixin(or); var sr = 1, ar = { target: null, data: { global: null } }, hr = function (e) { function r(t, r) { var i = e.call(this) || this; return r = r || {}, i.renderer = t, i.autoPreventDefault = void 0 === r.autoPreventDefault || r.autoPreventDefault, i.interactionFrequency = r.interactionFrequency || 10, i.mouse = new tr, i.mouse.identifier = sr, i.mouse.global.set(-999999), i.activeInteractionData = {}, i.activeInteractionData[sr] = i.mouse, i.interactionDataPool = [], i.eventData = new rr, i.interactionDOMElement = null, i.moveWhenInside = !1, i.eventsAdded = !1, i.tickerAdded = !1, i.mouseOverRenderer = !1, i.supportsTouchEvents = "ontouchstart" in window, i.supportsPointerEvents = !!window.PointerEvent, i.onPointerUp = i.onPointerUp.bind(i), i.processPointerUp = i.processPointerUp.bind(i), i.onPointerCancel = i.onPointerCancel.bind(i), i.processPointerCancel = i.processPointerCancel.bind(i), i.onPointerDown = i.onPointerDown.bind(i), i.processPointerDown = i.processPointerDown.bind(i), i.onPointerMove = i.onPointerMove.bind(i), i.processPointerMove = i.processPointerMove.bind(i), i.onPointerOut = i.onPointerOut.bind(i), i.processPointerOverOut = i.processPointerOverOut.bind(i), i.onPointerOver = i.onPointerOver.bind(i), i.cursorStyles = { default: "inherit", pointer: "pointer" }, i.currentCursorMode = null, i.cursor = null, i.resolution = 1, i.delayedEvents = [], i.search = new nr, i._tempDisplayObject = new je, i._useSystemTicker = void 0 === r.useSystemTicker || r.useSystemTicker, i.setTargetElement(i.renderer.view, i.renderer.resolution), i } return function (t, e) { function r() { this.constructor = t } er(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) }(r, e), Object.defineProperty(r.prototype, "useSystemTicker", { get: function () { return this._useSystemTicker }, set: function (t) { this._useSystemTicker = t, t ? this.addTickerListener() : this.removeTickerListener() }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "lastObjectRendered", { get: function () { return this.renderer._lastObjectRendered || this._tempDisplayObject }, enumerable: !1, configurable: !0 }), r.prototype.hitTest = function (t, e) { return ar.target = null, ar.data.global = t, e || (e = this.lastObjectRendered), this.processInteractive(ar, e, null, !0), ar.target }, r.prototype.setTargetElement = function (t, e) { void 0 === e && (e = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = t, this.resolution = e, this.addEvents(), this.addTickerListener() }, r.prototype.addTickerListener = function () { !this.tickerAdded && this.interactionDOMElement && this._useSystemTicker && (Qe.system.add(this.tickerUpdate, this, t.UPDATE_PRIORITY.INTERACTION), this.tickerAdded = !0) }, r.prototype.removeTickerListener = function () { this.tickerAdded && (Qe.system.remove(this.tickerUpdate, this), this.tickerAdded = !1) }, r.prototype.addEvents = function () { if (!this.eventsAdded && this.interactionDOMElement) { var t = this.interactionDOMElement.style; window.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none"), this.supportsPointerEvents ? (window.document.addEventListener("pointermove", this.onPointerMove, !0), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, !0), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, !0), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, !0), window.addEventListener("pointercancel", this.onPointerCancel, !0), window.addEventListener("pointerup", this.onPointerUp, !0)) : (window.document.addEventListener("mousemove", this.onPointerMove, !0), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, !0), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, !0), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, !0), window.addEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, !0), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, !0), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, !0), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, !0)), this.eventsAdded = !0 } }, r.prototype.removeEvents = function () { if (this.eventsAdded && this.interactionDOMElement) { var t = this.interactionDOMElement.style; window.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = ""), this.supportsPointerEvents ? (window.document.removeEventListener("pointermove", this.onPointerMove, !0), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, !0), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, !0), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, !0), window.removeEventListener("pointercancel", this.onPointerCancel, !0), window.removeEventListener("pointerup", this.onPointerUp, !0)) : (window.document.removeEventListener("mousemove", this.onPointerMove, !0), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, !0), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, !0), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, !0), window.removeEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, !0), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, !0), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, !0), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, !0)), this.interactionDOMElement = null, this.eventsAdded = !1 } }, r.prototype.tickerUpdate = function (t) { this._deltaTime += t, this._deltaTime < this.interactionFrequency || (this._deltaTime = 0, this.update()) }, r.prototype.update = function () { if (this.interactionDOMElement) if (this._didMove) this._didMove = !1; else { for (var t in this.cursor = null, this.activeInteractionData) if (this.activeInteractionData.hasOwnProperty(t)) { var e = this.activeInteractionData[t]; if (e.originalEvent && "touch" !== e.pointerType) { var r = this.configureInteractionEventForDOMEvent(this.eventData, e.originalEvent, e); this.processInteractive(r, this.lastObjectRendered, this.processPointerOverOut, !0) } } this.setCursorMode(this.cursor) } }, r.prototype.setCursorMode = function (t) { if (t = t || "default", this.currentCursorMode !== t) { this.currentCursorMode = t; var e = this.cursorStyles[t]; if (e) switch (typeof e) { case "string": this.interactionDOMElement.style.cursor = e; break; case "function": e(t); break; case "object": Object.assign(this.interactionDOMElement.style, e) } else "string" != typeof t || Object.prototype.hasOwnProperty.call(this.cursorStyles, t) || (this.interactionDOMElement.style.cursor = t) } }, r.prototype.dispatchEvent = function (t, e, r) { r.stopPropagationHint && t !== r.stopsPropagatingAt || (r.currentTarget = t, r.type = e, t.emit(e, r), t[e] && t[e](r)) }, r.prototype.delayDispatchEvent = function (t, e, r) { this.delayedEvents.push({ displayObject: t, eventString: e, eventData: r }) }, r.prototype.mapPositionToPoint = function (t, e, r) { var i; i = this.interactionDOMElement.parentElement ? this.interactionDOMElement.getBoundingClientRect() : { x: 0, y: 0, width: 0, height: 0 }; var n = 1 / this.resolution; t.x = (e - i.left) * (this.interactionDOMElement.width / i.width) * n, t.y = (r - i.top) * (this.interactionDOMElement.height / i.height) * n }, r.prototype.processInteractive = function (t, e, r, i) { var n = this.search.findHit(t, e, r, i), o = this.delayedEvents; if (!o.length) return n; t.stopPropagationHint = !1; var s = o.length; this.delayedEvents = []; for (var a = 0; a < s; a++) { var h = o[a], u = h.displayObject, l = h.eventString, c = h.eventData; c.stopsPropagatingAt === u && (c.stopPropagationHint = !0), this.dispatchEvent(u, l, c) } return n }, r.prototype.onPointerDown = function (t) { if (!this.supportsTouchEvents || "touch" !== t.pointerType) { var e = this.normalizeToPointerData(t); if (this.autoPreventDefault && e[0].isNormalized) (t.cancelable || !("cancelable" in t)) && t.preventDefault(); for (var r = e.length, i = 0; i < r; i++) { var n = e[i], o = this.getInteractionDataForPointerId(n), s = this.configureInteractionEventForDOMEvent(this.eventData, n, o); if (s.data.originalEvent = t, this.processInteractive(s, this.lastObjectRendered, this.processPointerDown, !0), this.emit("pointerdown", s), "touch" === n.pointerType) this.emit("touchstart", s); else if ("mouse" === n.pointerType || "pen" === n.pointerType) { var a = 2 === n.button; this.emit(a ? "rightdown" : "mousedown", this.eventData) } } } }, r.prototype.processPointerDown = function (t, e, r) { var i = t.data, n = t.data.identifier; if (r) if (e.trackedPointers[n] || (e.trackedPointers[n] = new ir(n)), this.dispatchEvent(e, "pointerdown", t), "touch" === i.pointerType) this.dispatchEvent(e, "touchstart", t); else if ("mouse" === i.pointerType || "pen" === i.pointerType) { var o = 2 === i.button; o ? e.trackedPointers[n].rightDown = !0 : e.trackedPointers[n].leftDown = !0, this.dispatchEvent(e, o ? "rightdown" : "mousedown", t) } }, r.prototype.onPointerComplete = function (t, e, r) { for (var i = this.normalizeToPointerData(t), n = i.length, o = t.target !== this.interactionDOMElement ? "outside" : "", s = 0; s < n; s++) { var a = i[s], h = this.getInteractionDataForPointerId(a), u = this.configureInteractionEventForDOMEvent(this.eventData, a, h); if (u.data.originalEvent = t, this.processInteractive(u, this.lastObjectRendered, r, e || !o), this.emit(e ? "pointercancel" : "pointerup" + o, u), "mouse" === a.pointerType || "pen" === a.pointerType) { var l = 2 === a.button; this.emit(l ? "rightup" + o : "mouseup" + o, u) } else "touch" === a.pointerType && (this.emit(e ? "touchcancel" : "touchend" + o, u), this.releaseInteractionDataForPointerId(a.pointerId)) } }, r.prototype.onPointerCancel = function (t) { this.supportsTouchEvents && "touch" === t.pointerType || this.onPointerComplete(t, !0, this.processPointerCancel) }, r.prototype.processPointerCancel = function (t, e) { var r = t.data, i = t.data.identifier; void 0 !== e.trackedPointers[i] && (delete e.trackedPointers[i], this.dispatchEvent(e, "pointercancel", t), "touch" === r.pointerType && this.dispatchEvent(e, "touchcancel", t)) }, r.prototype.onPointerUp = function (t) { this.supportsTouchEvents && "touch" === t.pointerType || this.onPointerComplete(t, !1, this.processPointerUp) }, r.prototype.processPointerUp = function (t, e, r) { var i = t.data, n = t.data.identifier, o = e.trackedPointers[n], s = "touch" === i.pointerType, a = "mouse" === i.pointerType || "pen" === i.pointerType, h = !1; if (a) { var u = 2 === i.button, l = ir.FLAGS, c = u ? l.RIGHT_DOWN : l.LEFT_DOWN, d = void 0 !== o && o.flags & c; r ? (this.dispatchEvent(e, u ? "rightup" : "mouseup", t), d && (this.dispatchEvent(e, u ? "rightclick" : "click", t), h = !0)) : d && this.dispatchEvent(e, u ? "rightupoutside" : "mouseupoutside", t), o && (u ? o.rightDown = !1 : o.leftDown = !1) } r ? (this.dispatchEvent(e, "pointerup", t), s && this.dispatchEvent(e, "touchend", t), o && (a && !h || this.dispatchEvent(e, "pointertap", t), s && (this.dispatchEvent(e, "tap", t), o.over = !1))) : o && (this.dispatchEvent(e, "pointerupoutside", t), s && this.dispatchEvent(e, "touchendoutside", t)), o && o.none && delete e.trackedPointers[n] }, r.prototype.onPointerMove = function (t) { if (!this.supportsTouchEvents || "touch" !== t.pointerType) { var e = this.normalizeToPointerData(t); "mouse" !== e[0].pointerType && "pen" !== e[0].pointerType || (this._didMove = !0, this.cursor = null); for (var r = e.length, i = 0; i < r; i++) { var n = e[i], o = this.getInteractionDataForPointerId(n), s = this.configureInteractionEventForDOMEvent(this.eventData, n, o); s.data.originalEvent = t, this.processInteractive(s, this.lastObjectRendered, this.processPointerMove, !0), this.emit("pointermove", s), "touch" === n.pointerType && this.emit("touchmove", s), "mouse" !== n.pointerType && "pen" !== n.pointerType || this.emit("mousemove", s) } "mouse" === e[0].pointerType && this.setCursorMode(this.cursor) } }, r.prototype.processPointerMove = function (t, e, r) { var i = t.data, n = "touch" === i.pointerType, o = "mouse" === i.pointerType || "pen" === i.pointerType; o && this.processPointerOverOut(t, e, r), this.moveWhenInside && !r || (this.dispatchEvent(e, "pointermove", t), n && this.dispatchEvent(e, "touchmove", t), o && this.dispatchEvent(e, "mousemove", t)) }, r.prototype.onPointerOut = function (t) { if (!this.supportsTouchEvents || "touch" !== t.pointerType) { var e = this.normalizeToPointerData(t)[0]; "mouse" === e.pointerType && (this.mouseOverRenderer = !1, this.setCursorMode(null)); var r = this.getInteractionDataForPointerId(e), i = this.configureInteractionEventForDOMEvent(this.eventData, e, r); i.data.originalEvent = e, this.processInteractive(i, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit("pointerout", i), "mouse" === e.pointerType || "pen" === e.pointerType ? this.emit("mouseout", i) : this.releaseInteractionDataForPointerId(r.identifier) } }, r.prototype.processPointerOverOut = function (t, e, r) { var i = t.data, n = t.data.identifier, o = "mouse" === i.pointerType || "pen" === i.pointerType, s = e.trackedPointers[n]; r && !s && (s = e.trackedPointers[n] = new ir(n)), void 0 !== s && (r && this.mouseOverRenderer ? (s.over || (s.over = !0, this.delayDispatchEvent(e, "pointerover", t), o && this.delayDispatchEvent(e, "mouseover", t)), o && null === this.cursor && (this.cursor = e.cursor)) : s.over && (s.over = !1, this.dispatchEvent(e, "pointerout", this.eventData), o && this.dispatchEvent(e, "mouseout", t), s.none && delete e.trackedPointers[n])) }, r.prototype.onPointerOver = function (t) { var e = this.normalizeToPointerData(t)[0], r = this.getInteractionDataForPointerId(e), i = this.configureInteractionEventForDOMEvent(this.eventData, e, r); i.data.originalEvent = e, "mouse" === e.pointerType && (this.mouseOverRenderer = !0), this.emit("pointerover", i), "mouse" !== e.pointerType && "pen" !== e.pointerType || this.emit("mouseover", i) }, r.prototype.getInteractionDataForPointerId = function (t) { var e, r = t.pointerId; return r === sr || "mouse" === t.pointerType ? e = this.mouse : this.activeInteractionData[r] ? e = this.activeInteractionData[r] : ((e = this.interactionDataPool.pop() || new tr).identifier = r, this.activeInteractionData[r] = e), e.copyEvent(t), e }, r.prototype.releaseInteractionDataForPointerId = function (t) { var e = this.activeInteractionData[t]; e && (delete this.activeInteractionData[t], e.reset(), this.interactionDataPool.push(e)) }, r.prototype.configureInteractionEventForDOMEvent = function (t, e, r) { return t.data = r, this.mapPositionToPoint(r.global, e.clientX, e.clientY), "touch" === e.pointerType && (e.globalX = r.global.x, e.globalY = r.global.y), r.originalEvent = e, t.reset(), t }, r.prototype.normalizeToPointerData = function (t) { var e = []; if (this.supportsTouchEvents && t instanceof TouchEvent) for (var r = 0, i = t.changedTouches.length; r < i; r++) { var n = t.changedTouches[r]; void 0 === n.button && (n.button = t.touches.length ? 1 : 0), void 0 === n.buttons && (n.buttons = t.touches.length ? 1 : 0), void 0 === n.isPrimary && (n.isPrimary = 1 === t.touches.length && "touchstart" === t.type), void 0 === n.width && (n.width = n.radiusX || 1), void 0 === n.height && (n.height = n.radiusY || 1), void 0 === n.tiltX && (n.tiltX = 0), void 0 === n.tiltY && (n.tiltY = 0), void 0 === n.pointerType && (n.pointerType = "touch"), void 0 === n.pointerId && (n.pointerId = n.identifier || 0), void 0 === n.pressure && (n.pressure = n.force || .5), void 0 === n.twist && (n.twist = 0), void 0 === n.tangentialPressure && (n.tangentialPressure = 0), void 0 === n.layerX && (n.layerX = n.offsetX = n.clientX), void 0 === n.layerY && (n.layerY = n.offsetY = n.clientY), n.isNormalized = !0, e.push(n) } else if (!(t instanceof MouseEvent) || this.supportsPointerEvents && t instanceof window.PointerEvent) e.push(t); else { var o = t; void 0 === o.isPrimary && (o.isPrimary = !0), void 0 === o.width && (o.width = 1), void 0 === o.height && (o.height = 1), void 0 === o.tiltX && (o.tiltX = 0), void 0 === o.tiltY && (o.tiltY = 0), void 0 === o.pointerType && (o.pointerType = "mouse"), void 0 === o.pointerId && (o.pointerId = sr), void 0 === o.pressure && (o.pressure = .5), void 0 === o.twist && (o.twist = 0), void 0 === o.tangentialPressure && (o.tangentialPressure = 0), o.isNormalized = !0, e.push(o) } return e }, r.prototype.destroy = function () { this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null }, r }(C), ur = function () { function t(t) { this.items = [], this._name = t, this._aliasCount = 0 } return t.prototype.emit = function (t, e, r, i, n, o, s, a) { if (arguments.length > 8) throw new Error("max arguments reached"); var h = this.name, u = this.items; this._aliasCount++; for (var l = 0, c = u.length; l < c; l++)u[l][h](t, e, r, i, n, o, s, a); return u === this.items && this._aliasCount--, this }, t.prototype.ensureNonAliasedItems = function () { this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0)) }, t.prototype.add = function (t) { return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this }, t.prototype.remove = function (t) { var e = this.items.indexOf(t); return -1 !== e && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this }, t.prototype.contains = function (t) { return -1 !== this.items.indexOf(t) }, t.prototype.removeAll = function () { return this.ensureNonAliasedItems(), this.items.length = 0, this }, t.prototype.destroy = function () { this.removeAll(), this.items = null, this._name = null }, Object.defineProperty(t.prototype, "empty", { get: function () { return 0 === this.items.length }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "name", { get: function () { return this._name }, enumerable: !1, configurable: !0 }), t }(); Object.defineProperties(ur.prototype, { dispatch: { value: ur.prototype.emit }, run: { value: ur.prototype.emit } }), D.PREFER_ENV = M.any ? t.ENV.WEBGL : t.ENV.WEBGL2, D.STRICT_TEXTURE_CACHE = !1; var lr = []; function cr(t, e) { if (!t) return null; var r = ""; if ("string" == typeof t) { var i = /\.(\w{3,4})(?:$|\?|#)/i.exec(t); i && (r = i[1].toLowerCase()) } for (var n = lr.length - 1; n >= 0; --n) { var o = lr[n]; if (o.test && o.test(t, r)) return new o(t, e) } throw new Error("Unrecognized source type to auto-detect Resource") } var dr = function (t, e) { return (dr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; function pr(t, e) { function r() { this.constructor = t } dr(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var fr = function () { function t(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new ur("setRealSize"), this.onUpdate = new ur("update"), this.onError = new ur("onError") } return t.prototype.bind = function (t) { this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height) }, t.prototype.unbind = function (t) { this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t) }, t.prototype.resize = function (t, e) { t === this._width && e === this._height || (this._width = t, this._height = e, this.onResize.emit(t, e)) }, Object.defineProperty(t.prototype, "valid", { get: function () { return !!this._width && !!this._height }, enumerable: !1, configurable: !0 }), t.prototype.update = function () { this.destroyed || this.onUpdate.emit() }, t.prototype.load = function () { return Promise.resolve(this) }, Object.defineProperty(t.prototype, "width", { get: function () { return this._width }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "height", { get: function () { return this._height }, enumerable: !1, configurable: !0 }), t.prototype.style = function (t, e, r) { return !1 }, t.prototype.dispose = function () { }, t.prototype.destroy = function () { this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null) }, t.test = function (t, e) { return !1 }, t }(), mr = function (e) { function r(t, r) { var i = this, n = r || {}, o = n.width, s = n.height; if (!o || !s) throw new Error("BufferResource width or height invalid"); return (i = e.call(this, o, s) || this).data = t, i } return pr(r, e), r.prototype.upload = function (e, r, i) { var n = e.gl; return n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === t.ALPHA_MODES.UNPACK), i.width === r.width && i.height === r.height ? n.texSubImage2D(r.target, 0, 0, 0, r.width, r.height, r.format, r.type, this.data) : (i.width = r.width, i.height = r.height, n.texImage2D(r.target, 0, i.internalFormat, r.width, r.height, 0, r.format, i.type, this.data)), !0 }, r.prototype.dispose = function () { this.data = null }, r.test = function (t) { return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array }, r }(fr), vr = { scaleMode: t.SCALE_MODES.NEAREST, format: t.FORMATS.RGBA, alphaMode: t.ALPHA_MODES.NPM }, gr = function (e) { function r(r, i) { void 0 === r && (r = null), void 0 === i && (i = null); var n = e.call(this) || this, o = (i = i || {}).alphaMode, s = i.mipmap, a = i.anisotropicLevel, h = i.scaleMode, u = i.width, l = i.height, c = i.wrapMode, d = i.format, p = i.type, f = i.target, m = i.resolution, v = i.resourceOptions; return !r || r instanceof fr || ((r = cr(r, v)).internal = !0), n.width = u || 0, n.height = l || 0, n.resolution = m || D.RESOLUTION, n.mipmap = void 0 !== s ? s : D.MIPMAP_TEXTURES, n.anisotropicLevel = void 0 !== a ? a : D.ANISOTROPIC_LEVEL, n.wrapMode = c || D.WRAP_MODE, n.scaleMode = void 0 !== h ? h : D.SCALE_MODE, n.format = d || t.FORMATS.RGBA, n.type = p || t.TYPES.UNSIGNED_BYTE, n.target = f || t.TARGETS.TEXTURE_2D, n.alphaMode = void 0 !== o ? o : t.ALPHA_MODES.UNPACK, void 0 !== i.premultiplyAlpha && (n.premultiplyAlpha = i.premultiplyAlpha), n.uid = ie(), n.touched = 0, n.isPowerOfTwo = !1, n._refreshPOT(), n._glTextures = {}, n.dirtyId = 0, n.dirtyStyleId = 0, n.cacheId = null, n.valid = u > 0 && l > 0, n.textureCacheIds = [], n.destroyed = !1, n.resource = null, n._batchEnabled = 0, n._batchLocation = 0, n.parentTextureArray = null, n.setResource(r), n } return pr(r, e), Object.defineProperty(r.prototype, "realWidth", { get: function () { return Math.ceil(this.width * this.resolution - 1e-4) }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "realHeight", { get: function () { return Math.ceil(this.height * this.resolution - 1e-4) }, enumerable: !1, configurable: !0 }), r.prototype.setStyle = function (t, e) { var r; return void 0 !== t && t !== this.scaleMode && (this.scaleMode = t, r = !0), void 0 !== e && e !== this.mipmap && (this.mipmap = e, r = !0), r && this.dirtyStyleId++, this }, r.prototype.setSize = function (t, e, r) { return this.resolution = r || this.resolution, this.width = t, this.height = e, this._refreshPOT(), this.update(), this }, r.prototype.setRealSize = function (t, e, r) { return this.resolution = r || this.resolution, this.width = t / this.resolution, this.height = e / this.resolution, this._refreshPOT(), this.update(), this }, r.prototype._refreshPOT = function () { this.isPowerOfTwo = Qt(this.realWidth) && Qt(this.realHeight) }, r.prototype.setResolution = function (t) { var e = this.resolution; return e === t ? this : (this.resolution = t, this.valid && (this.width = this.width * e / t, this.height = this.height * e / t, this.emit("update", this)), this._refreshPOT(), this) }, r.prototype.setResource = function (t) { if (this.resource === t) return this; if (this.resource) throw new Error("Resource can be set only once"); return t.bind(this), this.resource = t, this }, r.prototype.update = function () { this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this)) }, r.prototype.onError = function (t) { this.emit("error", this, t) }, r.prototype.destroy = function () { this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete he[this.cacheId], delete ae[this.cacheId], this.cacheId = null), this.dispose(), r.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0 }, r.prototype.dispose = function () { this.emit("dispose", this) }, r.prototype.castToBaseTexture = function () { return this }, r.from = function (t, e, i) { void 0 === i && (i = D.STRICT_TEXTURE_CACHE); var n = "string" == typeof t, o = null; n ? o = t : (t._pixiId || (t._pixiId = "pixiid_" + ie()), o = t._pixiId); var s = he[o]; if (n && i && !s) throw new Error('The cacheId "' + o + '" does not exist in BaseTextureCache.'); return s || ((s = new r(t, e)).cacheId = o, r.addToCache(s, o)), s }, r.fromBuffer = function (e, i, n, o) { e = e || new Float32Array(i * n * 4); var s = new mr(e, { width: i, height: n }), a = e instanceof Float32Array ? t.TYPES.FLOAT : t.TYPES.UNSIGNED_BYTE; return new r(s, Object.assign(vr, o || { width: i, height: n, type: a })) }, r.addToCache = function (t, e) { e && (-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e), he[e] && console.warn("BaseTexture added to the cache with an id [" + e + "] that already had an entry"), he[e] = t) }, r.removeFromCache = function (t) { if ("string" == typeof t) { var e = he[t]; if (e) { var r = e.textureCacheIds.indexOf(t); return r > -1 && e.textureCacheIds.splice(r, 1), delete he[t], e } } else if (t && t.textureCacheIds) { for (var i = 0; i < t.textureCacheIds.length; ++i)delete he[t.textureCacheIds[i]]; return t.textureCacheIds.length = 0, t } return null }, r._globalBatch = 0, r }(C), yr = function (t) { function e(e, r) { var i = this, n = r || {}, o = n.width, s = n.height; (i = t.call(this, o, s) || this).items = [], i.itemDirtyIds = []; for (var a = 0; a < e; a++) { var h = new gr; i.items.push(h), i.itemDirtyIds.push(-2) } return i.length = e, i._load = null, i.baseTexture = null, i } return pr(e, t), e.prototype.initFromArray = function (t, e) { for (var r = 0; r < this.length; r++)t[r] && (t[r].castToBaseTexture ? this.addBaseTextureAt(t[r].castToBaseTexture(), r) : t[r] instanceof fr ? this.addResourceAt(t[r], r) : this.addResourceAt(cr(t[r], e), r)) }, e.prototype.dispose = function () { for (var t = 0, e = this.length; t < e; t++)this.items[t].destroy(); this.items = null, this.itemDirtyIds = null, this._load = null }, e.prototype.addResourceAt = function (t, e) { if (!this.items[e]) throw new Error("Index " + e + " is out of bounds"); return t.valid && !this.valid && this.resize(t.width, t.height), this.items[e].setResource(t), this }, e.prototype.bind = function (e) { if (null !== this.baseTexture) throw new Error("Only one base texture per TextureArray is allowed"); t.prototype.bind.call(this, e); for (var r = 0; r < this.length; r++)this.items[r].parentTextureArray = e, this.items[r].on("update", e.update, e) }, e.prototype.unbind = function (e) { t.prototype.unbind.call(this, e); for (var r = 0; r < this.length; r++)this.items[r].parentTextureArray = null, this.items[r].off("update", e.update, e) }, e.prototype.load = function () { var t = this; if (this._load) return this._load; var e = this.items.map(function (t) { return t.resource }).filter(function (t) { return t }).map(function (t) { return t.load() }); return this._load = Promise.all(e).then(function () { var e = t.items[0], r = e.realWidth, i = e.realHeight; return t.resize(r, i), Promise.resolve(t) }), this._load }, e }(fr), _r = function (e) { function r(t, r) { var i, n, o = this, s = r || {}, a = s.width, h = s.height; return Array.isArray(t) ? (i = t, n = t.length) : n = t, o = e.call(this, n, { width: a, height: h }) || this, i && o.initFromArray(i, r), o } return pr(r, e), r.prototype.addBaseTextureAt = function (t, e) { if (!t.resource) throw new Error("ArrayResource does not support RenderTexture"); return this.addResourceAt(t.resource, e), this }, r.prototype.bind = function (r) { e.prototype.bind.call(this, r), r.target = t.TARGETS.TEXTURE_2D_ARRAY }, r.prototype.upload = function (t, e, r) { var i = this.length, n = this.itemDirtyIds, o = this.items, s = t.gl; r.dirtyId < 0 && s.texImage3D(s.TEXTURE_2D_ARRAY, 0, e.format, this._width, this._height, i, 0, e.format, e.type, null); for (var a = 0; a < i; a++) { var h = o[a]; n[a] < h.dirtyId && (n[a] = h.dirtyId, h.valid && s.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, a, h.resource.width, h.resource.height, 1, e.format, e.type, h.resource.source)) } return !0 }, r }(yr), xr = function (e) { function r(t) { var r = this, i = t, n = i.naturalWidth || i.videoWidth || i.width, o = i.naturalHeight || i.videoHeight || i.height; return (r = e.call(this, n, o) || this).source = t, r.noSubImage = !1, r } return pr(r, e), r.crossOrigin = function (t, e, r) { void 0 === r && 0 !== e.indexOf("data:") ? t.crossOrigin = pe(e) : !1 !== r && (t.crossOrigin = "string" == typeof r ? r : "anonymous") }, r.prototype.upload = function (e, r, i, n) { var o = e.gl, s = r.realWidth, a = r.realHeight; return n = n || this.source, o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === t.ALPHA_MODES.UNPACK), this.noSubImage || r.target !== o.TEXTURE_2D || i.width !== s || i.height !== a ? (i.width = s, i.height = a, o.texImage2D(r.target, 0, r.format, r.format, r.type, n)) : o.texSubImage2D(o.TEXTURE_2D, 0, 0, 0, r.format, r.type, n), !0 }, r.prototype.update = function () { if (!this.destroyed) { var t = this.source, r = t.naturalWidth || t.videoWidth || t.width, i = t.naturalHeight || t.videoHeight || t.height; this.resize(r, i), e.prototype.update.call(this) } }, r.prototype.dispose = function () { this.source = null }, r }(fr), br = function (t) { function e() { return null !== t && t.apply(this, arguments) || this } return pr(e, t), e.test = function (t) { var e = window.OffscreenCanvas; return !!(e && t instanceof e) || t instanceof HTMLCanvasElement }, e }(xr), Er = function (e) { function r(i, n) { var o = this, s = n || {}, a = s.width, h = s.height, u = s.autoLoad, l = s.linkBaseTexture; if (i && i.length !== r.SIDES) throw new Error("Invalid length. Got " + i.length + ", expected 6"); o = e.call(this, 6, { width: a, height: h }) || this; for (var c = 0; c < r.SIDES; c++)o.items[c].target = t.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + c; return o.linkBaseTexture = !1 !== l, i && o.initFromArray(i, n), !1 !== u && o.load(), o } return pr(r, e), r.prototype.bind = function (r) { e.prototype.bind.call(this, r), r.target = t.TARGETS.TEXTURE_CUBE_MAP }, r.prototype.addBaseTextureAt = function (e, r, i) { if (void 0 === i && (i = this.linkBaseTexture), !this.items[r]) throw new Error("Index " + r + " is out of bounds"); if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0) { if (!e.resource) throw new Error("CubeResource does not support copying of renderTexture."); this.addResourceAt(e.resource, r) } else e.target = t.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + r, e.parentTextureArray = this.baseTexture, this.items[r] = e; return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[r] = e, this }, r.prototype.upload = function (t, e, i) { for (var n = this.itemDirtyIds, o = 0; o < r.SIDES; o++) { var s = this.items[o]; n[o] < s.dirtyId && (s.valid && s.resource ? (s.resource.upload(t, s, i), n[o] = s.dirtyId) : n[o] < -1 && (t.gl.texImage2D(s.target, 0, i.internalFormat, e.realWidth, e.realHeight, 0, e.format, i.type, null), n[o] = -1)) } return !0 }, r.test = function (t) { return Array.isArray(t) && t.length === r.SIDES }, r.SIDES = 6, r }(yr), Tr = function (e) { function r(t, r) { var i = this; if (r = r || {}, !(t instanceof HTMLImageElement)) { var n = new Image; xr.crossOrigin(n, t, r.crossorigin), n.src = t, t = n } return i = e.call(this, t) || this, !t.complete && i._width && i._height && (i._width = 0, i._height = 0), i.url = t.src, i._process = null, i.preserveBitmap = !1, i.createBitmap = (void 0 !== r.createBitmap ? r.createBitmap : D.CREATE_IMAGE_BITMAP) && !!window.createImageBitmap, i.alphaMode = "number" == typeof r.alphaMode ? r.alphaMode : null, void 0 !== r.premultiplyAlpha && (i.premultiplyAlpha = r.premultiplyAlpha), i.bitmap = null, i._load = null, !1 !== r.autoLoad && i.load(), i } return pr(r, e), r.prototype.load = function (t) { var e = this; return this._load ? this._load : (void 0 !== t && (this.createBitmap = t), this._load = new Promise(function (t, r) { var i = e.source; e.url = i.src; var n = function () { e.destroyed || (i.onload = null, i.onerror = null, e.resize(i.width, i.height), e._load = null, e.createBitmap ? t(e.process()) : t(e)) }; i.complete && i.src ? n() : (i.onload = n, i.onerror = function (t) { r(t), e.onError.emit(t) }) }), this._load) }, r.prototype.process = function () { var e = this, r = this.source; return null !== this._process ? this._process : null === this.bitmap && window.createImageBitmap ? (this._process = window.createImageBitmap(r, 0, 0, r.width, r.height, { premultiplyAlpha: this.alphaMode === t.ALPHA_MODES.UNPACK ? "premultiply" : "none" }).then(function (t) { return e.destroyed ? Promise.reject() : (e.bitmap = t, e.update(), e._process = null, Promise.resolve(e)) }), this._process) : Promise.resolve(this) }, r.prototype.upload = function (t, r, i) { if ("number" == typeof this.alphaMode && (r.alphaMode = this.alphaMode), !this.createBitmap) return e.prototype.upload.call(this, t, r, i); if (!this.bitmap && (this.process(), !this.bitmap)) return !1; if (e.prototype.upload.call(this, t, r, i, this.bitmap), !this.preserveBitmap) { var n = !0, o = r._glTextures; for (var s in o) { var a = o[s]; if (a !== i && a.dirtyId !== r.dirtyId) { n = !1; break } } n && (this.bitmap.close && this.bitmap.close(), this.bitmap = null) } return !0 }, r.prototype.dispose = function () { this.source.onload = null, this.source.onerror = null, e.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null }, r.test = function (t) { return "string" == typeof t || t instanceof HTMLImageElement }, r }(xr), Sr = function (t) { function e(e, r) { var i = this; return r = r || {}, (i = t.call(this, document.createElement("canvas")) || this)._width = 0, i._height = 0, i.svg = e, i.scale = r.scale || 1, i._overrideWidth = r.width, i._overrideHeight = r.height, i._resolve = null, i._crossorigin = r.crossorigin, i._load = null, !1 !== r.autoLoad && i.load(), i } return pr(e, t), e.prototype.load = function () { var t = this; return this._load ? this._load : (this._load = new Promise(function (e) { if (t._resolve = function () { t.resize(t.source.width, t.source.height), e(t) }, /^\<svg/.test(t.svg.trim())) { if (!btoa) throw new Error("Your browser doesn't support base64 conversions."); t.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(t.svg))) } t._loadSvg() }), this._load) }, e.prototype._loadSvg = function () { var t = this, e = new Image; xr.crossOrigin(e, this.svg, this._crossorigin), e.src = this.svg, e.onerror = function (r) { t._resolve && (e.onerror = null, t.onError.emit(r)) }, e.onload = function () { if (t._resolve) { var r = e.width, i = e.height; if (!r || !i) throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them."); var n = r * t.scale, o = i * t.scale; (t._overrideWidth || t._overrideHeight) && (n = t._overrideWidth || t._overrideHeight / i * r, o = t._overrideHeight || t._overrideWidth / r * i), n = Math.round(n), o = Math.round(o); var s = t.source; s.width = n, s.height = o, s._pixiId = "canvas_" + ie(), s.getContext("2d").drawImage(e, 0, 0, r, i, 0, 0, n, o), t._resolve(), t._resolve = null } } }, e.getSize = function (t) { var r = e.SVG_SIZE.exec(t), i = {}; return r && (i[r[1]] = Math.round(parseFloat(r[3])), i[r[5]] = Math.round(parseFloat(r[7]))), i }, e.prototype.dispose = function () { t.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null }, e.test = function (t, e) { return "svg" === e || "string" == typeof t && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t) || "string" == typeof t && 0 === t.indexOf("<svg") }, e.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, e }(xr), wr = function (t) { function e(r, i) { var n = this; if (i = i || {}, !(r instanceof HTMLVideoElement)) { var o = document.createElement("video"); o.setAttribute("preload", "auto"), o.setAttribute("webkit-playsinline", ""), o.setAttribute("playsinline", ""), "string" == typeof r && (r = [r]); var s = r[0].src || r[0]; xr.crossOrigin(o, s, i.crossorigin); for (var a = 0; a < r.length; ++a) { var h = document.createElement("source"), u = r[a], l = u.src, c = u.mime, d = (l = l || r[a]).split("?").shift().toLowerCase(), p = d.substr(d.lastIndexOf(".") + 1); c = c || e.MIME_TYPES[p] || "video/" + p, h.src = l, h.type = c, o.appendChild(h) } r = o } return (n = t.call(this, r) || this).noSubImage = !0, n._autoUpdate = !0, n._isConnectedToTicker = !1, n._updateFPS = i.updateFPS || 0, n._msToNextUpdate = 0, n.autoPlay = !1 !== i.autoPlay, n._load = null, n._resolve = null, n._onCanPlay = n._onCanPlay.bind(n), n._onError = n._onError.bind(n), !1 !== i.autoLoad && n.load(), n } return pr(e, t), e.prototype.update = function (e) { if (void 0 === e && (e = 0), !this.destroyed) { var r = Qe.shared.elapsedMS * this.source.playbackRate; this._msToNextUpdate = Math.floor(this._msToNextUpdate - r), (!this._updateFPS || this._msToNextUpdate <= 0) && (t.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0) } }, e.prototype.load = function () { var t = this; if (this._load) return this._load; var e = this.source; return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart.bind(this)), e.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlay), e.addEventListener("error", this._onError, !0)), this._load = new Promise(function (r) { t.valid ? r(t) : (t._resolve = r, e.load()) }), this._load }, e.prototype._onError = function (t) { this.source.removeEventListener("error", this._onError, !0), this.onError.emit(t) }, e.prototype._isSourcePlaying = function () { var t = this.source; return t.currentTime > 0 && !1 === t.paused && !1 === t.ended && t.readyState > 2 }, e.prototype._isSourceReady = function () { var t = this.source; return 3 === t.readyState || 4 === t.readyState }, e.prototype._onPlayStart = function () { this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Qe.shared.add(this.update, this), this._isConnectedToTicker = !0) }, e.prototype._onPlayStop = function () { this._isConnectedToTicker && (Qe.shared.remove(this.update, this), this._isConnectedToTicker = !1) }, e.prototype._onCanPlay = function () { var t = this.source; t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlay); var e = this.valid; this.resize(t.videoWidth, t.videoHeight), !e && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t.play() }, e.prototype.dispose = function () { this._isConnectedToTicker && Qe.shared.remove(this.update, this); var e = this.source; e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), t.prototype.dispose.call(this) }, Object.defineProperty(e.prototype, "autoUpdate", { get: function () { return this._autoUpdate }, set: function (t) { t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (Qe.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Qe.shared.add(this.update, this), this._isConnectedToTicker = !0)) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "updateFPS", { get: function () { return this._updateFPS }, set: function (t) { t !== this._updateFPS && (this._updateFPS = t) }, enumerable: !1, configurable: !0 }), e.test = function (t, r) { return t instanceof HTMLVideoElement || e.TYPES.indexOf(r) > -1 }, e.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], e.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" }, e }(xr), Pr = function (t) { function e() { return null !== t && t.apply(this, arguments) || this } return pr(e, t), e.test = function (t) { return !!window.createImageBitmap && t instanceof ImageBitmap }, e }(xr); lr.push(Tr, Pr, br, wr, Sr, mr, Er, _r); var Ir = { Resource: fr, BaseImageResource: xr, INSTALLED: lr, autoDetectResource: cr, AbstractMultiResource: yr, ArrayResource: _r, BufferResource: mr, CanvasResource: br, CubeResource: Er, ImageResource: Tr, SVGResource: Sr, VideoResource: wr, ImageBitmapResource: Pr }, Ar = function () { function t(t) { this.renderer = t } return t.prototype.destroy = function () { this.renderer = null }, t }(), Or = function (e) { function r() { return null !== e && e.apply(this, arguments) || this } return pr(r, e), r.prototype.upload = function (e, r, i) { var n = e.gl; return n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === t.ALPHA_MODES.UNPACK), i.width === r.width && i.height === r.height ? n.texSubImage2D(r.target, 0, 0, 0, r.width, r.height, r.format, r.type, this.data) : (i.width = r.width, i.height = r.height, n.texImage2D(r.target, 0, 1 === e.context.webGLVersion ? n.DEPTH_COMPONENT : n.DEPTH_COMPONENT16, r.width, r.height, 0, r.format, r.type, this.data)), !0 }, r }(mr), Mr = function () { function e(e, r) { this.width = Math.ceil(e || 100), this.height = Math.ceil(r || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new ur("disposeFramebuffer"), this.multisample = t.MSAA_QUALITY.NONE } return Object.defineProperty(e.prototype, "colorTexture", { get: function () { return this.colorTextures[0] }, enumerable: !1, configurable: !0 }), e.prototype.addColorTexture = function (e, r) { return void 0 === e && (e = 0), this.colorTextures[e] = r || new gr(null, { scaleMode: t.SCALE_MODES.NEAREST, resolution: 1, mipmap: t.MIPMAP_MODES.OFF, width: this.width, height: this.height }), this.dirtyId++, this.dirtyFormat++, this }, e.prototype.addDepthTexture = function (e) { return this.depthTexture = e || new gr(new Or(null, { width: this.width, height: this.height }), { scaleMode: t.SCALE_MODES.NEAREST, resolution: 1, width: this.width, height: this.height, mipmap: t.MIPMAP_MODES.OFF, format: t.FORMATS.DEPTH_COMPONENT, type: t.TYPES.UNSIGNED_SHORT }), this.dirtyId++, this.dirtyFormat++, this }, e.prototype.enableDepth = function () { return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this }, e.prototype.enableStencil = function () { return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this }, e.prototype.resize = function (t, e) { if (t = Math.ceil(t), e = Math.ceil(e), t !== this.width || e !== this.height) { this.width = t, this.height = e, this.dirtyId++, this.dirtySize++; for (var r = 0; r < this.colorTextures.length; r++) { var i = this.colorTextures[r], n = i.resolution; i.setSize(t / n, e / n) } if (this.depthTexture) { n = this.depthTexture.resolution; this.depthTexture.setSize(t / n, e / n) } } }, e.prototype.dispose = function () { this.disposeRunner.emit(this, !1) }, e.prototype.destroyDepthTexture = function () { this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat) }, e }(), Dr = function (t) { function e(e) { var r = this; "number" == typeof e && (e = { width: arguments[0], height: arguments[1], scaleMode: arguments[2], resolution: arguments[3] }); r = t.call(this, null, e) || this; var i = e || {}, n = i.width, o = i.height; return r.mipmap = 0, r.width = Math.ceil(n) || 100, r.height = Math.ceil(o) || 100, r.valid = !0, r.clearColor = [0, 0, 0, 0], r.framebuffer = new Mr(r.width * r.resolution, r.height * r.resolution).addColorTexture(0, r), r.maskStack = [], r.filterStack = [{}], r } return pr(e, t), e.prototype.resize = function (t, e) { t = Math.ceil(t), e = Math.ceil(e), this.framebuffer.resize(t * this.resolution, e * this.resolution) }, e.prototype.dispose = function () { this.framebuffer.dispose(), t.prototype.dispose.call(this) }, e.prototype.destroy = function () { t.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null }, e }(gr), Cr = function () { function t() { this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8) } return t.prototype.set = function (t, e, r) { var i = e.width, n = e.height; if (r) { var o = t.width / 2 / i, s = t.height / 2 / n, a = t.x / i + o, h = t.y / n + s; r = Ne.add(r, Ne.NW), this.x0 = a + o * Ne.uX(r), this.y0 = h + s * Ne.uY(r), r = Ne.add(r, 2), this.x1 = a + o * Ne.uX(r), this.y1 = h + s * Ne.uY(r), r = Ne.add(r, 2), this.x2 = a + o * Ne.uX(r), this.y2 = h + s * Ne.uY(r), r = Ne.add(r, 2), this.x3 = a + o * Ne.uX(r), this.y3 = h + s * Ne.uY(r) } else this.x0 = t.x / i, this.y0 = t.y / n, this.x1 = (t.x + t.width) / i, this.y1 = t.y / n, this.x2 = (t.x + t.width) / i, this.y2 = (t.y + t.height) / n, this.x3 = t.x / i, this.y3 = (t.y + t.height) / n; this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3 }, t }(), Rr = new Cr, Lr = function (t) { function e(r, i, n, o, s, a) { var h = t.call(this) || this; if (h.noFrame = !1, i || (h.noFrame = !0, i = new xe(0, 0, 1, 1)), r instanceof e && (r = r.baseTexture), h.baseTexture = r, h._frame = i, h.trim = o, h.valid = !1, h._uvs = Rr, h.uvMatrix = null, h.orig = n || i, h._rotate = Number(s || 0), !0 === s) h._rotate = 2; else if (h._rotate % 2 != 0) throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually"); return h.defaultAnchor = a ? new we(a.x, a.y) : new we(0, 0), h._updateID = 0, h.textureCacheIds = [], r.valid ? h.noFrame ? r.valid && h.onBaseTextureUpdated(r) : h.frame = i : r.once("loaded", h.onBaseTextureUpdated, h), h.noFrame && r.on("update", h.onBaseTextureUpdated, h), h } return pr(e, t), e.prototype.update = function () { this.baseTexture.resource && this.baseTexture.resource.update() }, e.prototype.onBaseTextureUpdated = function (t) { if (this.noFrame) { if (!this.baseTexture.valid) return; this._frame.width = t.width, this._frame.height = t.height, this.valid = !0, this.updateUvs() } else this.frame = this._frame; this.emit("update", this) }, e.prototype.destroy = function (t) { if (this.baseTexture) { if (t) { var r = this.baseTexture; r && r.url && ae[r.url] && e.removeFromCache(r.url), this.baseTexture.destroy() } this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null } this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, e.removeFromCache(this), this.textureCacheIds = null }, e.prototype.clone = function () { return new e(this.baseTexture, this.frame.clone(), this.orig.clone(), this.trim && this.trim.clone(), this.rotate, this.defaultAnchor) }, e.prototype.updateUvs = function () { this._uvs === Rr && (this._uvs = new Cr), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++ }, e.from = function (t, r, i) { void 0 === r && (r = {}), void 0 === i && (i = D.STRICT_TEXTURE_CACHE); var n = "string" == typeof t, o = null; n ? o = t : (t._pixiId || (t._pixiId = "pixiid_" + ie()), o = t._pixiId); var s = ae[o]; if (n && i && !s) throw new Error('The cacheId "' + o + '" does not exist in TextureCache.'); return s || (r.resolution || (r.resolution = fe(t)), (s = new e(new gr(t, r))).baseTexture.cacheId = o, gr.addToCache(s.baseTexture, o), e.addToCache(s, o)), s }, e.fromURL = function (t, r) { var i = Object.assign({ autoLoad: !1 }, null == r ? void 0 : r.resourceOptions), n = e.from(t, Object.assign({ resourceOptions: i }, r), !1), o = n.baseTexture.resource; return n.baseTexture.valid ? Promise.resolve(n) : o.load().then(function () { return Promise.resolve(n) }) }, e.fromBuffer = function (t, r, i, n) { return new e(gr.fromBuffer(t, r, i, n)) }, e.fromLoader = function (t, r, i) { var n = new Tr(t); n.url = r; var o = new e(new gr(n, { scaleMode: D.SCALE_MODE, resolution: fe(r) })); return i || (i = r), gr.addToCache(o.baseTexture, i), e.addToCache(o, i), i !== r && (gr.addToCache(o.baseTexture, r), e.addToCache(o, r)), o }, e.addToCache = function (t, e) { e && (-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e), ae[e] && console.warn("Texture added to the cache with an id [" + e + "] that already had an entry"), ae[e] = t) }, e.removeFromCache = function (t) { if ("string" == typeof t) { var e = ae[t]; if (e) { var r = e.textureCacheIds.indexOf(t); return r > -1 && e.textureCacheIds.splice(r, 1), delete ae[t], e } } else if (t && t.textureCacheIds) { for (var i = 0; i < t.textureCacheIds.length; ++i)ae[t.textureCacheIds[i]] === t && delete ae[t.textureCacheIds[i]]; return t.textureCacheIds.length = 0, t } return null }, Object.defineProperty(e.prototype, "resolution", { get: function () { return this.baseTexture.resolution }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "frame", { get: function () { return this._frame }, set: function (t) { this._frame = t, this.noFrame = !1; var e = t.x, r = t.y, i = t.width, n = t.height, o = e + i > this.baseTexture.width, s = r + n > this.baseTexture.height; if (o || s) { var a = o && s ? "and" : "or", h = "X: " + e + " + " + i + " = " + (e + i) + " > " + this.baseTexture.width, u = "Y: " + r + " + " + n + " = " + (r + n) + " > " + this.baseTexture.height; throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + h + " " + a + " " + u) } this.valid = i && n && this.baseTexture.valid, this.trim || this.rotate || (this.orig = t), this.valid && this.updateUvs() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "rotate", { get: function () { return this._rotate }, set: function (t) { this._rotate = t, this.valid && this.updateUvs() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "width", { get: function () { return this.orig.width }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "height", { get: function () { return this.orig.height }, enumerable: !1, configurable: !0 }), e.prototype.castToBaseTexture = function () { return this.baseTexture }, e }(C); function Nr(t) { t.destroy = function () { }, t.on = function () { }, t.once = function () { }, t.emit = function () { } } Lr.EMPTY = new Lr(new gr), Nr(Lr.EMPTY), Nr(Lr.EMPTY.baseTexture), Lr.WHITE = function () { var t = document.createElement("canvas"); t.width = 16, t.height = 16; var e = t.getContext("2d"); return e.fillStyle = "white", e.fillRect(0, 0, 16, 16), new Lr(new gr(new br(t))) }(), Nr(Lr.WHITE), Nr(Lr.WHITE.baseTexture); var Fr = function (t) { function e(e, r) { var i = this, n = null; if (!(e instanceof Dr)) { var o = arguments[1], s = arguments[2], a = arguments[3], h = arguments[4]; console.warn("Please use RenderTexture.create(" + o + ", " + s + ") instead of the ctor directly."), n = arguments[0], r = null, e = new Dr({ width: o, height: s, scaleMode: a, resolution: h }) } return (i = t.call(this, e, r) || this).legacyRenderer = n, i.valid = !0, i.filterFrame = null, i.filterPoolKey = null, i.updateUvs(), i } return pr(e, t), Object.defineProperty(e.prototype, "framebuffer", { get: function () { return this.baseTexture.framebuffer }, enumerable: !1, configurable: !0 }), e.prototype.resize = function (t, e, r) { void 0 === r && (r = !0), t = Math.ceil(t), e = Math.ceil(e), this.valid = t > 0 && e > 0, this._frame.width = this.orig.width = t, this._frame.height = this.orig.height = e, r && this.baseTexture.resize(t, e), this.updateUvs() }, e.prototype.setResolution = function (t) { var e = this.baseTexture; e.resolution !== t && (e.setResolution(t), this.resize(e.width, e.height, !1)) }, e.create = function (t) { return "number" == typeof t && (t = { width: t, height: arguments[1], scaleMode: arguments[2], resolution: arguments[3] }), new e(new Dr(t)) }, e }(Lr), Br = function () { function t(t) { this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0 } return t.prototype.createTexture = function (t, e) { var r = new Dr(Object.assign({ width: t, height: e, resolution: 1 }, this.textureOptions)); return new Fr(r) }, t.prototype.getOptimalTexture = function (e, r, i) { void 0 === i && (i = 1); var n = t.SCREEN_KEY; e *= i, r *= i, this.enableFullScreen && e === this._pixelsWidth && r === this._pixelsHeight || (n = (65535 & (e = Jt(e))) << 16 | 65535 & (r = Jt(r))), this.texturePool[n] || (this.texturePool[n] = []); var o = this.texturePool[n].pop(); return o || (o = this.createTexture(e, r)), o.filterPoolKey = n, o.setResolution(i), o }, t.prototype.getFilterTexture = function (t, e) { var r = this.getOptimalTexture(t.width, t.height, e || t.resolution); return r.filterFrame = t.filterFrame, r }, t.prototype.returnTexture = function (t) { var e = t.filterPoolKey; t.filterFrame = null, this.texturePool[e].push(t) }, t.prototype.returnFilterTexture = function (t) { this.returnTexture(t) }, t.prototype.clear = function (t) { if (t = !1 !== t) for (var e in this.texturePool) { var r = this.texturePool[e]; if (r) for (var i = 0; i < r.length; i++)r[i].destroy(!0) } this.texturePool = {} }, t.prototype.setScreenSize = function (e) { if (e.width !== this._pixelsWidth || e.height !== this._pixelsHeight) { var r = t.SCREEN_KEY, i = this.texturePool[r]; if (this.enableFullScreen = e.width > 0 && e.height > 0, i) for (var n = 0; n < i.length; n++)i[n].destroy(!0); this.texturePool[r] = [], this._pixelsWidth = e.width, this._pixelsHeight = e.height } }, t.SCREEN_KEY = "screen", t }(), Ur = function () { function t(t, e, r, i, n, o, s) { void 0 === e && (e = 0), void 0 === r && (r = !1), void 0 === i && (i = 5126), this.buffer = t, this.size = e, this.normalized = r, this.type = i, this.stride = n, this.start = o, this.instance = s } return t.prototype.destroy = function () { this.buffer = null }, t.from = function (e, r, i, n, o) { return new t(e, r, i, n, o) }, t }(), kr = 0, Xr = function () { function t(t, e, r) { void 0 === e && (e = !0), void 0 === r && (r = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = r, this.static = e, this.id = kr++, this.disposeRunner = new ur("disposeBuffer") } return t.prototype.update = function (t) { this.data = t || this.data, this._updateID++ }, t.prototype.dispose = function () { this.disposeRunner.emit(this, !1) }, t.prototype.destroy = function () { this.dispose(), this.data = null }, t.from = function (e) { return e instanceof Array && (e = new Float32Array(e)), new t(e) }, t }(); function jr(t) { if (4 === t.BYTES_PER_ELEMENT) return t instanceof Float32Array ? "Float32Array" : t instanceof Uint32Array ? "Uint32Array" : "Int32Array"; if (2 === t.BYTES_PER_ELEMENT) { if (t instanceof Uint16Array) return "Uint16Array" } else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array) return "Uint8Array"; return null } var Hr = { Float32Array: Float32Array, Uint32Array: Uint32Array, Int32Array: Int32Array, Uint8Array: Uint8Array }; var Gr = { 5126: 4, 5123: 2, 5121: 1 }, Yr = 0, zr = { Float32Array: Float32Array, Uint32Array: Uint32Array, Int32Array: Int32Array, Uint8Array: Uint8Array, Uint16Array: Uint16Array }, Vr = function () { function t(t, e) { void 0 === t && (t = []), void 0 === e && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = Yr++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new ur("disposeGeometry"), this.refCount = 0 } return t.prototype.addAttribute = function (t, e, r, i, n, o, s, a) { if (void 0 === r && (r = 0), void 0 === i && (i = !1), void 0 === a && (a = !1), !e) throw new Error("You must pass a buffer when creating an attribute"); e instanceof Xr || (e instanceof Array && (e = new Float32Array(e)), e = new Xr(e)); var h = t.split("|"); if (h.length > 1) { for (var u = 0; u < h.length; u++)this.addAttribute(h[u], e, r, i, n); return this } var l = this.buffers.indexOf(e); return -1 === l && (this.buffers.push(e), l = this.buffers.length - 1), this.attributes[t] = new Ur(l, r, i, n, o, s, a), this.instanced = this.instanced || a, this }, t.prototype.getAttribute = function (t) { return this.attributes[t] }, t.prototype.getBuffer = function (t) { return this.buffers[this.getAttribute(t).buffer] }, t.prototype.addIndex = function (t) { return t instanceof Xr || (t instanceof Array && (t = new Uint16Array(t)), t = new Xr(t)), t.index = !0, this.indexBuffer = t, -1 === this.buffers.indexOf(t) && this.buffers.push(t), this }, t.prototype.getIndex = function () { return this.indexBuffer }, t.prototype.interleave = function () { if (1 === this.buffers.length || 2 === this.buffers.length && this.indexBuffer) return this; var t, e = [], r = [], i = new Xr; for (t in this.attributes) { var n = this.attributes[t], o = this.buffers[n.buffer]; e.push(o.data), r.push(n.size * Gr[n.type] / 4), n.buffer = 0 } for (i.data = function (t, e) { for (var r = 0, i = 0, n = {}, o = 0; o < t.length; o++)i += e[o], r += t[o].length; var s = new ArrayBuffer(4 * r), a = null, h = 0; for (o = 0; o < t.length; o++) { var u = e[o], l = t[o], c = jr(l); n[c] || (n[c] = new Hr[c](s)), a = n[c]; for (var d = 0; d < l.length; d++)a[(d / u | 0) * i + h + d % u] = l[d]; h += u } return new Float32Array(s) }(e, r), t = 0; t < this.buffers.length; t++)this.buffers[t] !== this.indexBuffer && this.buffers[t].destroy(); return this.buffers = [i], this.indexBuffer && this.buffers.push(this.indexBuffer), this }, t.prototype.getSize = function () { for (var t in this.attributes) { var e = this.attributes[t]; return this.buffers[e.buffer].data.length / (e.stride / 4 || e.size) } return 0 }, t.prototype.dispose = function () { this.disposeRunner.emit(this, !1) }, t.prototype.destroy = function () { this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null }, t.prototype.clone = function () { for (var e = new t, r = 0; r < this.buffers.length; r++)e.buffers[r] = new Xr(this.buffers[r].data.slice(0)); for (var r in this.attributes) { var i = this.attributes[r]; e.attributes[r] = new Ur(i.buffer, i.size, i.normalized, i.type, i.stride, i.start, i.instance) } return this.indexBuffer && (e.indexBuffer = e.buffers[this.buffers.indexOf(this.indexBuffer)], e.indexBuffer.index = !0), e }, t.merge = function (e) { for (var r, i = new t, n = [], o = [], s = [], a = 0; a < e.length; a++) { r = e[a]; for (var h = 0; h < r.buffers.length; h++)o[h] = o[h] || 0, o[h] += r.buffers[h].data.length, s[h] = 0 } for (a = 0; a < r.buffers.length; a++)n[a] = new (zr[jr(r.buffers[a].data)])(o[a]), i.buffers[a] = new Xr(n[a]); for (a = 0; a < e.length; a++) { r = e[a]; for (h = 0; h < r.buffers.length; h++)n[h].set(r.buffers[h].data, s[h]), s[h] += r.buffers[h].data.length } if (i.attributes = r.attributes, r.indexBuffer) { i.indexBuffer = i.buffers[r.buffers.indexOf(r.indexBuffer)], i.indexBuffer.index = !0; var u = 0, l = 0, c = 0, d = 0; for (a = 0; a < r.buffers.length; a++)if (r.buffers[a] !== r.indexBuffer) { d = a; break } for (var a in r.attributes) { var p = r.attributes[a]; (0 | p.buffer) === d && (l += p.size * Gr[p.type] / 4) } for (a = 0; a < e.length; a++) { var f = e[a].indexBuffer.data; for (h = 0; h < f.length; h++)i.indexBuffer.data[h + c] += u; u += r.buffers[d].data.length / l, c += f.length } } return i }, t }(), Wr = function (t) { function e() { var e = t.call(this) || this; return e.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2]), e } return pr(e, t), e }(Vr), qr = function (t) { function e() { var e = t.call(this) || this; return e.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), e.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), e.vertexBuffer = new Xr(e.vertices), e.uvBuffer = new Xr(e.uvs), e.addAttribute("aVertexPosition", e.vertexBuffer).addAttribute("aTextureCoord", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e } return pr(e, t), e.prototype.map = function (t, e) { var r = 0, i = 0; return this.uvs[0] = r, this.uvs[1] = i, this.uvs[2] = r + e.width / t.width, this.uvs[3] = i, this.uvs[4] = r + e.width / t.width, this.uvs[5] = i + e.height / t.height, this.uvs[6] = r, this.uvs[7] = i + e.height / t.height, r = e.x, i = e.y, this.vertices[0] = r, this.vertices[1] = i, this.vertices[2] = r + e.width, this.vertices[3] = i, this.vertices[4] = r + e.width, this.vertices[5] = i + e.height, this.vertices[6] = r, this.vertices[7] = i + e.height, this.invalidate(), this }, e.prototype.invalidate = function () { return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this }, e }(Vr), Kr = 0, Zr = function () { function t(t, e) { this.uniforms = t, this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = Kr++, this.static = !!e } return t.prototype.update = function () { this.dirtyId++ }, t.prototype.add = function (e, r, i) { this.uniforms[e] = new t(r, i) }, t.from = function (e, r) { return new t(e, r) }, t }(), Jr = function () { function t() { this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.sourceFrame = new xe, this.destinationFrame = new xe, this.filters = [] } return t.prototype.clear = function () { this.target = null, this.filters = null, this.renderTexture = null }, t }(), Qr = function (e) { function r(t) { var r = e.call(this, t) || this; return r.defaultFilterStack = [{}], r.texturePool = new Br, r.texturePool.setScreenSize(t.view), r.statePool = [], r.quad = new Wr, r.quadUv = new qr, r.tempRect = new xe, r.activeState = {}, r.globalUniforms = new Zr({ outputFrame: r.tempRect, inputSize: new Float32Array(4), inputPixel: new Float32Array(4), inputClamp: new Float32Array(4), resolution: 1, filterArea: new Float32Array(4), filterClamp: new Float32Array(4) }, !0), r.forceClear = !1, r.useMaxPadding = !1, r } return pr(r, e), r.prototype.push = function (t, e) { for (var r = this.renderer, i = this.defaultFilterStack, n = this.statePool.pop() || new Jr, o = e[0].resolution, s = e[0].padding, a = e[0].autoFit, h = e[0].legacy, u = 1; u < e.length; u++) { var l = e[u]; o = Math.min(o, l.resolution), s = this.useMaxPadding ? Math.max(s, l.padding) : s + l.padding, a = a && l.autoFit, h = h || l.legacy } 1 === i.length && (this.defaultFilterStack[0].renderTexture = r.renderTexture.current), i.push(n), n.resolution = o, n.legacy = h, n.target = t, n.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), n.sourceFrame.pad(s), a && n.sourceFrame.fit(this.renderer.renderTexture.sourceFrame), n.sourceFrame.ceil(o), n.renderTexture = this.getOptimalFilterTexture(n.sourceFrame.width, n.sourceFrame.height, o), n.filters = e, n.destinationFrame.width = n.renderTexture.width, n.destinationFrame.height = n.renderTexture.height; var c = this.tempRect; c.width = n.sourceFrame.width, c.height = n.sourceFrame.height, n.renderTexture.filterFrame = n.sourceFrame, r.renderTexture.bind(n.renderTexture, n.sourceFrame, c), r.renderTexture.clear() }, r.prototype.pop = function () { var e = this.defaultFilterStack, r = e.pop(), i = r.filters; this.activeState = r; var n = this.globalUniforms.uniforms; n.outputFrame = r.sourceFrame, n.resolution = r.resolution; var o = n.inputSize, s = n.inputPixel, a = n.inputClamp; if (o[0] = r.destinationFrame.width, o[1] = r.destinationFrame.height, o[2] = 1 / o[0], o[3] = 1 / o[1], s[0] = o[0] * r.resolution, s[1] = o[1] * r.resolution, s[2] = 1 / s[0], s[3] = 1 / s[1], a[0] = .5 * s[2], a[1] = .5 * s[3], a[2] = r.sourceFrame.width * o[2] - .5 * s[2], a[3] = r.sourceFrame.height * o[3] - .5 * s[3], r.legacy) { var h = n.filterArea; h[0] = r.destinationFrame.width, h[1] = r.destinationFrame.height, h[2] = r.sourceFrame.x, h[3] = r.sourceFrame.y, n.filterClamp = n.inputClamp } this.globalUniforms.update(); var u = e[e.length - 1]; if (r.renderTexture.framebuffer.multisample > 1 && this.renderer.framebuffer.blit(), 1 === i.length) i[0].apply(this, r.renderTexture, u.renderTexture, t.CLEAR_MODES.BLEND, r), this.returnFilterTexture(r.renderTexture); else { var l = r.renderTexture, c = this.getOptimalFilterTexture(l.width, l.height, r.resolution); c.filterFrame = l.filterFrame; var d = 0; for (d = 0; d < i.length - 1; ++d) { i[d].apply(this, l, c, t.CLEAR_MODES.CLEAR, r); var p = l; l = c, c = p } i[d].apply(this, l, u.renderTexture, t.CLEAR_MODES.BLEND, r), this.returnFilterTexture(l), this.returnFilterTexture(c) } r.clear(), this.statePool.push(r) }, r.prototype.bindAndClear = function (e, r) { if (void 0 === r && (r = t.CLEAR_MODES.CLEAR), e && e.filterFrame) { var i = this.tempRect; i.width = e.filterFrame.width, i.height = e.filterFrame.height, this.renderer.renderTexture.bind(e, e.filterFrame, i) } else this.renderer.renderTexture.bind(e); "boolean" == typeof r && (r = r ? t.CLEAR_MODES.CLEAR : t.CLEAR_MODES.BLEND, oe("5.2.1", "Use CLEAR_MODES when using clear applyFilter option")), (r === t.CLEAR_MODES.CLEAR || r === t.CLEAR_MODES.BLIT && this.forceClear) && this.renderer.renderTexture.clear() }, r.prototype.applyFilter = function (e, r, i, n) { var o = this.renderer; this.bindAndClear(i, n), e.uniforms.uSampler = r, e.uniforms.filterGlobals = this.globalUniforms, o.state.set(e.state), o.shader.bind(e), e.legacy ? (this.quadUv.map(r._frame, r.filterFrame), o.geometry.bind(this.quadUv), o.geometry.draw(t.DRAW_MODES.TRIANGLES)) : (o.geometry.bind(this.quad), o.geometry.draw(t.DRAW_MODES.TRIANGLE_STRIP)) }, r.prototype.calculateSpriteMatrix = function (t, e) { var r = this.activeState, i = r.sourceFrame, n = r.destinationFrame, o = e._texture.orig, s = t.set(n.width, 0, 0, n.height, i.x, i.y), a = e.worldTransform.copyTo(Ie.TEMP_MATRIX); return a.invert(), s.prepend(a), s.scale(1 / o.width, 1 / o.height), s.translate(e.anchor.x, e.anchor.y), s }, r.prototype.destroy = function () { this.texturePool.clear(!1) }, r.prototype.getOptimalFilterTexture = function (t, e, r) { return void 0 === r && (r = 1), this.texturePool.getOptimalTexture(t, e, r) }, r.prototype.getFilterTexture = function (t, e) { if ("number" == typeof t) { var r = t; t = e, e = r } t = t || this.activeState.renderTexture; var i = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution); return i.filterFrame = t.filterFrame, i }, r.prototype.returnFilterTexture = function (t) { this.texturePool.returnTexture(t) }, r.prototype.emptyPool = function () { this.texturePool.clear(!0) }, r.prototype.resize = function () { this.texturePool.setScreenSize(this.renderer.view) }, r }(Ar), $r = function () { function t(t) { this.renderer = t } return t.prototype.flush = function () { }, t.prototype.destroy = function () { this.renderer = null }, t.prototype.start = function () { }, t.prototype.stop = function () { this.flush() }, t.prototype.render = function (t) { }, t }(), ti = function (t) { function e(e) { var r = t.call(this, e) || this; return r.emptyRenderer = new $r(e), r.currentRenderer = r.emptyRenderer, r } return pr(e, t), e.prototype.setObjectRenderer = function (t) { this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start()) }, e.prototype.flush = function () { this.setObjectRenderer(this.emptyRenderer) }, e.prototype.reset = function () { this.setObjectRenderer(this.emptyRenderer) }, e.prototype.copyBoundTextures = function (t, e) { for (var r = this.renderer.texture.boundTextures, i = e - 1; i >= 0; --i)t[i] = r[i] || null, t[i] && (t[i]._batchLocation = i) }, e.prototype.boundArray = function (t, e, r, i) { for (var n = t.elements, o = t.ids, s = t.count, a = 0, h = 0; h < s; h++) { var u = n[h], l = u._batchLocation; if (l >= 0 && l < i && e[l] === u) o[h] = l; else for (; a < i;) { var c = e[a]; if (!c || c._batchEnabled !== r || c._batchLocation !== a) { o[h] = a, u._batchLocation = a, e[a] = u; break } a++ } } }, e }(Ar), ei = 0, ri = function (e) { function r(t) { var r = e.call(this, t) || this; return r.webGLVersion = 1, r.extensions = {}, r.supports = { uint32Indices: !1 }, r.handleContextLost = r.handleContextLost.bind(r), r.handleContextRestored = r.handleContextRestored.bind(r), t.view.addEventListener("webglcontextlost", r.handleContextLost, !1), t.view.addEventListener("webglcontextrestored", r.handleContextRestored, !1), r } return pr(r, e), Object.defineProperty(r.prototype, "isLost", { get: function () { return !this.gl || this.gl.isContextLost() }, enumerable: !1, configurable: !0 }), r.prototype.contextChange = function (t) { this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = ei++, t.isContextLost() && t.getExtension("WEBGL_lose_context") && t.getExtension("WEBGL_lose_context").restoreContext() }, r.prototype.initFromContext = function (t) { this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = ei++, this.renderer.runners.contextChange.emit(t) }, r.prototype.initFromOptions = function (t) { var e = this.createContext(this.renderer.view, t); this.initFromContext(e) }, r.prototype.createContext = function (e, r) { var i; if (D.PREFER_ENV >= t.ENV.WEBGL2 && (i = e.getContext("webgl2", r)), i) this.webGLVersion = 2; else if (this.webGLVersion = 1, !(i = e.getContext("webgl", r) || e.getContext("experimental-webgl", r))) throw new Error("This browser does not support WebGL. Try using the canvas renderer"); return this.gl = i, this.getExtensions(), this.gl }, r.prototype.getExtensions = function () { var t = this.gl; 1 === this.webGLVersion ? Object.assign(this.extensions, { drawBuffers: t.getExtension("WEBGL_draw_buffers"), depthTexture: t.getExtension("WEBGL_depth_texture"), loseContext: t.getExtension("WEBGL_lose_context"), vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"), anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"), uint32ElementIndex: t.getExtension("OES_element_index_uint"), floatTexture: t.getExtension("OES_texture_float"), floatTextureLinear: t.getExtension("OES_texture_float_linear"), textureHalfFloat: t.getExtension("OES_texture_half_float"), textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear") }) : 2 === this.webGLVersion && Object.assign(this.extensions, { anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"), colorBufferFloat: t.getExtension("EXT_color_buffer_float"), floatTextureLinear: t.getExtension("OES_texture_float_linear") }) }, r.prototype.handleContextLost = function (t) { t.preventDefault() }, r.prototype.handleContextRestored = function () { this.renderer.runners.contextChange.emit(this.gl) }, r.prototype.destroy = function () { var t = this.renderer.view; t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext() }, r.prototype.postrender = function () { this.renderer.renderingToScreen && this.gl.flush() }, r.prototype.validateContext = function (t) { var e = t.getContextAttributes(), r = "WebGL2RenderingContext" in window && t instanceof window.WebGL2RenderingContext; r && (this.webGLVersion = 2), e.stencil || console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly"); var i = r || !!t.getExtension("OES_element_index_uint"); this.supports.uint32Indices = i, i || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly") }, r }(Ar), ii = function () { return function (e) { this.framebuffer = e, this.stencil = null, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.multisample = t.MSAA_QUALITY.NONE, this.msaaBuffer = null, this.blitFramebuffer = null } }(), ni = new xe, oi = function (e) { function r(t) { var r = e.call(this, t) || this; return r.managedFramebuffers = [], r.unknownFramebuffer = new Mr(10, 10), r.msaaSamples = null, r } return pr(r, e), r.prototype.contextChange = function () { var e = this.gl = this.renderer.gl; if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new xe, this.hasMRT = !0, this.writeDepthTexture = !0, this.disposeAll(!0), 1 === this.renderer.context.webGLVersion) { var r = this.renderer.context.extensions.drawBuffers, i = this.renderer.context.extensions.depthTexture; D.PREFER_ENV === t.ENV.WEBGL_LEGACY && (r = null, i = null), r ? e.drawBuffers = function (t) { return r.drawBuffersWEBGL(t) } : (this.hasMRT = !1, e.drawBuffers = function () { }), i || (this.writeDepthTexture = !1) } else this.msaaSamples = e.getInternalformatParameter(e.RENDERBUFFER, e.RGBA8, e.SAMPLES) }, r.prototype.bind = function (t, e) { var r = this.gl; if (t) { var i = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t); this.current !== t && (this.current = t, r.bindFramebuffer(r.FRAMEBUFFER, i.framebuffer)), i.dirtyId !== t.dirtyId && (i.dirtyId = t.dirtyId, i.dirtyFormat !== t.dirtyFormat ? (i.dirtyFormat = t.dirtyFormat, this.updateFramebuffer(t)) : i.dirtySize !== t.dirtySize && (i.dirtySize = t.dirtySize, this.resizeFramebuffer(t))); for (var n = 0; n < t.colorTextures.length; n++) { var o = t.colorTextures[n]; this.renderer.texture.unbind(o.parentTextureArray || o) } t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, t.width, t.height) } else this.current && (this.current = null, r.bindFramebuffer(r.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height) }, r.prototype.setViewport = function (t, e, r, i) { var n = this.viewport; n.width === r && n.height === i && n.x === t && n.y === e || (n.x = t, n.y = e, n.width = r, n.height = i, this.gl.viewport(t, e, r, i)) }, Object.defineProperty(r.prototype, "size", { get: function () { return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height } }, enumerable: !1, configurable: !0 }), r.prototype.clear = function (e, r, i, n, o) { void 0 === o && (o = t.BUFFER_BITS.COLOR | t.BUFFER_BITS.DEPTH); var s = this.gl; s.clearColor(e, r, i, n), s.clear(o) }, r.prototype.initFramebuffer = function (t) { var e = this.gl, r = new ii(e.createFramebuffer()); return r.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = r, this.managedFramebuffers.push(t), t.disposeRunner.add(this), r }, r.prototype.resizeFramebuffer = function (t) { var e = this.gl, r = t.glFramebuffers[this.CONTEXT_UID]; r.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, r.stencil), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height)); for (var i = t.colorTextures, n = 0; n < i.length; n++)this.renderer.texture.bind(i[n], 0); t.depthTexture && this.renderer.texture.bind(t.depthTexture, 0) }, r.prototype.updateFramebuffer = function (t) { var e = this.gl, r = t.glFramebuffers[this.CONTEXT_UID], i = t.colorTextures.length; e.drawBuffers || (i = Math.min(i, 1)), r.multisample > 1 && (r.msaaBuffer = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, r.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.RGBA8, t.width, t.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, r.msaaBuffer)); for (var n = [], o = 0; o < i; o++)if (!(0 === o && r.multisample > 1)) { var s = t.colorTextures[o], a = s.parentTextureArray || s; this.renderer.texture.bind(a, 0), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + o, s.target, a._glTextures[this.CONTEXT_UID].texture, 0), n.push(e.COLOR_ATTACHMENT0 + o) } if ((n.length > 1 && e.drawBuffers(n), t.depthTexture) && this.writeDepthTexture) { var h = t.depthTexture; this.renderer.texture.bind(h, 0), e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, h._glTextures[this.CONTEXT_UID].texture, 0) } r.stencil || !t.stencil && !t.depth || (r.stencil = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, r.stencil), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height), t.depthTexture || e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, r.stencil)) }, r.prototype.detectSamples = function (e) { var r = this.msaaSamples, i = t.MSAA_QUALITY.NONE; if (e <= 1 || null === r) return i; for (var n = 0; n < r.length; n++)if (r[n] <= e) { i = r[n]; break } return 1 === i && (i = t.MSAA_QUALITY.NONE), i }, r.prototype.blit = function (t, e, r) { var i = this.current, n = this.renderer, o = this.gl, s = this.CONTEXT_UID; if (2 === n.context.webGLVersion && i) { var a = i.glFramebuffers[s]; if (a) { if (!t) { if (a.multisample <= 1) return; a.blitFramebuffer || (a.blitFramebuffer = new Mr(i.width, i.height), a.blitFramebuffer.addColorTexture(0, i.colorTextures[0])), (t = a.blitFramebuffer).width = i.width, t.height = i.height } e || ((e = ni).width = i.width, e.height = i.height), r || (r = e); var h = e.width === r.width && e.height === r.height; this.bind(t), o.bindFramebuffer(o.READ_FRAMEBUFFER, a.framebuffer), o.blitFramebuffer(e.x, e.y, e.width, e.height, r.x, r.y, r.width, r.height, o.COLOR_BUFFER_BIT, h ? o.NEAREST : o.LINEAR) } } }, r.prototype.disposeFramebuffer = function (t, e) { var r = t.glFramebuffers[this.CONTEXT_UID], i = this.gl; if (r) { delete t.glFramebuffers[this.CONTEXT_UID]; var n = this.managedFramebuffers.indexOf(t); n >= 0 && this.managedFramebuffers.splice(n, 1), t.disposeRunner.remove(this), e || (i.deleteFramebuffer(r.framebuffer), r.stencil && i.deleteRenderbuffer(r.stencil)) } }, r.prototype.disposeAll = function (t) { var e = this.managedFramebuffers; this.managedFramebuffers = []; for (var r = 0; r < e.length; r++)this.disposeFramebuffer(e[r], t) }, r.prototype.forceStencil = function () { var t = this.current; if (t) { var e = t.glFramebuffers[this.CONTEXT_UID]; if (e && !e.stencil) { t.enableStencil(); var r = t.width, i = t.height, n = this.gl, o = n.createRenderbuffer(); n.bindRenderbuffer(n.RENDERBUFFER, o), n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, r, i), e.stencil = o, n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, o) } } }, r.prototype.reset = function () { this.current = this.unknownFramebuffer, this.viewport = new xe }, r }(Ar), si = function () { return function (t) { this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0 } }(), ai = { 5126: 4, 5123: 2, 5121: 1 }, hi = function (e) { function r(t) { var r = e.call(this, t) || this; return r._activeGeometry = null, r._activeVao = null, r.hasVao = !0, r.hasInstance = !0, r.canUseUInt32ElementIndex = !1, r.managedGeometries = {}, r.managedBuffers = {}, r } return pr(r, e), r.prototype.contextChange = function () { this.disposeAll(!0); var e = this.gl = this.renderer.gl, r = this.renderer.context; if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, 2 !== r.webGLVersion) { var i = this.renderer.context.extensions.vertexArrayObject; D.PREFER_ENV === t.ENV.WEBGL_LEGACY && (i = null), i ? (e.createVertexArray = function () { return i.createVertexArrayOES() }, e.bindVertexArray = function (t) { return i.bindVertexArrayOES(t) }, e.deleteVertexArray = function (t) { return i.deleteVertexArrayOES(t) }) : (this.hasVao = !1, e.createVertexArray = function () { return null }, e.bindVertexArray = function () { return null }, e.deleteVertexArray = function () { return null }) } if (2 !== r.webGLVersion) { var n = e.getExtension("ANGLE_instanced_arrays"); n ? (e.vertexAttribDivisor = function (t, e) { return n.vertexAttribDivisorANGLE(t, e) }, e.drawElementsInstanced = function (t, e, r, i, o) { return n.drawElementsInstancedANGLE(t, e, r, i, o) }, e.drawArraysInstanced = function (t, e, r, i) { return n.drawArraysInstancedANGLE(t, e, r, i) }) : this.hasInstance = !1 } this.canUseUInt32ElementIndex = 2 === r.webGLVersion || !!r.extensions.uint32ElementIndex }, r.prototype.bind = function (t, e) { e = e || this.renderer.shader.shader; var r = this.gl, i = t.glVertexArrayObjects[this.CONTEXT_UID], n = !1; i || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = i = {}, n = !0); var o = i[e.program.id] || this.initGeometryVao(t, e.program, n); this._activeGeometry = t, this._activeVao !== o && (this._activeVao = o, this.hasVao ? r.bindVertexArray(o) : this.activateVao(t, e.program)), this.updateBuffers() }, r.prototype.reset = function () { this.unbind() }, r.prototype.updateBuffers = function () { for (var t = this._activeGeometry, e = this.gl, r = 0; r < t.buffers.length; r++) { var i = t.buffers[r], n = i._glBuffers[this.CONTEXT_UID]; if (i._updateID !== n.updateID) { n.updateID = i._updateID; var o = i.index ? e.ELEMENT_ARRAY_BUFFER : e.ARRAY_BUFFER; if (e.bindBuffer(o, n.buffer), this._boundBuffer = n, n.byteLength >= i.data.byteLength) e.bufferSubData(o, 0, i.data); else { var s = i.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW; n.byteLength = i.data.byteLength, e.bufferData(o, i.data, s) } } } }, r.prototype.checkCompatibility = function (t, e) { var r = t.attributes, i = e.attributeData; for (var n in i) if (!r[n]) throw new Error('shader and geometry incompatible, geometry missing the "' + n + '" attribute') }, r.prototype.getSignature = function (t, e) { var r = t.attributes, i = e.attributeData, n = ["g", t.id]; for (var o in r) i[o] && n.push(o); return n.join("-") }, r.prototype.initGeometryVao = function (t, e, r) { void 0 === r && (r = !0), this.checkCompatibility(t, e); var i = this.gl, n = this.CONTEXT_UID, o = this.getSignature(t, e), s = t.glVertexArrayObjects[this.CONTEXT_UID], a = s[o]; if (a) return s[e.id] = a, a; var h = t.buffers, u = t.attributes, l = {}, c = {}; for (var d in h) l[d] = 0, c[d] = 0; for (var d in u) !u[d].size && e.attributeData[d] ? u[d].size = e.attributeData[d].size : u[d].size || console.warn("PIXI Geometry attribute '" + d + "' size cannot be determined (likely the bound shader does not have the attribute)"), l[u[d].buffer] += u[d].size * ai[u[d].type]; for (var d in u) { var p = u[d], f = p.size; void 0 === p.stride && (l[p.buffer] === f * ai[p.type] ? p.stride = 0 : p.stride = l[p.buffer]), void 0 === p.start && (p.start = c[p.buffer], c[p.buffer] += f * ai[p.type]) } a = i.createVertexArray(), i.bindVertexArray(a); for (var m = 0; m < h.length; m++) { var v = h[m]; v._glBuffers[n] || (v._glBuffers[n] = new si(i.createBuffer()), this.managedBuffers[v.id] = v, v.disposeRunner.add(this)), r && v._glBuffers[n].refCount++ } return this.activateVao(t, e), this._activeVao = a, s[e.id] = a, s[o] = a, a }, r.prototype.disposeBuffer = function (t, e) { if (this.managedBuffers[t.id]) { delete this.managedBuffers[t.id]; var r = t._glBuffers[this.CONTEXT_UID], i = this.gl; t.disposeRunner.remove(this), r && (e || i.deleteBuffer(r.buffer), delete t._glBuffers[this.CONTEXT_UID]) } }, r.prototype.disposeGeometry = function (t, e) { if (this.managedGeometries[t.id]) { delete this.managedGeometries[t.id]; var r = t.glVertexArrayObjects[this.CONTEXT_UID], i = this.gl, n = t.buffers; if (t.disposeRunner.remove(this), r) { for (var o = 0; o < n.length; o++) { var s = n[o]._glBuffers[this.CONTEXT_UID]; s.refCount--, 0 !== s.refCount || e || this.disposeBuffer(n[o], e) } if (!e) for (var a in r) if ("g" === a[0]) { var h = r[a]; this._activeVao === h && this.unbind(), i.deleteVertexArray(h) } delete t.glVertexArrayObjects[this.CONTEXT_UID] } } }, r.prototype.disposeAll = function (t) { for (var e = Object.keys(this.managedGeometries), r = 0; r < e.length; r++)this.disposeGeometry(this.managedGeometries[e[r]], t); e = Object.keys(this.managedBuffers); for (r = 0; r < e.length; r++)this.disposeBuffer(this.managedBuffers[e[r]], t) }, r.prototype.activateVao = function (t, e) { var r = this.gl, i = this.CONTEXT_UID, n = t.buffers, o = t.attributes; t.indexBuffer && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t.indexBuffer._glBuffers[i].buffer); var s = null; for (var a in o) { var h = o[a], u = n[h.buffer]._glBuffers[i]; if (e.attributeData[a]) { s !== u && (r.bindBuffer(r.ARRAY_BUFFER, u.buffer), s = u); var l = e.attributeData[a].location; if (r.enableVertexAttribArray(l), r.vertexAttribPointer(l, h.size, h.type || r.FLOAT, h.normalized, h.stride, h.start), h.instance) { if (!this.hasInstance) throw new Error("geometry error, GPU Instancing is not supported on this device"); r.vertexAttribDivisor(l, 1) } } } }, r.prototype.draw = function (t, e, r, i) { var n = this.gl, o = this._activeGeometry; if (o.indexBuffer) { var s = o.indexBuffer.data.BYTES_PER_ELEMENT, a = 2 === s ? n.UNSIGNED_SHORT : n.UNSIGNED_INT; 2 === s || 4 === s && this.canUseUInt32ElementIndex ? o.instanced ? n.drawElementsInstanced(t, e || o.indexBuffer.data.length, a, (r || 0) * s, i || 1) : n.drawElements(t, e || o.indexBuffer.data.length, a, (r || 0) * s) : console.warn("unsupported index buffer type: uint32") } else o.instanced ? n.drawArraysInstanced(t, r, e || o.getSize(), i || 1) : n.drawArrays(t, r, e || o.getSize()); return this }, r.prototype.unbind = function () { this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null }, r }(Ar), ui = function () { function e(e) { void 0 === e && (e = null), this.type = t.MASK_TYPES.NONE, this.autoDetect = !0, this.maskObject = e || null, this.pooled = !1, this.isMaskData = !0, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._target = null } return e.prototype.reset = function () { this.pooled && (this.maskObject = null, this.type = t.MASK_TYPES.NONE, this.autoDetect = !0), this._target = null }, e.prototype.copyCountersOrReset = function (t) { t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null) }, e }(); function li(t, e, r) { var i = t.createShader(e); return t.shaderSource(i, r), t.compileShader(i), i } function ci(t, e, r, i) { var n = li(t, t.VERTEX_SHADER, e), o = li(t, t.FRAGMENT_SHADER, r), s = t.createProgram(); if (t.attachShader(s, n), t.attachShader(s, o), i) for (var a in i) t.bindAttribLocation(s, i[a], a); return t.linkProgram(s), t.getProgramParameter(s, t.LINK_STATUS) || (t.getShaderParameter(n, t.COMPILE_STATUS) || (console.warn(e), console.error(t.getShaderInfoLog(n))), t.getShaderParameter(o, t.COMPILE_STATUS) || (console.warn(r), console.error(t.getShaderInfoLog(o))), console.error("Pixi.js Error: Could not initialize shader."), console.error("gl.VALIDATE_STATUS", t.getProgramParameter(s, t.VALIDATE_STATUS)), console.error("gl.getError()", t.getError()), "" !== t.getProgramInfoLog(s) && console.warn("Pixi.js Warning: gl.getProgramInfoLog()", t.getProgramInfoLog(s)), t.deleteProgram(s), s = null), t.deleteShader(n), t.deleteShader(o), s } function di(t) { for (var e = new Array(t), r = 0; r < e.length; r++)e[r] = !1; return e } function pi(t, e) { switch (t) { case "float": return 0; case "vec2": return new Float32Array(2 * e); case "vec3": return new Float32Array(3 * e); case "vec4": return new Float32Array(4 * e); case "int": case "sampler2D": case "sampler2DArray": return 0; case "ivec2": return new Int32Array(2 * e); case "ivec3": return new Int32Array(3 * e); case "ivec4": return new Int32Array(4 * e); case "bool": return !1; case "bvec2": return di(2 * e); case "bvec3": return di(3 * e); case "bvec4": return di(4 * e); case "mat2": return new Float32Array([1, 0, 0, 1]); case "mat3": return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]); case "mat4": return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) }return null } var fi, mi = {}, vi = mi; function gi() { if (vi === mi || vi && vi.isContextLost()) { var e = document.createElement("canvas"), r = void 0; D.PREFER_ENV >= t.ENV.WEBGL2 && (r = e.getContext("webgl2", {})), r || ((r = e.getContext("webgl", {}) || e.getContext("experimental-webgl", {})) ? r.getExtension("WEBGL_draw_buffers") : r = null), vi = r } return vi } function yi(e, r, i) { if ("precision" !== e.substring(0, 9)) { var n = r; return r === t.PRECISION.HIGH && i !== t.PRECISION.HIGH && (n = t.PRECISION.MEDIUM), "precision " + n + " float;\n" + e } return i !== t.PRECISION.HIGH && "precision highp" === e.substring(0, 15) ? e.replace("precision highp", "precision mediump") : e } var _i = { float: 1, vec2: 2, vec3: 3, vec4: 4, int: 1, ivec2: 2, ivec3: 3, ivec4: 4, bool: 1, bvec2: 2, bvec3: 3, bvec4: 4, mat2: 4, mat3: 9, mat4: 16, sampler2D: 1 }; function xi(t) { return _i[t] } var bi = null, Ei = { FLOAT: "float", FLOAT_VEC2: "vec2", FLOAT_VEC3: "vec3", FLOAT_VEC4: "vec4", INT: "int", INT_VEC2: "ivec2", INT_VEC3: "ivec3", INT_VEC4: "ivec4", BOOL: "bool", BOOL_VEC2: "bvec2", BOOL_VEC3: "bvec3", BOOL_VEC4: "bvec4", FLOAT_MAT2: "mat2", FLOAT_MAT3: "mat3", FLOAT_MAT4: "mat4", SAMPLER_2D: "sampler2D", INT_SAMPLER_2D: "sampler2D", UNSIGNED_INT_SAMPLER_2D: "sampler2D", SAMPLER_CUBE: "samplerCube", INT_SAMPLER_CUBE: "samplerCube", UNSIGNED_INT_SAMPLER_CUBE: "samplerCube", SAMPLER_2D_ARRAY: "sampler2DArray", INT_SAMPLER_2D_ARRAY: "sampler2DArray", UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray" }; function Ti(t, e) { if (!bi) { var r = Object.keys(Ei); bi = {}; for (var i = 0; i < r.length; ++i) { var n = r[i]; bi[t[n]] = Ei[n] } } return bi[e] } var Si = [{ test: function (t) { return "float" === t.type && 1 === t.size }, code: function (t) { return '\n            if(uv["' + t + '"] !== ud["' + t + '"].value)\n            {\n                ud["' + t + '"].value = uv["' + t + '"]\n                gl.uniform1f(ud["' + t + '"].location, uv["' + t + '"])\n            }\n            ' } }, { test: function (t) { return ("sampler2D" === t.type || "samplerCube" === t.type || "sampler2DArray" === t.type) && 1 === t.size && !t.isArray }, code: function (t) { return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + t + '"], t);\n\n            if(ud["' + t + '"].value !== t)\n            {\n                ud["' + t + '"].value = t;\n                gl.uniform1i(ud["' + t + '"].location, t);\n; // eslint-disable-line max-len\n            }' } }, { test: function (t, e) { return "mat3" === t.type && 1 === t.size && void 0 !== e.a }, code: function (t) { return '\n            gl.uniformMatrix3fv(ud["' + t + '"].location, false, uv["' + t + '"].toArray(true));\n            ' } }, { test: function (t, e) { return "vec2" === t.type && 1 === t.size && void 0 !== e.x }, code: function (t) { return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + t + '"].location, v.x, v.y);\n                }' } }, { test: function (t) { return "vec2" === t.type && 1 === t.size }, code: function (t) { return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + t + '"].location, v[0], v[1]);\n                }\n            ' } }, { test: function (t, e) { return "vec4" === t.type && 1 === t.size && void 0 !== e.width }, code: function (t) { return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + t + '"].location, v.x, v.y, v.width, v.height)\n                }' } }, { test: function (t) { return "vec4" === t.type && 1 === t.size }, code: function (t) { return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + t + '"].location, v[0], v[1], v[2], v[3])\n                }' } }], wi = { float: "\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }", vec2: "\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }", vec3: "\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }", vec4: "gl.uniform4f(location, v[0], v[1], v[2], v[3])", int: "gl.uniform1i(location, v)", ivec2: "gl.uniform2i(location, v[0], v[1])", ivec3: "gl.uniform3i(location, v[0], v[1], v[2])", ivec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])", bool: "gl.uniform1i(location, v)", bvec2: "gl.uniform2i(location, v[0], v[1])", bvec3: "gl.uniform3i(location, v[0], v[1], v[2])", bvec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])", mat2: "gl.uniformMatrix2fv(location, false, v)", mat3: "gl.uniformMatrix3fv(location, false, v)", mat4: "gl.uniformMatrix4fv(location, false, v)", sampler2D: "gl.uniform1i(location, v)", samplerCube: "gl.uniform1i(location, v)", sampler2DArray: "gl.uniform1i(location, v)" }, Pi = { float: "gl.uniform1fv(location, v)", vec2: "gl.uniform2fv(location, v)", vec3: "gl.uniform3fv(location, v)", vec4: "gl.uniform4fv(location, v)", mat4: "gl.uniformMatrix4fv(location, false, v)", mat3: "gl.uniformMatrix3fv(location, false, v)", mat2: "gl.uniformMatrix2fv(location, false, v)", int: "gl.uniform1iv(location, v)", ivec2: "gl.uniform2iv(location, v)", ivec3: "gl.uniform3iv(location, v)", ivec4: "gl.uniform4iv(location, v)", bool: "gl.uniform1iv(location, v)", bvec2: "gl.uniform2iv(location, v)", bvec3: "gl.uniform3iv(location, v)", bvec4: "gl.uniform4iv(location, v)", sampler2D: "gl.uniform1iv(location, v)", samplerCube: "gl.uniform1iv(location, v)", sampler2DArray: "gl.uniform1iv(location, v)" }; var Ii, Ai = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n"); function Oi(t) { for (var e = "", r = 0; r < t; ++r)r > 0 && (e += "\nelse "), r < t - 1 && (e += "if(test == " + r + ".0){}"); return e } function Mi(t, e) { if (0 === t) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`"); for (var r = e.createShader(e.FRAGMENT_SHADER); ;) { var i = Ai.replace(/%forloop%/gi, Oi(t)); if (e.shaderSource(r, i), e.compileShader(r), e.getShaderParameter(r, e.COMPILE_STATUS)) break; t = t / 2 | 0 } return t } var Di = 0, Ci = {}, Ri = function () { function e(r, i, n) { void 0 === n && (n = "pixi-shader"), this.id = Di++, this.vertexSrc = r || e.defaultVertexSrc, this.fragmentSrc = i || e.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), "#version" !== this.vertexSrc.substring(0, 8) && (n = n.replace(/\s+/g, "-"), Ci[n] ? (Ci[n]++, n += "-" + Ci[n]) : Ci[n] = 1, this.vertexSrc = "#define SHADER_NAME " + n + "\n" + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + n + "\n" + this.fragmentSrc, this.vertexSrc = yi(this.vertexSrc, D.PRECISION_VERTEX, t.PRECISION.HIGH), this.fragmentSrc = yi(this.fragmentSrc, D.PRECISION_FRAGMENT, function () { if (!fi) { fi = t.PRECISION.MEDIUM; var e = gi(); if (e && e.getShaderPrecisionFormat) { var r = e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT); fi = r.precision ? t.PRECISION.HIGH : t.PRECISION.MEDIUM } } return fi }())), this.extractData(this.vertexSrc, this.fragmentSrc), this.glPrograms = {}, this.syncUniforms = null } return e.prototype.extractData = function (t, e) { var r = gi(); if (r) { var i = ci(r, t, e); this.attributeData = this.getAttributeData(i, r), this.uniformData = this.getUniformData(i, r), r.deleteProgram(i) } else this.uniformData = {}, this.attributeData = {} }, e.prototype.getAttributeData = function (t, e) { for (var r = {}, i = [], n = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), o = 0; o < n; o++) { var s = e.getActiveAttrib(t, o), a = Ti(e, s.type), h = { type: a, name: s.name, size: xi(a), location: 0 }; r[s.name] = h, i.push(h) } i.sort(function (t, e) { return t.name > e.name ? 1 : -1 }); for (o = 0; o < i.length; o++)i[o].location = o; return r }, e.prototype.getUniformData = function (t, e) { for (var r = {}, i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), n = 0; n < i; n++) { var o = e.getActiveUniform(t, n), s = o.name.replace(/\[.*?\]$/, ""), a = o.name.match(/\[.*?\]$/), h = Ti(e, o.type); r[s] = { type: h, size: o.size, isArray: a, value: pi(h, o.size) } } return r }, Object.defineProperty(e, "defaultVertexSrc", { get: function () { return "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n" }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "defaultFragmentSrc", { get: function () { return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}" }, enumerable: !1, configurable: !0 }), e.from = function (t, r, i) { var n = t + r, o = se[n]; return o || (se[n] = o = new e(t, r, i)), o }, e }(), Li = function () { function t(t, e) { for (var r in this.program = t, this.uniformGroup = e ? e instanceof Zr ? e : new Zr(e) : new Zr({}), t.uniformData) this.uniformGroup.uniforms[r] instanceof Array && (this.uniformGroup.uniforms[r] = new Float32Array(this.uniformGroup.uniforms[r])) } return t.prototype.checkUniformExists = function (t, e) { if (e.uniforms[t]) return !0; for (var r in e.uniforms) { var i = e.uniforms[r]; if (i.group && this.checkUniformExists(t, i)) return !0 } return !1 }, t.prototype.destroy = function () { this.uniformGroup = null }, Object.defineProperty(t.prototype, "uniforms", { get: function () { return this.uniformGroup.uniforms }, enumerable: !1, configurable: !0 }), t.from = function (e, r, i) { return new t(Ri.from(e, r), i) }, t }(), Ni = function () { function e() { this.data = 0, this.blendMode = t.BLEND_MODES.NORMAL, this.polygonOffset = 0, this.blend = !0 } return Object.defineProperty(e.prototype, "blend", { get: function () { return !!(1 & this.data) }, set: function (t) { !!(1 & this.data) !== t && (this.data ^= 1) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "offsets", { get: function () { return !!(2 & this.data) }, set: function (t) { !!(2 & this.data) !== t && (this.data ^= 2) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "culling", { get: function () { return !!(4 & this.data) }, set: function (t) { !!(4 & this.data) !== t && (this.data ^= 4) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "depthTest", { get: function () { return !!(8 & this.data) }, set: function (t) { !!(8 & this.data) !== t && (this.data ^= 8) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "clockwiseFrontFace", { get: function () { return !!(16 & this.data) }, set: function (t) { !!(16 & this.data) !== t && (this.data ^= 16) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "blendMode", { get: function () { return this._blendMode }, set: function (e) { this.blend = e !== t.BLEND_MODES.NONE, this._blendMode = e }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "polygonOffset", { get: function () { return this._polygonOffset }, set: function (t) { this.offsets = !!t, this._polygonOffset = t }, enumerable: !1, configurable: !0 }), e.for2d = function () { var t = new e; return t.depthTest = !1, t.blend = !0, t }, e }(), Fi = function (t) { function e(r, i, n) { var o = this, s = Ri.from(r || e.defaultVertexSrc, i || e.defaultFragmentSrc); return (o = t.call(this, s, n) || this).padding = 0, o.resolution = D.FILTER_RESOLUTION, o.enabled = !0, o.autoFit = !0, o.legacy = !!o.program.attributeData.aTextureCoord, o.state = new Ni, o } return pr(e, t), e.prototype.apply = function (t, e, r, i, n) { t.applyFilter(this, e, r, i) }, Object.defineProperty(e.prototype, "blendMode", { get: function () { return this.state.blendMode }, set: function (t) { this.state.blendMode = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "defaultVertexSrc", { get: function () { return "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n" }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "defaultFragmentSrc", { get: function () { return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n" }, enumerable: !1, configurable: !0 }), e }(Li), Bi = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n", Ui = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n", ki = new Ie, Xi = function () { function t(t, e) { this._texture = t, this.mapCoord = new Ie, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = void 0 === e ? .5 : e, this.isSimple = !1 } return Object.defineProperty(t.prototype, "texture", { get: function () { return this._texture }, set: function (t) { this._texture = t, this._textureID = -1 }, enumerable: !1, configurable: !0 }), t.prototype.multiplyUvs = function (t, e) { void 0 === e && (e = t); for (var r = this.mapCoord, i = 0; i < t.length; i += 2) { var n = t[i], o = t[i + 1]; e[i] = n * r.a + o * r.c + r.tx, e[i + 1] = n * r.b + o * r.d + r.ty } return e }, t.prototype.update = function (t) { var e = this._texture; if (!e || !e.valid) return !1; if (!t && this._textureID === e._updateID) return !1; this._textureID = e._updateID, this._updateID++; var r = e._uvs; this.mapCoord.set(r.x1 - r.x0, r.y1 - r.y0, r.x3 - r.x0, r.y3 - r.y0, r.x0, r.y0); var i = e.orig, n = e.trim; n && (ki.set(i.width / n.width, 0, 0, i.height / n.height, -n.x / n.width, -n.y / n.height), this.mapCoord.append(ki)); var o = e.baseTexture, s = this.uClampFrame, a = this.clampMargin / o.resolution, h = this.clampOffset; return s[0] = (e._frame.x + a + h) / o.width, s[1] = (e._frame.y + a + h) / o.height, s[2] = (e._frame.x + e._frame.width - a + h) / o.width, s[3] = (e._frame.y + e._frame.height - a + h) / o.height, this.uClampOffset[0] = h / o.realWidth, this.uClampOffset[1] = h / o.realHeight, this.isSimple = e._frame.width === o.width && e._frame.height === o.height && 0 === e.rotate, !0 }, t }(), ji = function (t) { function e(e) { var r = this, i = new Ie; return r = t.call(this, Bi, Ui) || this, e.renderable = !1, r.maskSprite = e, r.maskMatrix = i, r } return pr(e, t), e.prototype.apply = function (t, e, r, i) { var n = this.maskSprite, o = n._texture; o.valid && (o.uvMatrix || (o.uvMatrix = new Xi(o, 0)), o.uvMatrix.update(), this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o, this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, n).prepend(o.uvMatrix.mapCoord), this.uniforms.alpha = n.worldAlpha, this.uniforms.maskClamp = o.uvMatrix.uClampFrame, t.applyFilter(this, e, r, i)) }, e }(Fi), Hi = function (e) { function r(t) { var r = e.call(this, t) || this; return r.enableScissor = !1, r.alphaMaskPool = [], r.maskDataPool = [], r.maskStack = [], r.alphaMaskIndex = 0, r } return pr(r, e), r.prototype.setMaskStack = function (t) { this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t) }, r.prototype.push = function (e, r) { var i = r; if (!i.isMaskData) { var n = this.maskDataPool.pop() || new ui; n.pooled = !0, n.maskObject = r, i = n } switch (i.autoDetect && this.detect(i), i.copyCountersOrReset(this.maskStack[this.maskStack.length - 1]), i._target = e, i.type) { case t.MASK_TYPES.SCISSOR: this.maskStack.push(i), this.renderer.scissor.push(i); break; case t.MASK_TYPES.STENCIL: this.maskStack.push(i), this.renderer.stencil.push(i); break; case t.MASK_TYPES.SPRITE: i.copyCountersOrReset(null), this.pushSpriteMask(i), this.maskStack.push(i) } }, r.prototype.pop = function (e) { var r = this.maskStack.pop(); if (r && r._target === e) { switch (r.type) { case t.MASK_TYPES.SCISSOR: this.renderer.scissor.pop(); break; case t.MASK_TYPES.STENCIL: this.renderer.stencil.pop(r.maskObject); break; case t.MASK_TYPES.SPRITE: this.popSpriteMask() }r.reset(), r.pooled && this.maskDataPool.push(r) } }, r.prototype.detect = function (e) { var r = e.maskObject; if (r.isSprite) e.type = t.MASK_TYPES.SPRITE; else if (e.type = t.MASK_TYPES.STENCIL, this.enableScissor && r.isFastRect && r.isFastRect()) { var i = r.worldTransform, n = Math.atan2(i.b, i.a), o = Math.atan2(i.d, i.c); n = Math.round(n * (180 / Math.PI) * 100), o = ((o = Math.round(o * (180 / Math.PI) * 100) - n) % 18e3 + 18e3) % 18e3, 0 === (n = (n % 9e3 + 9e3) % 9e3) && 9e3 === o && (e.type = t.MASK_TYPES.SCISSOR) } }, r.prototype.pushSpriteMask = function (t) { var e = t.maskObject, r = t._target, i = this.alphaMaskPool[this.alphaMaskIndex]; i || (i = this.alphaMaskPool[this.alphaMaskIndex] = [new ji(e)]), i[0].resolution = this.renderer.resolution, i[0].maskSprite = e; var n = r.filterArea; r.filterArea = e.getBounds(!0), this.renderer.filter.push(r, i), r.filterArea = n, this.alphaMaskIndex++ }, r.prototype.popSpriteMask = function () { this.renderer.filter.pop(), this.alphaMaskIndex-- }, r }(Ar), Gi = function (t) { function e(e) { var r = t.call(this, e) || this; return r.maskStack = [], r.glConst = 0, r } return pr(e, t), e.prototype.getStackLength = function () { return this.maskStack.length }, e.prototype.setMaskStack = function (t) { var e = this.renderer.gl, r = this.getStackLength(); this.maskStack = t; var i = this.getStackLength(); i !== r && (0 === i ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent())) }, e.prototype._useCurrent = function () { }, e.prototype.destroy = function () { t.prototype.destroy.call(this), this.maskStack = null }, e }(Ar), Yi = function (t) { function e(e) { var r = t.call(this, e) || this; return r.glConst = WebGLRenderingContext.SCISSOR_TEST, r } return pr(e, t), e.prototype.getStackLength = function () { var t = this.maskStack[this.maskStack.length - 1]; return t ? t._scissorCounter : 0 }, e.prototype.push = function (t) { var e = t.maskObject; e.renderable = !0; var r = t._scissorRect, i = e.getBounds(!0), n = this.renderer.gl; e.renderable = !1, r ? i.fit(r) : n.enable(n.SCISSOR_TEST), t._scissorCounter++, t._scissorRect = i, this._useCurrent() }, e.prototype.pop = function () { var t = this.renderer.gl; this.getStackLength() > 0 ? this._useCurrent() : t.disable(t.SCISSOR_TEST) }, e.prototype._useCurrent = function () { var t = this.maskStack[this.maskStack.length - 1]._scissorRect, e = this.renderer.renderTexture.current, r = this.renderer.projection, i = r.transform, n = r.sourceFrame, o = r.destinationFrame, s = e ? e.resolution : this.renderer.resolution, a = (t.x - n.x) * s + o.x, h = (t.y - n.y) * s + o.y, u = t.width * s, l = t.height * s; i && (a += i.tx * s, h += i.ty * s), e || (h = this.renderer.height - l - h), this.renderer.gl.scissor(a, h, u, l) }, e }(Gi), zi = function (t) { function e(e) { var r = t.call(this, e) || this; return r.glConst = WebGLRenderingContext.STENCIL_TEST, r } return pr(e, t), e.prototype.getStackLength = function () { var t = this.maskStack[this.maskStack.length - 1]; return t ? t._stencilCounter : 0 }, e.prototype.push = function (t) { var e = t.maskObject, r = this.renderer.gl, i = t._stencilCounter; 0 === i && (this.renderer.framebuffer.forceStencil(), r.enable(r.STENCIL_TEST)), t._stencilCounter++, r.colorMask(!1, !1, !1, !1), r.stencilFunc(r.EQUAL, i, this._getBitwiseMask()), r.stencilOp(r.KEEP, r.KEEP, r.INCR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, this._useCurrent() }, e.prototype.pop = function (t) { var e = this.renderer.gl; 0 === this.getStackLength() ? (e.disable(e.STENCIL_TEST), e.clear(e.STENCIL_BUFFER_BIT), e.clearStencil(0)) : (e.colorMask(!1, !1, !1, !1), e.stencilOp(e.KEEP, e.KEEP, e.DECR), t.renderable = !0, t.render(this.renderer), this.renderer.batch.flush(), t.renderable = !1, this._useCurrent()) }, e.prototype._useCurrent = function () { var t = this.renderer.gl; t.colorMask(!0, !0, !0, !0), t.stencilFunc(t.EQUAL, this.getStackLength(), this._getBitwiseMask()), t.stencilOp(t.KEEP, t.KEEP, t.KEEP) }, e.prototype._getBitwiseMask = function () { return (1 << this.getStackLength()) - 1 }, e }(Gi), Vi = function (t) { function e(e) { var r = t.call(this, e) || this; return r.destinationFrame = null, r.sourceFrame = null, r.defaultFrame = null, r.projectionMatrix = new Ie, r.transform = null, r } return pr(e, t), e.prototype.update = function (t, e, r, i) { this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, r, i), this.transform && this.projectionMatrix.append(this.transform); var n = this.renderer; n.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, n.globalUniforms.update(), n.shader.shader && n.shader.syncUniformGroup(n.shader.shader.uniforms.globals) }, e.prototype.calculateProjection = function (t, e, r, i) { var n = this.projectionMatrix, o = i ? -1 : 1; n.identity(), n.a = 1 / e.width * 2, n.d = o * (1 / e.height * 2), n.tx = -1 - e.x * n.a, n.ty = -o - e.y * n.d }, e.prototype.setTransform = function (t) { }, e }(Ar), Wi = new xe, qi = new xe, Ki = new xe, Zi = function (t) { function e(e) { var r = t.call(this, e) || this; return r.clearColor = e._backgroundColorRgba, r.defaultMaskStack = [], r.current = null, r.sourceFrame = new xe, r.destinationFrame = new xe, r } return pr(e, t), e.prototype.bind = function (t, e, r) { void 0 === t && (t = null); var i, n, o, s = this.renderer; this.current = t, t ? (o = (i = t.baseTexture).resolution, e || (Wi.width = t.frame.width, Wi.height = t.frame.height, e = Wi), r || (qi.x = t.frame.x, qi.y = t.frame.y, qi.width = e.width, qi.height = e.height, r = qi), n = i.framebuffer) : (o = s.resolution, e || (Wi.width = s.screen.width, Wi.height = s.screen.height, e = Wi), r || ((r = Wi).width = e.width, r.height = e.height)), Ki.x = r.x * o, Ki.y = r.y * o, Ki.width = r.width * o, Ki.height = r.height * o, this.renderer.framebuffer.bind(n, Ki), this.renderer.projection.update(r, e, o, !n), t ? this.renderer.mask.setMaskStack(i.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(r) }, e.prototype.clear = function (t, e) { t = this.current ? t || this.current.baseTexture.clearColor : t || this.clearColor, this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e) }, e.prototype.resize = function () { this.bind(null) }, e.prototype.reset = function () { this.bind(null) }, e }(Ar), Ji = function () { return function () { } }(), Qi = function () { function t(t, e) { this.program = t, this.uniformData = e, this.uniformGroups = {} } return t.prototype.destroy = function () { this.uniformData = null, this.uniformGroups = null, this.program = null }, t }(), $i = 0, tn = { textureCount: 0 }, en = function (t) { function e(e) { var r = t.call(this, e) || this; return r.destroyed = !1, r.systemCheck(), r.gl = null, r.shader = null, r.program = null, r.cache = {}, r.id = $i++, r } return pr(e, t), e.prototype.systemCheck = function () { if (!function () { if ("boolean" == typeof Ii) return Ii; try { var t = new Function("param1", "param2", "param3", "return param1[param2] === param3;"); Ii = !0 === t({ a: "b" }, "a", "b") } catch (t) { Ii = !1 } return Ii }()) throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.") }, e.prototype.contextChange = function (t) { this.gl = t, this.reset() }, e.prototype.bind = function (t, e) { t.uniforms.globals = this.renderer.globalUniforms; var r = t.program, i = r.glPrograms[this.renderer.CONTEXT_UID] || this.generateShader(t); return this.shader = t, this.program !== r && (this.program = r, this.gl.useProgram(i.program)), e || (tn.textureCount = 0, this.syncUniformGroup(t.uniformGroup, tn)), i }, e.prototype.setUniforms = function (t) { var e = this.shader.program, r = e.glPrograms[this.renderer.CONTEXT_UID]; e.syncUniforms(r.uniformData, t, this.renderer) }, e.prototype.syncUniformGroup = function (t, e) { var r = this.getglProgram(); t.static && t.dirtyId === r.uniformGroups[t.id] || (r.uniformGroups[t.id] = t.dirtyId, this.syncUniforms(t, r, e)) }, e.prototype.syncUniforms = function (t, e, r) { (t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(e.uniformData, t.uniforms, this.renderer, r) }, e.prototype.createSyncGroups = function (t) { var e = this.getSignature(t, this.shader.program.uniformData); return this.cache[e] || (this.cache[e] = function (t, e) { var r = ["\n        var v = null;\n        var cv = null\n        var t = 0;\n        var gl = renderer.gl\n    "]; for (var i in t.uniforms) { var n = e[i]; if (n) { for (var o = t.uniforms[i], s = !1, a = 0; a < Si.length; a++)if (Si[a].test(n, o)) { r.push(Si[a].code(i, o)), s = !0; break } if (!s) { var h = (1 === n.size ? wi : Pi)[n.type].replace("location", 'ud["' + i + '"].location'); r.push('\n            cv = ud["' + i + '"].value;\n            v = uv["' + i + '"];\n            ' + h + ";") } } else t.uniforms[i].group && r.push('\n                    renderer.shader.syncUniformGroup(uv["' + i + '"], syncData);\n                ') } return new Function("ud", "uv", "renderer", "syncData", r.join("\n")) }(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id] }, e.prototype.getSignature = function (t, e) { var r = t.uniforms, i = []; for (var n in r) i.push(n), e[n] && i.push(e[n].type); return i.join("-") }, e.prototype.getglProgram = function () { return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null }, e.prototype.generateShader = function (t) { var e = this.gl, r = t.program, i = {}; for (var n in r.attributeData) i[n] = r.attributeData[n].location; var o = ci(e, r.vertexSrc, r.fragmentSrc, i), s = {}; for (var n in r.uniformData) { var a = r.uniformData[n]; s[n] = { location: e.getUniformLocation(o, n), value: pi(a.type, a.size) } } var h = new Qi(o, s); return r.glPrograms[this.renderer.CONTEXT_UID] = h, h }, e.prototype.reset = function () { this.program = null, this.shader = null }, e.prototype.destroy = function () { this.destroyed = !0 }, e }(Ar); var rn = 0, nn = 1, on = 2, sn = 3, an = 4, hn = function (e) { function r(r) { var i = e.call(this, r) || this; return i.gl = null, i.stateId = 0, i.polygonOffset = 0, i.blendMode = t.BLEND_MODES.NONE, i._blendEq = !1, i.map = [], i.map[rn] = i.setBlend, i.map[nn] = i.setOffset, i.map[on] = i.setCullFace, i.map[sn] = i.setDepthTest, i.map[an] = i.setFrontFace, i.checks = [], i.defaultState = new Ni, i.defaultState.blend = !0, i } return pr(r, e), r.prototype.contextChange = function (e) { this.gl = e, this.blendModes = function (e, r) { return void 0 === r && (r = []), r[t.BLEND_MODES.NORMAL] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.ADD] = [e.ONE, e.ONE], r[t.BLEND_MODES.MULTIPLY] = [e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.SCREEN] = [e.ONE, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.OVERLAY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.DARKEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.LIGHTEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.COLOR_DODGE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.COLOR_BURN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.HARD_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.SOFT_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.DIFFERENCE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.EXCLUSION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.HUE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.SATURATION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.COLOR] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.LUMINOSITY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.NONE] = [0, 0], r[t.BLEND_MODES.NORMAL_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.ADD_NPM] = [e.SRC_ALPHA, e.ONE, e.ONE, e.ONE], r[t.BLEND_MODES.SCREEN_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.SRC_IN] = [e.DST_ALPHA, e.ZERO], r[t.BLEND_MODES.SRC_OUT] = [e.ONE_MINUS_DST_ALPHA, e.ZERO], r[t.BLEND_MODES.SRC_ATOP] = [e.DST_ALPHA, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.DST_OVER] = [e.ONE_MINUS_DST_ALPHA, e.ONE], r[t.BLEND_MODES.DST_IN] = [e.ZERO, e.SRC_ALPHA], r[t.BLEND_MODES.DST_OUT] = [e.ZERO, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.DST_ATOP] = [e.ONE_MINUS_DST_ALPHA, e.SRC_ALPHA], r[t.BLEND_MODES.XOR] = [e.ONE_MINUS_DST_ALPHA, e.ONE_MINUS_SRC_ALPHA], r[t.BLEND_MODES.SUBTRACT] = [e.ONE, e.ONE, e.ONE, e.ONE, e.FUNC_REVERSE_SUBTRACT, e.FUNC_ADD], r }(e), this.set(this.defaultState), this.reset() }, r.prototype.set = function (t) { if (t = t || this.defaultState, this.stateId !== t.data) { for (var e = this.stateId ^ t.data, r = 0; e;)1 & e && this.map[r].call(this, !!(t.data & 1 << r)), e >>= 1, r++; this.stateId = t.data } for (r = 0; r < this.checks.length; r++)this.checks[r](this, t) }, r.prototype.forceState = function (t) { t = t || this.defaultState; for (var e = 0; e < this.map.length; e++)this.map[e].call(this, !!(t.data & 1 << e)); for (e = 0; e < this.checks.length; e++)this.checks[e](this, t); this.stateId = t.data }, r.prototype.setBlend = function (t) { this.updateCheck(r.checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND) }, r.prototype.setOffset = function (t) { this.updateCheck(r.checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL) }, r.prototype.setDepthTest = function (t) { this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST) }, r.prototype.setCullFace = function (t) { this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE) }, r.prototype.setFrontFace = function (t) { this.gl.frontFace(this.gl[t ? "CW" : "CCW"]) }, r.prototype.setBlendMode = function (t) { if (t !== this.blendMode) { this.blendMode = t; var e = this.blendModes[t], r = this.gl; 2 === e.length ? r.blendFunc(e[0], e[1]) : r.blendFuncSeparate(e[0], e[1], e[2], e[3]), 6 === e.length ? (this._blendEq = !0, r.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD)) } }, r.prototype.setPolygonOffset = function (t, e) { this.gl.polygonOffset(t, e) }, r.prototype.reset = function () { this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0) }, r.prototype.updateCheck = function (t, e) { var r = this.checks.indexOf(t); e && -1 === r ? this.checks.push(t) : e || -1 === r || this.checks.splice(r, 1) }, r.checkBlendMode = function (t, e) { t.setBlendMode(e.blendMode) }, r.checkPolygonOffset = function (t, e) { t.setPolygonOffset(1, e.polygonOffset) }, r }(Ar), un = function (e) { function r(t) { var r = e.call(this, t) || this; return r.count = 0, r.checkCount = 0, r.maxIdle = D.GC_MAX_IDLE, r.checkCountMax = D.GC_MAX_CHECK_COUNT, r.mode = D.GC_MODE, r } return pr(r, e), r.prototype.postrender = function () { this.renderer.renderingToScreen && (this.count++, this.mode !== t.GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run()))) }, r.prototype.run = function () { for (var t = this.renderer.texture, e = t.managedTextures, r = !1, i = 0; i < e.length; i++) { var n = e[i]; !n.framebuffer && this.count - n.touched > this.maxIdle && (t.destroyTexture(n, !0), e[i] = null, r = !0) } if (r) { var o = 0; for (i = 0; i < e.length; i++)null !== e[i] && (e[o++] = e[i]); e.length = o } }, r.prototype.unload = function (t) { var e = this.renderer.texture, r = t._texture; r && !r.framebuffer && e.destroyTexture(r); for (var i = t.children.length - 1; i >= 0; i--)this.unload(t.children[i]) }, r }(Ar), ln = function () { return function (t) { this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = 6408, this.internalFormat = 5121 } }(), cn = function (e) { function r(t) { var r = e.call(this, t) || this; return r.boundTextures = [], r.currentLocation = -1, r.managedTextures = [], r._unknownBoundTextures = !1, r.unknownTexture = new gr, r } return pr(r, e), r.prototype.contextChange = function () { var t = this.gl = this.renderer.gl; this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion; var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS); this.boundTextures.length = e; for (var r = 0; r < e; r++)this.boundTextures[r] = null; this.emptyTextures = {}; var i = new ln(t.createTexture()); t.bindTexture(t.TEXTURE_2D, i.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = i, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new ln(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture); for (r = 0; r < 6; r++)t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null); t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR); for (r = 0; r < this.boundTextures.length; r++)this.bind(null, r) }, r.prototype.bind = function (t, e) { void 0 === e && (e = 0); var r = this.gl; if (t) { if ((t = t.castToBaseTexture()).parentTextureArray) return; if (t.valid) { t.touched = this.renderer.textureGC.count; var i = t._glTextures[this.CONTEXT_UID] || this.initTexture(t); this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(t.target, i.texture)), i.dirtyId !== t.dirtyId && (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), this.updateTexture(t)), this.boundTextures[e] = t } } else this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(r.TEXTURE_2D, this.emptyTextures[r.TEXTURE_2D].texture), this.boundTextures[e] = null }, r.prototype.reset = function () { this._unknownBoundTextures = !0, this.currentLocation = -1; for (var t = 0; t < this.boundTextures.length; t++)this.boundTextures[t] = this.unknownTexture }, r.prototype.unbind = function (t) { var e = this.gl, r = this.boundTextures; if (this._unknownBoundTextures) { this._unknownBoundTextures = !1; for (var i = 0; i < r.length; i++)r[i] === this.unknownTexture && this.bind(null, i) } for (i = 0; i < r.length; i++)r[i] === t && (this.currentLocation !== i && (e.activeTexture(e.TEXTURE0 + i), this.currentLocation = i), e.bindTexture(t.target, this.emptyTextures[t.target].texture), r[i] = null) }, r.prototype.initTexture = function (t) { var e = new ln(this.gl.createTexture()); return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), e }, r.prototype.initTextureType = function (e, r) { if (r.internalFormat = e.format, r.type = e.type, 2 === this.webGLVersion) { var i = this.renderer.gl; e.type === i.FLOAT && e.format === i.RGBA && (r.internalFormat = i.RGBA32F), e.type === t.TYPES.HALF_FLOAT && (r.type = i.HALF_FLOAT), r.type === i.HALF_FLOAT && e.format === i.RGBA && (r.internalFormat = i.RGBA16F) } }, r.prototype.updateTexture = function (t) { var e = t._glTextures[this.CONTEXT_UID]; if (e) { var r = this.renderer; if (this.initTextureType(t, e), t.resource && t.resource.upload(r, t, e)); else { var i = t.realWidth, n = t.realHeight, o = r.gl; (e.width !== i || e.height !== n || e.dirtyId < 0) && (e.width = i, e.height = n, o.texImage2D(t.target, 0, e.internalFormat, i, n, 0, t.format, e.type, null)) } t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId } }, r.prototype.destroyTexture = function (t, e) { var r = this.gl; if ((t = t.castToBaseTexture())._glTextures[this.CONTEXT_UID] && (this.unbind(t), r.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) { var i = this.managedTextures.indexOf(t); -1 !== i && te(this.managedTextures, i, 1) } }, r.prototype.updateTextureStyle = function (e) { var r = e._glTextures[this.CONTEXT_UID]; r && (e.mipmap !== t.MIPMAP_MODES.POW2 && 2 === this.webGLVersion || e.isPowerOfTwo ? r.mipmap = e.mipmap >= 1 : r.mipmap = !1, 2 === this.webGLVersion || e.isPowerOfTwo ? r.wrapMode = e.wrapMode : r.wrapMode = t.WRAP_MODES.CLAMP, e.resource && e.resource.style(this.renderer, e, r) || this.setStyle(e, r), r.dirtyStyleId = e.dirtyStyleId) }, r.prototype.setStyle = function (e, r) { var i = this.gl; if (r.mipmap && i.generateMipmap(e.target), i.texParameteri(e.target, i.TEXTURE_WRAP_S, r.wrapMode), i.texParameteri(e.target, i.TEXTURE_WRAP_T, r.wrapMode), r.mipmap) { i.texParameteri(e.target, i.TEXTURE_MIN_FILTER, e.scaleMode === t.SCALE_MODES.LINEAR ? i.LINEAR_MIPMAP_LINEAR : i.NEAREST_MIPMAP_NEAREST); var n = this.renderer.context.extensions.anisotropicFiltering; if (n && e.anisotropicLevel > 0 && e.scaleMode === t.SCALE_MODES.LINEAR) { var o = Math.min(e.anisotropicLevel, i.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)); i.texParameterf(e.target, n.TEXTURE_MAX_ANISOTROPY_EXT, o) } } else i.texParameteri(e.target, i.TEXTURE_MIN_FILTER, e.scaleMode === t.SCALE_MODES.LINEAR ? i.LINEAR : i.NEAREST); i.texParameteri(e.target, i.TEXTURE_MAG_FILTER, e.scaleMode === t.SCALE_MODES.LINEAR ? i.LINEAR : i.NEAREST) }, r }(Ar), dn = { FilterSystem: Qr, BatchSystem: ti, ContextSystem: ri, FramebufferSystem: oi, GeometrySystem: hi, MaskSystem: Hi, ScissorSystem: Yi, StencilSystem: zi, ProjectionSystem: Vi, RenderTextureSystem: Zi, ShaderSystem: en, StateSystem: hn, TextureGCSystem: un, TextureSystem: cn }, pn = new Ie, fn = function (e) { function r(r, i) { void 0 === r && (r = t.RENDERER_TYPE.UNKNOWN); var n = e.call(this) || this; return (i = Object.assign({}, D.RENDER_OPTIONS, i)).roundPixels && (D.ROUND_PIXELS = i.roundPixels, oe("5.0.0", "Renderer roundPixels option is deprecated, please use PIXI.settings.ROUND_PIXELS", 2)), n.options = i, n.type = r, n.screen = new xe(0, 0, i.width, i.height), n.view = i.view || document.createElement("canvas"), n.resolution = i.resolution || D.RESOLUTION, n.transparent = i.transparent, n.autoDensity = i.autoDensity || i.autoResize || !1, n.preserveDrawingBuffer = i.preserveDrawingBuffer, n.clearBeforeRender = i.clearBeforeRender, n._backgroundColor = 0, n._backgroundColorRgba = [0, 0, 0, 0], n._backgroundColorString = "#000000", n.backgroundColor = i.backgroundColor || n._backgroundColor, n._lastObjectRendered = null, n.plugins = {}, n } return pr(r, e), r.prototype.initPlugins = function (t) { for (var e in t) this.plugins[e] = new t[e](this) }, Object.defineProperty(r.prototype, "width", { get: function () { return this.view.width }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "height", { get: function () { return this.view.height }, enumerable: !1, configurable: !0 }), r.prototype.resize = function (t, e) { this.screen.width = t, this.screen.height = e, this.view.width = t * this.resolution, this.view.height = e * this.resolution, this.autoDensity && (this.view.style.width = t + "px", this.view.style.height = e + "px"), this.emit("resize", t, e) }, r.prototype.generateTexture = function (t, e, r, i) { 0 === (i = i || t.getLocalBounds(null, !0)).width && (i.width = 1), 0 === i.height && (i.height = 1); var n = Fr.create({ width: 0 | i.width, height: 0 | i.height, scaleMode: e, resolution: r }); return pn.tx = -i.x, pn.ty = -i.y, this.render(t, n, !1, pn, !!t.parent), n }, r.prototype.destroy = function (e) { for (var r in this.plugins) this.plugins[r].destroy(), this.plugins[r] = null; e && this.view.parentNode && this.view.parentNode.removeChild(this.view); this.plugins = null, this.type = t.RENDERER_TYPE.UNKNOWN, this.view = null, this.screen = null, this._tempDisplayObjectParent = null, this.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null }, Object.defineProperty(r.prototype, "backgroundColor", { get: function () { return this._backgroundColor }, set: function (t) { this._backgroundColor = t, this._backgroundColorString = Xt(t), kt(t, this._backgroundColorRgba) }, enumerable: !1, configurable: !0 }), r }(C), mn = function (e) { function r(i) { var n = e.call(this, t.RENDERER_TYPE.WEBGL, i) || this; return i = n.options, n.gl = null, n.CONTEXT_UID = 0, n.runners = { destroy: new ur("destroy"), contextChange: new ur("contextChange"), reset: new ur("reset"), update: new ur("update"), postrender: new ur("postrender"), prerender: new ur("prerender"), resize: new ur("resize") }, n.globalUniforms = new Zr({ projectionMatrix: new Ie }, !0), n.addSystem(Hi, "mask").addSystem(ri, "context").addSystem(hn, "state").addSystem(en, "shader").addSystem(cn, "texture").addSystem(hi, "geometry").addSystem(oi, "framebuffer").addSystem(Yi, "scissor").addSystem(zi, "stencil").addSystem(Vi, "projection").addSystem(un, "textureGC").addSystem(Qr, "filter").addSystem(Zi, "renderTexture").addSystem(ti, "batch"), n.initPlugins(r.__plugins), i.context ? n.context.initFromContext(i.context) : n.context.initFromOptions({ alpha: !!n.transparent, antialias: i.antialias, premultipliedAlpha: n.transparent && "notMultiplied" !== n.transparent, stencil: !0, preserveDrawingBuffer: i.preserveDrawingBuffer, powerPreference: n.options.powerPreference }), n.renderingToScreen = !0, Bt(2 === n.context.webGLVersion ? "WebGL 2" : "WebGL 1"), n.resize(n.options.width, n.options.height), n } return pr(r, e), r.create = function (t) { if (Ut()) return new r(t); throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.') }, r.prototype.addSystem = function (t, e) { e || (e = t.name); var r = new t(this); if (this[e]) throw new Error('Whoops! The name "' + e + '" is already in use'); for (var i in this[e] = r, this.runners) this.runners[i].add(r); return this }, r.prototype.render = function (t, e, r, i, n) { if (this.renderingToScreen = !e, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = i, !this.context.isLost) { if (e || (this._lastObjectRendered = t), !n) { var o = t.enableTempParent(); t.updateTransform(), t.disableTempParent(o) } this.renderTexture.bind(e), this.batch.currentRenderer.start(), (void 0 !== r ? r : this.clearBeforeRender) && this.renderTexture.clear(), t.render(this), this.batch.currentRenderer.flush(), e && e.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender") } }, r.prototype.resize = function (t, r) { e.prototype.resize.call(this, t, r), this.runners.resize.emit(t, r) }, r.prototype.reset = function () { return this.runners.reset.emit(), this }, r.prototype.clear = function () { this.renderTexture.bind(), this.renderTexture.clear() }, r.prototype.destroy = function (t) { for (var r in this.runners.destroy.emit(), this.runners) this.runners[r].destroy(); e.prototype.destroy.call(this, t), this.gl = null }, r.registerPlugin = function (t, e) { r.__plugins = r.__plugins || {}, r.__plugins[t] = e }, r }(fn); function vn(t) { return mn.create(t) } var gn = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", yn = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n", _n = function () { return function () { this.texArray = null, this.blend = 0, this.type = t.DRAW_MODES.TRIANGLES, this.start = 0, this.size = 0, this.data = null } }(), xn = function () { function t() { this.elements = [], this.ids = [], this.count = 0 } return t.prototype.clear = function () { for (var t = 0; t < this.count; t++)this.elements[t] = null; this.count = 0 }, t }(), bn = function () { function t(t) { this.rawBinaryData = new ArrayBuffer(t), this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData) } return Object.defineProperty(t.prototype, "int8View", { get: function () { return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "uint8View", { get: function () { return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "int16View", { get: function () { return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "uint16View", { get: function () { return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "int32View", { get: function () { return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View }, enumerable: !1, configurable: !0 }), t.prototype.view = function (t) { return this[t + "View"] }, t.prototype.destroy = function () { this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null }, t.sizeOf = function (t) { switch (t) { case "int8": case "uint8": return 1; case "int16": case "uint16": return 2; case "int32": case "uint32": case "float32": return 4; default: throw new Error(t + " isn't a valid view type") } }, t }(), En = function (e) { function r(t) { var r = e.call(this, t) || this; return r.shaderGenerator = null, r.geometryClass = null, r.vertexSize = null, r.state = Ni.for2d(), r.size = 4 * D.SPRITE_BATCH_SIZE, r._vertexCount = 0, r._indexCount = 0, r._bufferedElements = [], r._bufferedTextures = [], r._bufferSize = 0, r._shader = null, r._packedGeometries = [], r._packedGeometryPoolSize = 2, r._flushId = 0, r._aBuffers = {}, r._iBuffers = {}, r.MAX_TEXTURES = 1, r.renderer.on("prerender", r.onPrerender, r), t.runners.contextChange.add(r), r._dcIndex = 0, r._aIndex = 0, r._iIndex = 0, r._attributeBuffer = null, r._indexBuffer = null, r._tempBoundTextures = [], r } return pr(r, e), r.prototype.contextChange = function () { var e = this.renderer.gl; D.PREFER_ENV === t.ENV.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), D.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = Mi(this.MAX_TEXTURES, e)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES); for (var r = 0; r < this._packedGeometryPoolSize; r++)this._packedGeometries[r] = new this.geometryClass; this.initFlushBuffers() }, r.prototype.initFlushBuffers = function () { for (var t = r._drawCallPool, e = r._textureArrayPool, i = this.size / 4, n = Math.floor(i / this.MAX_TEXTURES) + 1; t.length < i;)t.push(new _n); for (; e.length < n;)e.push(new xn); for (var o = 0; o < this.MAX_TEXTURES; o++)this._tempBoundTextures[o] = null }, r.prototype.onPrerender = function () { this._flushId = 0 }, r.prototype.render = function (t) { t._texture.valid && (this._vertexCount + t.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t.vertexData.length / 2, this._indexCount += t.indices.length, this._bufferedTextures[this._bufferSize] = t._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t) }, r.prototype.buildTexturesAndDrawCalls = function () { var t = this._bufferedTextures, e = this.MAX_TEXTURES, i = r._textureArrayPool, n = this.renderer.batch, o = this._tempBoundTextures, s = this.renderer.textureGC.count, a = ++gr._globalBatch, h = 0, u = i[0], l = 0; n.copyBoundTextures(o, e); for (var c = 0; c < this._bufferSize; ++c) { var d = t[c]; t[c] = null, d._batchEnabled !== a && (u.count >= e && (n.boundArray(u, o, a, e), this.buildDrawCalls(u, l, c), l = c, u = i[++h], ++a), d._batchEnabled = a, d.touched = s, u.elements[u.count++] = d) } u.count > 0 && (n.boundArray(u, o, a, e), this.buildDrawCalls(u, l, this._bufferSize), ++h, ++a); for (c = 0; c < o.length; c++)o[c] = null; gr._globalBatch = a }, r.prototype.buildDrawCalls = function (t, e, i) { var n = this._bufferedElements, o = this._attributeBuffer, s = this._indexBuffer, a = this.vertexSize, h = r._drawCallPool, u = this._dcIndex, l = this._aIndex, c = this._iIndex, d = h[u]; d.start = this._iIndex, d.texArray = t; for (var p = e; p < i; ++p) { var f = n[p], m = f._texture.baseTexture, v = Gt[m.alphaMode ? 1 : 0][f.blendMode]; n[p] = null, e < p && d.blend !== v && (d.size = c - d.start, e = p, (d = h[++u]).texArray = t, d.start = c), this.packInterleavedGeometry(f, o, s, l, c), l += f.vertexData.length / 2 * a, c += f.indices.length, d.blend = v } e < i && (d.size = c - d.start, ++u), this._dcIndex = u, this._aIndex = l, this._iIndex = c }, r.prototype.bindAndClearTexArray = function (t) { for (var e = this.renderer.texture, r = 0; r < t.count; r++)e.bind(t.elements[r], t.ids[r]), t.elements[r] = null; t.count = 0 }, r.prototype.updateGeometry = function () { var t = this._packedGeometries, e = this._attributeBuffer, r = this._indexBuffer; D.CAN_UPLOAD_SAME_BUFFER ? (t[this._flushId]._buffer.update(e.rawBinaryData), t[this._flushId]._indexBuffer.update(r), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, t[this._flushId] = new this.geometryClass), t[this._flushId]._buffer.update(e.rawBinaryData), t[this._flushId]._indexBuffer.update(r), this.renderer.geometry.bind(t[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++) }, r.prototype.drawBatches = function () { for (var t = this._dcIndex, e = this.renderer, i = e.gl, n = e.state, o = r._drawCallPool, s = null, a = 0; a < t; a++) { var h = o[a], u = h.texArray, l = h.type, c = h.size, d = h.start, p = h.blend; s !== u && (s = u, this.bindAndClearTexArray(u)), this.state.blendMode = p, n.set(this.state), i.drawElements(l, c, i.UNSIGNED_SHORT, 2 * d) } }, r.prototype.flush = function () { 0 !== this._vertexCount && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0) }, r.prototype.start = function () { this.renderer.state.set(this.state), this.renderer.shader.bind(this._shader), D.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]) }, r.prototype.stop = function () { this.flush() }, r.prototype.destroy = function () { for (var t = 0; t < this._packedGeometryPoolSize; t++)this._packedGeometries[t] && this._packedGeometries[t].destroy(); this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), e.prototype.destroy.call(this) }, r.prototype.getAttributeBuffer = function (t) { var e = Jt(Math.ceil(t / 8)), r = $t(e), i = 8 * e; this._aBuffers.length <= r && (this._iBuffers.length = r + 1); var n = this._aBuffers[i]; return n || (this._aBuffers[i] = n = new bn(i * this.vertexSize * 4)), n }, r.prototype.getIndexBuffer = function (t) { var e = Jt(Math.ceil(t / 12)), r = $t(e), i = 12 * e; this._iBuffers.length <= r && (this._iBuffers.length = r + 1); var n = this._iBuffers[r]; return n || (this._iBuffers[r] = n = new Uint16Array(i)), n }, r.prototype.packInterleavedGeometry = function (t, e, r, i, n) { for (var o = e.uint32View, s = e.float32View, a = i / this.vertexSize, h = t.uvs, u = t.indices, l = t.vertexData, c = t._texture.baseTexture._batchLocation, d = Math.min(t.worldAlpha, 1), p = d < 1 && t._texture.baseTexture.alphaMode ? Vt(t._tintRGB, d) : t._tintRGB + (255 * d << 24), f = 0; f < l.length; f += 2)s[i++] = l[f], s[i++] = l[f + 1], s[i++] = h[f], s[i++] = h[f + 1], o[i++] = p, s[i++] = c; for (f = 0; f < u.length; f++)r[n++] = a + u[f] }, r._drawCallPool = [], r._textureArrayPool = [], r }($r), Tn = function () { function t(t, e) { if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf("%count%") < 0) throw new Error('Fragment template must contain "%count%".'); if (e.indexOf("%forloop%") < 0) throw new Error('Fragment template must contain "%forloop%".') } return t.prototype.generateShader = function (t) { if (!this.programCache[t]) { for (var e = new Int32Array(t), r = 0; r < t; r++)e[r] = r; this.defaultGroupCache[t] = Zr.from({ uSamplers: e }, !0); var i = this.fragTemplate; i = (i = i.replace(/%count%/gi, "" + t)).replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new Ri(this.vertexSrc, i) } var n = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new Ie, default: this.defaultGroupCache[t] }; return new Li(this.programCache[t], n) }, t.prototype.generateSampleSrc = function (t) { var e = ""; e += "\n", e += "\n"; for (var r = 0; r < t; r++)r > 0 && (e += "\nelse "), r < t - 1 && (e += "if(vTextureId < " + r + ".5)"), e += "\n{", e += "\n\tcolor = texture2D(uSamplers[" + r + "], vTextureCoord);", e += "\n}"; return e += "\n", e += "\n" }, t }(), Sn = function (e) { function r(r) { void 0 === r && (r = !1); var i = e.call(this) || this; return i._buffer = new Xr(null, r, !1), i._indexBuffer = new Xr(null, r, !0), i.addAttribute("aVertexPosition", i._buffer, 2, !1, t.TYPES.FLOAT).addAttribute("aTextureCoord", i._buffer, 2, !1, t.TYPES.FLOAT).addAttribute("aColor", i._buffer, 4, !0, t.TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", i._buffer, 1, !0, t.TYPES.FLOAT).addIndex(i._indexBuffer), i } return pr(r, e), r }(Vr), wn = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n", Pn = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n", In = function () { function t() { } return t.create = function (t) { var e = Object.assign({ vertex: wn, fragment: Pn, geometryClass: Sn, vertexSize: 6 }, t), r = e.vertex, i = e.fragment, n = e.vertexSize, o = e.geometryClass; return function (t) { function e(e) { var s = t.call(this, e) || this; return s.shaderGenerator = new Tn(r, i), s.geometryClass = o, s.vertexSize = n, s } return pr(e, t), e }(En) }, Object.defineProperty(t, "defaultVertexSrc", { get: function () { return wn }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "defaultFragmentTemplate", { get: function () { return Pn }, enumerable: !1, configurable: !0 }), t }(), An = In.create(), On = function () { function t(e) { var r = this; e = Object.assign({ forceCanvas: !1 }, e), this.renderer = vn(e), this.stage = new Ge, t._plugins.forEach(function (t) { t.init.call(r, e) }) } return t.registerPlugin = function (e) { t._plugins.push(e) }, t.prototype.render = function () { this.renderer.render(this.stage) }, Object.defineProperty(t.prototype, "view", { get: function () { return this.renderer.view }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "screen", { get: function () { return this.renderer.screen }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function (e, r) { var i = this, n = t._plugins.slice(0); n.reverse(), n.forEach(function (t) { t.destroy.call(i) }), this.stage.destroy(r), this.stage = null, this.renderer.destroy(e), this.renderer = null }, t }(); On._plugins = []; var Mn = function () { function t() { } return t.init = function (t) { var e = this; Object.defineProperty(this, "resizeTo", { set: function (t) { window.removeEventListener("resize", this.queueResize), this._resizeTo = t, t && (window.addEventListener("resize", this.queueResize), this.resize()) }, get: function () { return this._resizeTo } }), this.queueResize = function () { e._resizeTo && (e.cancelResize(), e._resizeId = requestAnimationFrame(function () { return e.resize() })) }, this.cancelResize = function () { e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null) }, this.resize = function () { if (e._resizeTo) { var t, r; if (e.cancelResize(), e._resizeTo === window) t = window.innerWidth, r = window.innerHeight; else { var i = e._resizeTo; t = i.clientWidth, r = i.clientHeight } e.renderer.resize(t, r) } }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null }, t.destroy = function () { this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null }, t }(); On.registerPlugin(Mn); var Dn = new xe, Cn = function () { function t(t) { this.renderer = t, t.extract = this } return t.prototype.image = function (t, e, r) { var i = new Image; return i.src = this.base64(t, e, r), i }, t.prototype.base64 = function (t, e, r) { return this.canvas(t).toDataURL(e, r) }, t.prototype.canvas = function (e) { var r, i, n, o = this.renderer, s = !1, a = !1; e && (e instanceof Fr ? n = e : (n = this.renderer.generateTexture(e), a = !0)), n ? (r = n.baseTexture.resolution, i = n.frame, s = !1, o.renderTexture.bind(n)) : (r = this.renderer.resolution, s = !0, (i = Dn).width = this.renderer.width, i.height = this.renderer.height, o.renderTexture.bind(null)); var h = Math.floor(i.width * r + 1e-4), u = Math.floor(i.height * r + 1e-4), l = new ue(h, u, 1), c = new Uint8Array(4 * h * u), d = o.gl; d.readPixels(i.x * r, i.y * r, h, u, d.RGBA, d.UNSIGNED_BYTE, c); var p = l.context.getImageData(0, 0, h, u); if (t.arrayPostDivide(c, p.data), l.context.putImageData(p, 0, 0), s) { var f = new ue(l.width, l.height, 1); f.context.scale(1, -1), f.context.drawImage(l.canvas, 0, -u), l.destroy(), l = f } return a && n.destroy(!0), l.canvas }, t.prototype.pixels = function (e) { var r, i, n, o = this.renderer, s = !1; e && (e instanceof Fr ? n = e : (n = this.renderer.generateTexture(e), s = !0)), n ? (r = n.baseTexture.resolution, i = n.frame, o.renderTexture.bind(n)) : (r = o.resolution, (i = Dn).width = o.width, i.height = o.height, o.renderTexture.bind(null)); var a = i.width * r, h = i.height * r, u = new Uint8Array(4 * a * h), l = o.gl; return l.readPixels(i.x * r, i.y * r, a, h, l.RGBA, l.UNSIGNED_BYTE, u), s && n.destroy(!0), t.arrayPostDivide(u, u), u }, t.prototype.destroy = function () { this.renderer.extract = null, this.renderer = null }, t.arrayPostDivide = function (t, e) { for (var r = 0; r < t.length; r += 4) { var i = e[r + 3] = t[r + 3]; 0 !== i ? (e[r] = Math.round(Math.min(255 * t[r] / i, 255)), e[r + 1] = Math.round(Math.min(255 * t[r + 1] / i, 255)), e[r + 2] = Math.round(Math.min(255 * t[r + 2] / i, 255))) : (e[r] = t[r], e[r + 1] = t[r + 1], e[r + 2] = t[r + 2]) } }, t }(); var Rn = function (t, e) { if (t) { e = e || {}; for (var r = { key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"], q: { name: "queryKey", parser: /(?:^|&)([^&=]*)=?([^&]*)/g }, parser: { strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/, loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ } }, i = r.parser[e.strictMode ? "strict" : "loose"].exec(t), n = {}, o = 14; o--;)n[r.key[o]] = i[o] || ""; return n[r.q.name] = {}, n[r.key[12]].replace(r.q.parser, function (t, e, i) { e && (n[r.q.name][e] = i) }), n } }, Ln = function (t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t }(r(function (t, e) { Object.defineProperty(e, "__esModule", { value: !0 }); var r = function () { function t(t, e) { for (var r = 0; r < e.length; r++) { var i = e[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, r, i) { return r && t(e.prototype, r), i && t(e, i), e } }(); function i(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } var n = function () { function t(e, r, n) { void 0 === r && (r = !1), i(this, t), this._fn = e, this._once = r, this._thisArg = n, this._next = this._prev = this._owner = null } return r(t, [{ key: "detach", value: function () { return null !== this._owner && (this._owner.detach(this), !0) } }]), t }(); function o(t, e) { return t._head ? (t._tail._next = e, e._prev = t._tail, t._tail = e) : (t._head = e, t._tail = e), e._owner = t, e } var s = function () { function t() { i(this, t), this._head = this._tail = void 0 } return r(t, [{ key: "handlers", value: function () { var t = !(arguments.length <= 0 || void 0 === arguments[0]) && arguments[0], e = this._head; if (t) return !!e; for (var r = []; e;)r.push(e), e = e._next; return r } }, { key: "has", value: function (t) { if (!(t instanceof n)) throw new Error("MiniSignal#has(): First arg must be a MiniSignalBinding object."); return t._owner === this } }, { key: "dispatch", value: function () { var t = arguments, e = this._head; if (!e) return !1; for (; e;)e._once && this.detach(e), e._fn.apply(e._thisArg, t), e = e._next; return !0 } }, { key: "add", value: function (t) { var e = arguments.length <= 1 || void 0 === arguments[1] ? null : arguments[1]; if ("function" != typeof t) throw new Error("MiniSignal#add(): First arg must be a Function."); return o(this, new n(t, !1, e)) } }, { key: "once", value: function (t) { var e = arguments.length <= 1 || void 0 === arguments[1] ? null : arguments[1]; if ("function" != typeof t) throw new Error("MiniSignal#once(): First arg must be a Function."); return o(this, new n(t, !0, e)) } }, { key: "detach", value: function (t) { if (!(t instanceof n)) throw new Error("MiniSignal#detach(): First arg must be a MiniSignalBinding object."); return t._owner !== this ? this : (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, null === t._next && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null, this) } }, { key: "detachAll", value: function () { var t = this._head; if (!t) return this; for (this._head = this._tail = null; t;)t._owner = null, t = t._next; return this } }]), t }(); s.MiniSignalBinding = n, e.default = s, t.exports = e.default })); function Nn() { } function Fn(t, e, r, i) { var n = 0, o = t.length; !function s(a) { a || n === o ? r && r(a) : i ? setTimeout(function () { e(t[n++], s) }, 1) : e(t[n++], s) }() } function Bn(t) { return function () { if (null === t) throw new Error("Callback was already called."); var e = t; t = null, e.apply(this, arguments) } } function Un(t, e) { if (null == e) e = 1; else if (0 === e) throw new Error("Concurrency must not be zero"); var r = 0, i = { _tasks: [], concurrency: e, saturated: Nn, unsaturated: Nn, buffer: e / 4, empty: Nn, drain: Nn, error: Nn, started: !1, paused: !1, push: function (t, e) { n(t, !1, e) }, kill: function () { r = 0, i.drain = Nn, i.started = !1, i._tasks = [] }, unshift: function (t, e) { n(t, !0, e) }, process: function () { for (; !i.paused && r < i.concurrency && i._tasks.length;) { var e = i._tasks.shift(); 0 === i._tasks.length && i.empty(), (r += 1) === i.concurrency && i.saturated(), t(e.data, Bn(o(e))) } }, length: function () { return i._tasks.length }, running: function () { return r }, idle: function () { return i._tasks.length + r === 0 }, pause: function () { !0 !== i.paused && (i.paused = !0) }, resume: function () { if (!1 !== i.paused) { i.paused = !1; for (var t = 1; t <= i.concurrency; t++)i.process() } } }; function n(t, e, r) { if (null != r && "function" != typeof r) throw new Error("task callback must be a function"); if (i.started = !0, null == t && i.idle()) setTimeout(function () { return i.drain() }, 1); else { var n = { data: t, callback: "function" == typeof r ? r : Nn }; e ? i._tasks.unshift(n) : i._tasks.push(n), setTimeout(function () { return i.process() }, 1) } } function o(t) { return function () { r -= 1, t.callback.apply(t, arguments), null != arguments[0] && i.error(arguments[0], t.data), r <= i.concurrency - i.buffer && i.unsaturated(), i.idle() && i.drain(), i.process() } } return i } var kn = {}; function Xn(t, e) { for (var r = 0; r < e.length; r++) { var i = e[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function jn(t, e, r) { return e && Xn(t.prototype, e), r && Xn(t, r), t } var Hn = !(!window.XDomainRequest || "withCredentials" in new XMLHttpRequest), Gn = null; function Yn() { } var zn = function () { function t(e, r, i) { if ("string" != typeof e || "string" != typeof r) throw new Error("Both name and url are required for constructing a resource."); i = i || {}, this._flags = 0, this._setFlag(t.STATUS_FLAGS.DATA_URL, 0 === r.indexOf("data:")), this.name = e, this.url = r, this.extension = this._getExtension(), this.data = null, this.crossOrigin = !0 === i.crossOrigin ? "anonymous" : i.crossOrigin, this.timeout = i.timeout || 0, this.loadType = i.loadType || this._determineLoadType(), this.xhrType = i.xhrType, this.metadata = i.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = t.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = Yn, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new Ln, this.onProgress = new Ln, this.onComplete = new Ln, this.onAfterMiddleware = new Ln } t.setExtensionLoadType = function (e, r) { Vn(t._loadTypeMap, e, r) }, t.setExtensionXhrType = function (e, r) { Vn(t._xhrTypeMap, e, r) }; var e = t.prototype; return e.complete = function () { this._clearEvents(), this._finish() }, e.abort = function (e) { if (!this.error) { if (this.error = new Error(e), this._clearEvents(), this.xhr) this.xhr.abort(); else if (this.xdr) this.xdr.abort(); else if (this.data) if (this.data.src) this.data.src = t.EMPTY_GIF; else for (; this.data.firstChild;)this.data.removeChild(this.data.firstChild); this._finish() } }, e.load = function (e) { var r = this; if (!this.isLoading) if (this.isComplete) e && setTimeout(function () { return e(r) }, 1); else switch (e && this.onComplete.once(e), this._setFlag(t.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), !1 !== this.crossOrigin && "string" == typeof this.crossOrigin || (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) { case t.LOAD_TYPE.IMAGE: this.type = t.TYPE.IMAGE, this._loadElement("image"); break; case t.LOAD_TYPE.AUDIO: this.type = t.TYPE.AUDIO, this._loadSourceElement("audio"); break; case t.LOAD_TYPE.VIDEO: this.type = t.TYPE.VIDEO, this._loadSourceElement("video"); break; case t.LOAD_TYPE.XHR: default: Hn && this.crossOrigin ? this._loadXdr() : this._loadXhr() } }, e._hasFlag = function (t) { return 0 != (this._flags & t) }, e._setFlag = function (t, e) { this._flags = e ? this._flags | t : this._flags & ~t }, e._clearEvents = function () { clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null)) }, e._finish = function () { if (this.isComplete) throw new Error("Complete called again for an already completed resource."); this._setFlag(t.STATUS_FLAGS.COMPLETE, !0), this._setFlag(t.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this) }, e._loadElement = function (t) { this.metadata.loadElement ? this.data = this.metadata.loadElement : "image" === t && void 0 !== window.Image ? this.data = new Image : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout)) }, e._loadSourceElement = function (t) { if (this.metadata.loadElement ? this.data = this.metadata.loadElement : "audio" === t && void 0 !== window.Audio ? this.data = new Audio : this.data = document.createElement(t), null !== this.data) { if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource) if (navigator.isCocoonJS) this.data.src = Array.isArray(this.url) ? this.url[0] : this.url; else if (Array.isArray(this.url)) for (var e = this.metadata.mimeType, r = 0; r < this.url.length; ++r)this.data.appendChild(this._createSource(t, this.url[r], Array.isArray(e) ? e[r] : e)); else { var i = this.metadata.mimeType; this.data.appendChild(this._createSource(t, this.url, Array.isArray(i) ? i[0] : i)) } this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout)) } else this.abort("Unsupported element: " + t) }, e._loadXhr = function () { "string" != typeof this.xhrType && (this.xhrType = this._determineXhrType()); var e = this.xhr = new XMLHttpRequest; e.open("GET", this.url, !0), e.timeout = this.timeout, this.xhrType === t.XHR_RESPONSE_TYPE.JSON || this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT ? e.responseType = t.XHR_RESPONSE_TYPE.TEXT : e.responseType = this.xhrType, e.addEventListener("error", this._boundXhrOnError, !1), e.addEventListener("timeout", this._boundXhrOnTimeout, !1), e.addEventListener("abort", this._boundXhrOnAbort, !1), e.addEventListener("progress", this._boundOnProgress, !1), e.addEventListener("load", this._boundXhrOnLoad, !1), e.send() }, e._loadXdr = function () { "string" != typeof this.xhrType && (this.xhrType = this._determineXhrType()); var t = this.xhr = new XDomainRequest; t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open("GET", this.url, !0), setTimeout(function () { return t.send() }, 1) }, e._createSource = function (t, e, r) { r || (r = t + "/" + this._getExtension(e)); var i = document.createElement("source"); return i.src = e, i.type = r, i }, e._onError = function (t) { this.abort("Failed to load element using: " + t.target.nodeName) }, e._onProgress = function (t) { t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total) }, e._onTimeout = function () { this.abort("Load timed out.") }, e._xhrOnError = function () { var t = this.xhr; this.abort(Wn(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"') }, e._xhrOnTimeout = function () { var t = this.xhr; this.abort(Wn(t) + " Request timed out.") }, e._xhrOnAbort = function () { var t = this.xhr; this.abort(Wn(t) + " Request was aborted by the user.") }, e._xhrOnLoad = function () { var e = this.xhr, r = "", i = void 0 === e.status ? 200 : e.status; if ("" !== e.responseType && "text" !== e.responseType && void 0 !== e.responseType || (r = e.responseText), 0 === i && (r.length > 0 || e.responseType === t.XHR_RESPONSE_TYPE.BUFFER) ? i = 200 : 1223 === i && (i = 204), 2 === (i / 100 | 0)) { if (this.xhrType === t.XHR_RESPONSE_TYPE.TEXT) this.data = r, this.type = t.TYPE.TEXT; else if (this.xhrType === t.XHR_RESPONSE_TYPE.JSON) try { this.data = JSON.parse(r), this.type = t.TYPE.JSON } catch (t) { return void this.abort("Error trying to parse loaded json: " + t) } else if (this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT) try { if (window.DOMParser) { var n = new DOMParser; this.data = n.parseFromString(r, "text/xml") } else { var o = document.createElement("div"); o.innerHTML = r, this.data = o } this.type = t.TYPE.XML } catch (t) { return void this.abort("Error trying to parse loaded xml: " + t) } else this.data = e.response || r; this.complete() } else this.abort("[" + e.status + "] " + e.statusText + ": " + e.responseURL) }, e._determineCrossOrigin = function (t, e) { if (0 === t.indexOf("data:")) return ""; if (window.origin !== window.location.origin) return "anonymous"; e = e || window.location, Gn || (Gn = document.createElement("a")), Gn.href = t; var r = !(t = Rn(Gn.href, { strictMode: !0 })).port && "" === e.port || t.port === e.port, i = t.protocol ? t.protocol + ":" : ""; return t.host === e.hostname && r && i === e.protocol ? "" : "anonymous" }, e._determineXhrType = function () { return t._xhrTypeMap[this.extension] || t.XHR_RESPONSE_TYPE.TEXT }, e._determineLoadType = function () { return t._loadTypeMap[this.extension] || t.LOAD_TYPE.XHR }, e._getExtension = function () { var t = this.url, e = ""; if (this.isDataUrl) { var r = t.indexOf("/"); e = t.substring(r + 1, t.indexOf(";", r)) } else { var i = t.indexOf("?"), n = t.indexOf("#"), o = Math.min(i > -1 ? i : t.length, n > -1 ? n : t.length); e = (t = t.substring(0, o)).substring(t.lastIndexOf(".") + 1) } return e.toLowerCase() }, e._getMimeFromXhrType = function (e) { switch (e) { case t.XHR_RESPONSE_TYPE.BUFFER: return "application/octet-binary"; case t.XHR_RESPONSE_TYPE.BLOB: return "application/blob"; case t.XHR_RESPONSE_TYPE.DOCUMENT: return "application/xml"; case t.XHR_RESPONSE_TYPE.JSON: return "application/json"; case t.XHR_RESPONSE_TYPE.DEFAULT: case t.XHR_RESPONSE_TYPE.TEXT: default: return "text/plain" } }, jn(t, [{ key: "isDataUrl", get: function () { return this._hasFlag(t.STATUS_FLAGS.DATA_URL) } }, { key: "isComplete", get: function () { return this._hasFlag(t.STATUS_FLAGS.COMPLETE) } }, { key: "isLoading", get: function () { return this._hasFlag(t.STATUS_FLAGS.LOADING) } }]), t }(); function Vn(t, e, r) { e && 0 === e.indexOf(".") && (e = e.substring(1)), e && (t[e] = r) } function Wn(t) { return t.toString().replace("object ", "") } zn.STATUS_FLAGS = { NONE: 0, DATA_URL: 1, COMPLETE: 2, LOADING: 4 }, zn.TYPE = { UNKNOWN: 0, JSON: 1, XML: 2, IMAGE: 3, AUDIO: 4, VIDEO: 5, TEXT: 6 }, zn.LOAD_TYPE = { XHR: 1, IMAGE: 2, AUDIO: 3, VIDEO: 4 }, zn.XHR_RESPONSE_TYPE = { DEFAULT: "text", BUFFER: "arraybuffer", BLOB: "blob", DOCUMENT: "document", JSON: "json", TEXT: "text" }, zn._loadTypeMap = { gif: zn.LOAD_TYPE.IMAGE, png: zn.LOAD_TYPE.IMAGE, bmp: zn.LOAD_TYPE.IMAGE, jpg: zn.LOAD_TYPE.IMAGE, jpeg: zn.LOAD_TYPE.IMAGE, tif: zn.LOAD_TYPE.IMAGE, tiff: zn.LOAD_TYPE.IMAGE, webp: zn.LOAD_TYPE.IMAGE, tga: zn.LOAD_TYPE.IMAGE, svg: zn.LOAD_TYPE.IMAGE, "svg+xml": zn.LOAD_TYPE.IMAGE, mp3: zn.LOAD_TYPE.AUDIO, ogg: zn.LOAD_TYPE.AUDIO, wav: zn.LOAD_TYPE.AUDIO, mp4: zn.LOAD_TYPE.VIDEO, webm: zn.LOAD_TYPE.VIDEO }, zn._xhrTypeMap = { xhtml: zn.XHR_RESPONSE_TYPE.DOCUMENT, html: zn.XHR_RESPONSE_TYPE.DOCUMENT, htm: zn.XHR_RESPONSE_TYPE.DOCUMENT, xml: zn.XHR_RESPONSE_TYPE.DOCUMENT, tmx: zn.XHR_RESPONSE_TYPE.DOCUMENT, svg: zn.XHR_RESPONSE_TYPE.DOCUMENT, tsx: zn.XHR_RESPONSE_TYPE.DOCUMENT, gif: zn.XHR_RESPONSE_TYPE.BLOB, png: zn.XHR_RESPONSE_TYPE.BLOB, bmp: zn.XHR_RESPONSE_TYPE.BLOB, jpg: zn.XHR_RESPONSE_TYPE.BLOB, jpeg: zn.XHR_RESPONSE_TYPE.BLOB, tif: zn.XHR_RESPONSE_TYPE.BLOB, tiff: zn.XHR_RESPONSE_TYPE.BLOB, webp: zn.XHR_RESPONSE_TYPE.BLOB, tga: zn.XHR_RESPONSE_TYPE.BLOB, json: zn.XHR_RESPONSE_TYPE.JSON, text: zn.XHR_RESPONSE_TYPE.TEXT, txt: zn.XHR_RESPONSE_TYPE.TEXT, ttf: zn.XHR_RESPONSE_TYPE.BUFFER, otf: zn.XHR_RESPONSE_TYPE.BUFFER }, zn.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="; var qn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; var Kn = window.URL || window.webkitURL; var Zn = { caching: function (t, e) { var r = this; kn[t.url] ? (t.data = kn[t.url], t.complete()) : t.onComplete.once(function () { return kn[r.url] = r.data }), e() }, parsing: function (t, e) { if (t.data) { if (t.xhr && t.xhrType === zn.XHR_RESPONSE_TYPE.BLOB) if (window.Blob && "string" != typeof t.data) { if (0 === t.data.type.indexOf("image")) { var r = Kn.createObjectURL(t.data); return t.blob = t.data, t.data = new Image, t.data.src = r, t.type = zn.TYPE.IMAGE, void (t.data.onload = function () { Kn.revokeObjectURL(r), t.data.onload = null, e() }) } } else { var i = t.xhr.getResponseHeader("content-type"); if (i && 0 === i.indexOf("image")) return t.data = new Image, t.data.src = "data:" + i + ";base64," + function (t) { for (var e = "", r = 0; r < t.length;) { for (var i = [0, 0, 0], n = [0, 0, 0, 0], o = 0; o < i.length; ++o)r < t.length ? i[o] = 255 & t.charCodeAt(r++) : i[o] = 0; switch (n[0] = i[0] >> 2, n[1] = (3 & i[0]) << 4 | i[1] >> 4, n[2] = (15 & i[1]) << 2 | i[2] >> 6, n[3] = 63 & i[2], r - (t.length - 1)) { case 2: n[3] = 64, n[2] = 64; break; case 1: n[3] = 64 }for (var s = 0; s < n.length; ++s)e += qn.charAt(n[s]) } return e }(t.xhr.responseText), t.type = zn.TYPE.IMAGE, void (t.data.onload = function () { t.data.onload = null, e() }) } e() } else e() } }, Jn = /(#[\w-]+)?$/, Qn = function () { function t(e, r) { var i = this; void 0 === e && (e = ""), void 0 === r && (r = 10), this.baseUrl = e, this.progress = 0, this.loading = !1, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function (t, e) { return i._loadResource(t, e) }, this._queue = Un(this._boundLoadResource, r), this._queue.pause(), this.resources = {}, this.onProgress = new Ln, this.onError = new Ln, this.onLoad = new Ln, this.onStart = new Ln, this.onComplete = new Ln; for (var n = 0; n < t._defaultBeforeMiddleware.length; ++n)this.pre(t._defaultBeforeMiddleware[n]); for (var o = 0; o < t._defaultAfterMiddleware.length; ++o)this.use(t._defaultAfterMiddleware[o]) } var e = t.prototype; return e.add = function (t, e, r, i) { if (Array.isArray(t)) { for (var n = 0; n < t.length; ++n)this.add(t[n]); return this } if ("object" == typeof t && (i = e || t.callback || t.onComplete, r = t, e = t.url, t = t.name || t.key || t.url), "string" != typeof e && (i = r, r = e, e = t), "string" != typeof e) throw new Error("No url passed to add resource to loader."); if ("function" == typeof r && (i = r, r = null), this.loading && (!r || !r.parentResource)) throw new Error("Cannot add resources while the loader is running."); if (this.resources[t]) throw new Error('Resource named "' + t + '" already exists.'); if (e = this._prepareUrl(e), this.resources[t] = new zn(t, e, r), "function" == typeof i && this.resources[t].onAfterMiddleware.once(i), this.loading) { for (var o = r.parentResource, s = [], a = 0; a < o.children.length; ++a)o.children[a].isComplete || s.push(o.children[a]); var h = o.progressChunk * (s.length + 1) / (s.length + 2); o.children.push(this.resources[t]), o.progressChunk = h; for (var u = 0; u < s.length; ++u)s[u].progressChunk = h; this.resources[t].progressChunk = h } return this._queue.push(this.resources[t]), this }, e.pre = function (t) { return this._beforeMiddleware.push(t), this }, e.use = function (t) { return this._afterMiddleware.push(t), this }, e.reset = function () { for (var t in this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause(), this.resources) { var e = this.resources[t]; e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort() } return this.resources = {}, this }, e.load = function (t) { if ("function" == typeof t && this.onComplete.once(t), this.loading) return this; if (this._queue.idle()) this._onStart(), this._onComplete(); else { for (var e = 100 / this._queue._tasks.length, r = 0; r < this._queue._tasks.length; ++r)this._queue._tasks[r].data.progressChunk = e; this._onStart(), this._queue.resume() } return this }, e._prepareUrl = function (t) { var e, r = Rn(t, { strictMode: !0 }); if (e = r.protocol || !r.path || 0 === t.indexOf("//") ? t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && "/" !== t.charAt(0) ? this.baseUrl + "/" + t : this.baseUrl + t, this.defaultQueryString) { var i = Jn.exec(e)[0]; -1 !== (e = e.substr(0, e.length - i.length)).indexOf("?") ? e += "&" + this.defaultQueryString : e += "?" + this.defaultQueryString, e += i } return e }, e._loadResource = function (t, e) { var r = this; t._dequeue = e, Fn(this._beforeMiddleware, function (e, i) { e.call(r, t, function () { i(t.isComplete ? {} : null) }) }, function () { t.isComplete ? r._onLoad(t) : (t._onLoadBinding = t.onComplete.once(r._onLoad, r), t.load()) }, !0) }, e._onStart = function () { this.progress = 0, this.loading = !0, this.onStart.dispatch(this) }, e._onComplete = function () { this.progress = 100, this.loading = !1, this.onComplete.dispatch(this, this.resources) }, e._onLoad = function (t) { var e = this; t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), Fn(this._afterMiddleware, function (r, i) { r.call(e, t, i) }, function () { t.onAfterMiddleware.dispatch(t), e.progress = Math.min(100, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && 0 === e._resourcesParsing.length && e._onComplete() }, !0) }, jn(t, [{ key: "concurrency", get: function () { return this._queue.concurrency }, set: function (t) { this._queue.concurrency = t } }]), t }(); Qn._defaultBeforeMiddleware = [], Qn._defaultAfterMiddleware = [], Qn.pre = function (t) { return Qn._defaultBeforeMiddleware.push(t), Qn }, Qn.use = function (t) { return Qn._defaultAfterMiddleware.push(t), Qn }; var $n = zn, to = function (t, e) { return (to = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; var eo = function () { function t() { } return t.use = function (t, e) { t.data && t.type === zn.TYPE.IMAGE && (t.texture = Lr.fromLoader(t.data, t.url, t.name)), e() }, t }(), ro = function (t) { function e(r, i) { for (var n = t.call(this, r, i) || this, o = 0; o < e._plugins.length; ++o) { var s = e._plugins[o], a = s.pre, h = s.use; a && n.pre(a), h && n.use(h) } return n._protected = !1, n } return function (t, e) { function r() { this.constructor = t } to(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) }(e, t), e.prototype.destroy = function () { this._protected || this.reset() }, Object.defineProperty(e, "shared", { get: function () { var t = e._shared; return t || ((t = new e)._protected = !0, e._shared = t), t }, enumerable: !1, configurable: !0 }), e.registerPlugin = function (t) { return e._plugins.push(t), t.add && t.add(), e }, e._plugins = [], e }(Qn); ro.registerPlugin({ use: Zn.parsing }), ro.registerPlugin(eo); var io = function () { function t() { } return t.init = function (t) { t = Object.assign({ sharedLoader: !1 }, t), this.loader = t.sharedLoader ? ro.shared : new ro }, t.destroy = function () { this.loader && (this.loader.destroy(), this.loader = null) }, t }(), no = function (t, e) { return (no = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; function oo(t, e) { function r() { this.constructor = t } no(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var so, ao, ho = function (e) { function r(r, i, n, o) { void 0 === r && (r = 1500), void 0 === n && (n = 16384), void 0 === o && (o = !1); var s = e.call(this) || this; return n > 16384 && (n = 16384), s._properties = [!1, !0, !1, !1, !1], s._maxSize = r, s._batchSize = n, s._buffers = null, s._bufferUpdateIDs = [], s._updateID = 0, s.interactiveChildren = !1, s.blendMode = t.BLEND_MODES.NORMAL, s.autoResize = o, s.roundPixels = !0, s.baseTexture = null, s.setProperties(i), s._tint = 0, s.tintRgb = new Float32Array(4), s.tint = 16777215, s } return oo(r, e), r.prototype.setProperties = function (t) { t && (this._properties[0] = "vertices" in t || "scale" in t ? !!t.vertices || !!t.scale : this._properties[0], this._properties[1] = "position" in t ? !!t.position : this._properties[1], this._properties[2] = "rotation" in t ? !!t.rotation : this._properties[2], this._properties[3] = "uvs" in t ? !!t.uvs : this._properties[3], this._properties[4] = "tint" in t || "alpha" in t ? !!t.tint || !!t.alpha : this._properties[4]) }, r.prototype.updateTransform = function () { this.displayObjectUpdateTransform() }, Object.defineProperty(r.prototype, "tint", { get: function () { return this._tint }, set: function (t) { this._tint = t, kt(t, this.tintRgb) }, enumerable: !1, configurable: !0 }), r.prototype.render = function (t) { var e = this; this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable && (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", function () { return e.onChildrenChange(0) })), t.batch.setObjectRenderer(t.plugins.particle), t.plugins.particle.render(this)) }, r.prototype.onChildrenChange = function (t) { for (var e = Math.floor(t / this._batchSize); this._bufferUpdateIDs.length < e;)this._bufferUpdateIDs.push(0); this._bufferUpdateIDs[e] = ++this._updateID }, r.prototype.dispose = function () { if (this._buffers) { for (var t = 0; t < this._buffers.length; ++t)this._buffers[t].destroy(); this._buffers = null } }, r.prototype.destroy = function (t) { e.prototype.destroy.call(this, t), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null }, r }(Ge), uo = function () { function e(e, r, i) { this.geometry = new Vr, this.indexBuffer = null, this.size = i, this.dynamicProperties = [], this.staticProperties = []; for (var n = 0; n < e.length; ++n) { var o = e[n]; o = { attributeName: o.attributeName, size: o.size, uploadFunction: o.uploadFunction, type: o.type || t.TYPES.FLOAT, offset: o.offset }, r[n] ? this.dynamicProperties.push(o) : this.staticProperties.push(o) } this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers() } return e.prototype.initBuffers = function () { var e = this.geometry, r = 0; this.indexBuffer = new Xr(qt(this.size), !0, !0), e.addIndex(this.indexBuffer), this.dynamicStride = 0; for (var i = 0; i < this.dynamicProperties.length; ++i) { (a = this.dynamicProperties[i]).offset = r, r += a.size, this.dynamicStride += a.size } var n = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4); this.dynamicData = new Float32Array(n), this.dynamicDataUint32 = new Uint32Array(n), this.dynamicBuffer = new Xr(this.dynamicData, !1, !1); var o = 0; this.staticStride = 0; for (i = 0; i < this.staticProperties.length; ++i) { (a = this.staticProperties[i]).offset = o, o += a.size, this.staticStride += a.size } var s = new ArrayBuffer(this.size * this.staticStride * 4 * 4); this.staticData = new Float32Array(s), this.staticDataUint32 = new Uint32Array(s), this.staticBuffer = new Xr(this.staticData, !0, !1); for (i = 0; i < this.dynamicProperties.length; ++i) { var a = this.dynamicProperties[i]; e.addAttribute(a.attributeName, this.dynamicBuffer, 0, a.type === t.TYPES.UNSIGNED_BYTE, a.type, 4 * this.dynamicStride, 4 * a.offset) } for (i = 0; i < this.staticProperties.length; ++i) { a = this.staticProperties[i]; e.addAttribute(a.attributeName, this.staticBuffer, 0, a.type === t.TYPES.UNSIGNED_BYTE, a.type, 4 * this.staticStride, 4 * a.offset) } }, e.prototype.uploadDynamic = function (e, r, i) { for (var n = 0; n < this.dynamicProperties.length; n++) { var o = this.dynamicProperties[n]; o.uploadFunction(e, r, i, o.type === t.TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, o.offset) } this.dynamicBuffer._updateID++ }, e.prototype.uploadStatic = function (e, r, i) { for (var n = 0; n < this.staticProperties.length; n++) { var o = this.staticProperties[n]; o.uploadFunction(e, r, i, o.type === t.TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, o.offset) } this.staticBuffer._updateID++ }, e.prototype.destroy = function () { this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy() }, e }(), lo = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}", co = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n", po = function (e) { function r(r) { var i = e.call(this, r) || this; return i.shader = null, i.properties = null, i.tempMatrix = new Ie, i.properties = [{ attributeName: "aVertexPosition", size: 2, uploadFunction: i.uploadVertices, offset: 0 }, { attributeName: "aPositionCoord", size: 2, uploadFunction: i.uploadPosition, offset: 0 }, { attributeName: "aRotation", size: 1, uploadFunction: i.uploadRotation, offset: 0 }, { attributeName: "aTextureCoord", size: 2, uploadFunction: i.uploadUvs, offset: 0 }, { attributeName: "aColor", size: 1, type: t.TYPES.UNSIGNED_BYTE, uploadFunction: i.uploadTint, offset: 0 }], i.shader = Li.from(co, lo, {}), i.state = Ni.for2d(), i } return oo(r, e), r.prototype.render = function (t) { var e = t.children, r = t._maxSize, i = t._batchSize, n = this.renderer, o = e.length; if (0 !== o) { o > r && !t.autoResize && (o = r); var s = t._buffers; s || (s = t._buffers = this.generateBuffers(t)); var a = e[0]._texture.baseTexture; this.state.blendMode = Yt(t.blendMode, a.alphaMode), n.state.set(this.state); var h = n.gl, u = t.worldTransform.copyTo(this.tempMatrix); u.prepend(n.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = u.toArray(!0), this.shader.uniforms.uColor = zt(t.tintRgb, t.worldAlpha, this.shader.uniforms.uColor, a.alphaMode), this.shader.uniforms.uSampler = a, this.renderer.shader.bind(this.shader); for (var l = !1, c = 0, d = 0; c < o; c += i, d += 1) { var p = o - c; p > i && (p = i), d >= s.length && s.push(this._generateOneMoreBuffer(t)); var f = s[d]; f.uploadDynamic(e, c, p); var m = t._bufferUpdateIDs[d] || 0; (l = l || f._updateID < m) && (f._updateID = t._updateID, f.uploadStatic(e, c, p)), n.geometry.bind(f.geometry), h.drawElements(h.TRIANGLES, 6 * p, h.UNSIGNED_SHORT, 0) } } }, r.prototype.generateBuffers = function (t) { for (var e = [], r = t._maxSize, i = t._batchSize, n = t._properties, o = 0; o < r; o += i)e.push(new uo(this.properties, n, i)); return e }, r.prototype._generateOneMoreBuffer = function (t) { var e = t._batchSize, r = t._properties; return new uo(this.properties, r, e) }, r.prototype.uploadVertices = function (t, e, r, i, n, o) { for (var s = 0, a = 0, h = 0, u = 0, l = 0; l < r; ++l) { var c = t[e + l], d = c._texture, p = c.scale.x, f = c.scale.y, m = d.trim, v = d.orig; m ? (s = (a = m.x - c.anchor.x * v.width) + m.width, h = (u = m.y - c.anchor.y * v.height) + m.height) : (s = v.width * (1 - c.anchor.x), a = v.width * -c.anchor.x, h = v.height * (1 - c.anchor.y), u = v.height * -c.anchor.y), i[o] = a * p, i[o + 1] = u * f, i[o + n] = s * p, i[o + n + 1] = u * f, i[o + 2 * n] = s * p, i[o + 2 * n + 1] = h * f, i[o + 3 * n] = a * p, i[o + 3 * n + 1] = h * f, o += 4 * n } }, r.prototype.uploadPosition = function (t, e, r, i, n, o) { for (var s = 0; s < r; s++) { var a = t[e + s].position; i[o] = a.x, i[o + 1] = a.y, i[o + n] = a.x, i[o + n + 1] = a.y, i[o + 2 * n] = a.x, i[o + 2 * n + 1] = a.y, i[o + 3 * n] = a.x, i[o + 3 * n + 1] = a.y, o += 4 * n } }, r.prototype.uploadRotation = function (t, e, r, i, n, o) { for (var s = 0; s < r; s++) { var a = t[e + s].rotation; i[o] = a, i[o + n] = a, i[o + 2 * n] = a, i[o + 3 * n] = a, o += 4 * n } }, r.prototype.uploadUvs = function (t, e, r, i, n, o) { for (var s = 0; s < r; ++s) { var a = t[e + s]._texture._uvs; a ? (i[o] = a.x0, i[o + 1] = a.y0, i[o + n] = a.x1, i[o + n + 1] = a.y1, i[o + 2 * n] = a.x2, i[o + 2 * n + 1] = a.y2, i[o + 3 * n] = a.x3, i[o + 3 * n + 1] = a.y3, o += 4 * n) : (i[o] = 0, i[o + 1] = 0, i[o + n] = 0, i[o + n + 1] = 0, i[o + 2 * n] = 0, i[o + 2 * n + 1] = 0, i[o + 3 * n] = 0, i[o + 3 * n + 1] = 0, o += 4 * n) } }, r.prototype.uploadTint = function (t, e, r, i, n, o) { for (var s = 0; s < r; ++s) { var a = t[e + s], h = a._texture.baseTexture.alphaMode > 0, u = a.alpha, l = u < 1 && h ? Vt(a._tintRGB, u) : a._tintRGB + (255 * u << 24); i[o] = l, i[o + n] = l, i[o + 2 * n] = l, i[o + 3 * n] = l, o += 4 * n } }, r.prototype.destroy = function () { e.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null }, r }($r); (so = t.LINE_JOIN || (t.LINE_JOIN = {})).MITER = "miter", so.BEVEL = "bevel", so.ROUND = "round", (ao = t.LINE_CAP || (t.LINE_CAP = {})).BUTT = "butt", ao.ROUND = "round", ao.SQUARE = "square"; var fo = { adaptive: !0, maxLength: 10, minSegments: 8, maxSegments: 2048, epsilon: 1e-4, _segmentsCount: function (t, e) { if (void 0 === e && (e = 20), !this.adaptive || !t || isNaN(t)) return e; var r = Math.ceil(t / this.maxLength); return r < this.minSegments ? r = this.minSegments : r > this.maxSegments && (r = this.maxSegments), r } }, mo = function () { function t() { this.color = 16777215, this.alpha = 1, this.texture = Lr.WHITE, this.matrix = null, this.visible = !1, this.reset() } return t.prototype.clone = function () { var e = new t; return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e }, t.prototype.reset = function () { this.color = 16777215, this.alpha = 1, this.texture = Lr.WHITE, this.matrix = null, this.visible = !1 }, t.prototype.destroy = function () { this.texture = null, this.matrix = null }, t }(), vo = function (t, e) { return (vo = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; function go(t, e) { function r() { this.constructor = t } vo(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var yo = { build: function (t) { t.points = t.shape.points.slice() }, triangulate: function (t, e) { var r = t.points, i = t.holes, n = e.points, o = e.indices; if (r.length >= 6) { for (var s = [], a = 0; a < i.length; a++) { var h = i[a]; s.push(r.length / 2), r = r.concat(h.points) } var u = R(r, s, 2); if (!u) return; var l = n.length / 2; for (a = 0; a < u.length; a += 3)o.push(u[a] + l), o.push(u[a + 1] + l), o.push(u[a + 2] + l); for (a = 0; a < r.length; a++)n.push(r[a]) } } }, _o = { build: function (e) { var r, i, n = e.shape, o = e.points, s = n.x, a = n.y; if (o.length = 0, e.type === t.SHAPES.CIRC) r = n.radius, i = n.radius; else { var h = e.shape; r = h.width, i = h.height } if (0 !== r && 0 !== i) { var u = Math.floor(30 * Math.sqrt(n.radius)) || Math.floor(15 * Math.sqrt(r + i)); u /= 2.3; for (var l = 2 * Math.PI / u, c = 0; c < u - .5; c++)o.push(s + Math.sin(-l * c) * r, a + Math.cos(-l * c) * i); o.push(o[0], o[1]) } }, triangulate: function (t, e) { var r = t.points, i = e.points, n = e.indices, o = i.length / 2, s = o, a = t.shape, h = t.matrix, u = a.x, l = a.y; i.push(t.matrix ? h.a * u + h.c * l + h.tx : u, t.matrix ? h.b * u + h.d * l + h.ty : l); for (var c = 0; c < r.length; c += 2)i.push(r[c], r[c + 1]), n.push(o++, s, o) } }, xo = { build: function (t) { var e = t.shape, r = e.x, i = e.y, n = e.width, o = e.height, s = t.points; s.length = 0, s.push(r, i, r + n, i, r + n, i + o, r, i + o) }, triangulate: function (t, e) { var r = t.points, i = e.points, n = i.length / 2; i.push(r[0], r[1], r[2], r[3], r[6], r[7], r[4], r[5]), e.indices.push(n, n + 1, n + 2, n + 1, n + 2, n + 3) } }; function bo(t, e, r) { return t + (e - t) * r } function Eo(t, e, r, i, n, o, s) { void 0 === s && (s = []); for (var a = s, h = 0, u = 0, l = 0, c = 0, d = 0, p = 0, f = 0, m = 0; f <= 20; ++f)h = bo(t, r, m = f / 20), u = bo(e, i, m), l = bo(r, n, m), c = bo(i, o, m), d = bo(h, l, m), p = bo(u, c, m), a.push(d, p); return a } var To = { build: function (t) { var e = t.shape, r = t.points, i = e.x, n = e.y, o = e.width, s = e.height, a = Math.max(0, Math.min(e.radius, Math.min(o, s) / 2)); r.length = 0, a ? (Eo(i, n + a, i, n, i + a, n, r), Eo(i + o - a, n, i + o, n, i + o, n + a, r), Eo(i + o, n + s - a, i + o, n + s, i + o - a, n + s, r), Eo(i + a, n + s, i, n + s, i, n + s - a, r)) : r.push(i, n, i + o, n, i + o, n + s, i, n + s) }, triangulate: function (t, e) { for (var r = t.points, i = e.points, n = e.indices, o = i.length / 2, s = R(r, null, 2), a = 0, h = s.length; a < h; a += 3)n.push(s[a] + o), n.push(s[a + 1] + o), n.push(s[a + 2] + o); for (a = 0, h = r.length; a < h; a++)i.push(r[a], r[++a]) } }; function So(t, e, r, i, n, o, s, a) { var h, u; s ? (h = i, u = -r) : (h = -i, u = r); var l = t - r * n + h, c = e - i * n + u, d = t + r * o + h, p = e + i * o + u; return a.push(l, c), a.push(d, p), 2 } function wo(t, e, r, i, n, o, s, a) { var h = r - t, u = i - e, l = Math.atan2(h, u), c = Math.atan2(n - t, o - e); a && l < c ? l += 2 * Math.PI : !a && l > c && (c += 2 * Math.PI); var d = l, p = c - l, f = Math.abs(p), m = Math.sqrt(h * h + u * u), v = 1 + (15 * f * Math.sqrt(m) / Math.PI >> 0), g = p / v; if (d += g, a) { s.push(t, e), s.push(r, i); for (var y = 1, _ = d; y < v; y++, _ += g)s.push(t, e), s.push(t + Math.sin(_) * m, e + Math.cos(_) * m); s.push(t, e), s.push(n, o) } else { s.push(r, i), s.push(t, e); for (y = 1, _ = d; y < v; y++, _ += g)s.push(t + Math.sin(_) * m, e + Math.cos(_) * m), s.push(t, e); s.push(n, o), s.push(t, e) } return 2 * v } function Po(e, r) { e.lineStyle.native ? function (e, r) { var i = 0, n = e.shape, o = e.points || n.points, s = n.type !== t.SHAPES.POLY || n.closeStroke; if (0 !== o.length) { var a = r.points, h = r.indices, u = o.length / 2, l = a.length / 2, c = l; for (a.push(o[0], o[1]), i = 1; i < u; i++)a.push(o[2 * i], o[2 * i + 1]), h.push(c, c + 1), c++; s && h.push(c, l) } }(e, r) : function (e, r) { var i = e.shape, n = e.points || i.points.slice(), o = r.closePointEps; if (0 !== n.length) { var s = e.lineStyle, a = new we(n[0], n[1]), h = new we(n[n.length - 2], n[n.length - 1]), u = i.type !== t.SHAPES.POLY || i.closeStroke, l = Math.abs(a.x - h.x) < o && Math.abs(a.y - h.y) < o; if (u) { n = n.slice(), l && (n.pop(), n.pop(), h.set(n[n.length - 2], n[n.length - 1])); var c = .5 * (a.x + h.x), d = .5 * (h.y + a.y); n.unshift(c, d), n.push(c, d) } var p = r.points, f = n.length / 2, m = n.length, v = p.length / 2, g = s.width / 2, y = g * g, _ = s.miterLimit * s.miterLimit, x = n[0], b = n[1], E = n[2], T = n[3], S = 0, w = 0, P = -(b - T), I = x - E, A = 0, O = 0, M = Math.sqrt(P * P + I * I); P /= M, I /= M, P *= g, I *= g; var D = s.alignment, C = 2 * (1 - D), R = 2 * D; u || (s.cap === t.LINE_CAP.ROUND ? m += wo(x - P * (C - R) * .5, b - I * (C - R) * .5, x - P * C, b - I * C, x + P * R, b + I * R, p, !0) + 2 : s.cap === t.LINE_CAP.SQUARE && (m += So(x, b, P, I, C, R, !0, p))), p.push(x - P * C, b - I * C), p.push(x + P * R, b + I * R); for (var L = 1; L < f - 1; ++L) { x = n[2 * (L - 1)], b = n[2 * (L - 1) + 1], E = n[2 * L], T = n[2 * L + 1], S = n[2 * (L + 1)], w = n[2 * (L + 1) + 1], P = -(b - T), I = x - E, P /= M = Math.sqrt(P * P + I * I), I /= M, P *= g, I *= g, A = -(T - w), O = E - S, A /= M = Math.sqrt(A * A + O * O), O /= M, A *= g, O *= g; var N = E - x, F = b - T, B = E - S, U = w - T, k = F * B - U * N, X = k < 0; if (Math.abs(k) < .1) p.push(E - P * C, T - I * C), p.push(E + P * R, T + I * R); else { var j = (-P + x) * (-I + T) - (-P + E) * (-I + b), H = (-A + S) * (-O + T) - (-A + E) * (-O + w), G = (N * H - B * j) / k, Y = (U * j - F * H) / k, z = (G - E) * (G - E) + (Y - T) * (Y - T), V = E + (G - E) * C, W = T + (Y - T) * C, q = E - (G - E) * R, K = T - (Y - T) * R, Z = X ? C : R; z <= Math.min(N * N + F * F, B * B + U * U) + Z * Z * y ? s.join === t.LINE_JOIN.BEVEL || z / y > _ ? (X ? (p.push(V, W), p.push(E + P * R, T + I * R), p.push(V, W), p.push(E + A * R, T + O * R)) : (p.push(E - P * C, T - I * C), p.push(q, K), p.push(E - A * C, T - O * C), p.push(q, K)), m += 2) : s.join === t.LINE_JOIN.ROUND ? X ? (p.push(V, W), p.push(E + P * R, T + I * R), m += wo(E, T, E + P * R, T + I * R, E + A * R, T + O * R, p, !0) + 4, p.push(V, W), p.push(E + A * R, T + O * R)) : (p.push(E - P * C, T - I * C), p.push(q, K), m += wo(E, T, E - P * C, T - I * C, E - A * C, T - O * C, p, !1) + 4, p.push(E - A * C, T - O * C), p.push(q, K)) : (p.push(V, W), p.push(q, K)) : (p.push(E - P * C, T - I * C), p.push(E + P * R, T + I * R), s.join === t.LINE_JOIN.BEVEL || z / y > _ || (s.join === t.LINE_JOIN.ROUND ? m += X ? wo(E, T, E + P * R, T + I * R, E + A * R, T + O * R, p, !0) + 2 : wo(E, T, E - P * C, T - I * C, E - A * C, T - O * C, p, !1) + 2 : (X ? (p.push(q, K), p.push(q, K)) : (p.push(V, W), p.push(V, W)), m += 2)), p.push(E - A * C, T - O * C), p.push(E + A * R, T + O * R), m += 2) } } x = n[2 * (f - 2)], b = n[2 * (f - 2) + 1], E = n[2 * (f - 1)], P = -(b - (T = n[2 * (f - 1) + 1])), I = x - E, P /= M = Math.sqrt(P * P + I * I), I /= M, P *= g, I *= g, p.push(E - P * C, T - I * C), p.push(E + P * R, T + I * R), u || (s.cap === t.LINE_CAP.ROUND ? m += wo(E - P * (C - R) * .5, T - I * (C - R) * .5, E - P * C, T - I * C, E + P * R, T + I * R, p, !1) + 2 : s.cap === t.LINE_CAP.SQUARE && (m += So(E, T, P, I, C, R, !1, p))); var J = r.indices, Q = fo.epsilon * fo.epsilon; for (L = v; L < m + v - 2; ++L)x = p[2 * L], b = p[2 * L + 1], E = p[2 * (L + 1)], T = p[2 * (L + 1) + 1], S = p[2 * (L + 2)], w = p[2 * (L + 2) + 1], Math.abs(x * (T - w) + E * (w - b) + S * (b - T)) < Q || J.push(L, L + 1, L + 2) } }(e, r) } var Io, Ao = function (t) { function e(e, r, i, n, o, s) { void 0 === s && (s = 0); o = o || n / 2; for (var a = -1 * Math.PI / 2 + s, h = 2 * i, u = ge / h, l = [], c = 0; c < h; c++) { var d = c % 2 ? o : n, p = c * u + a; l.push(e + d * Math.cos(p), r + d * Math.sin(p)) } return t.call(this, l) || this } return go(e, t), e }(Te), Oo = function () { function t() { } return t.curveTo = function (t, e, r, i, n, o) { var s = o[o.length - 2], a = o[o.length - 1] - e, h = s - t, u = i - e, l = r - t, c = Math.abs(a * l - h * u); if (c < 1e-8 || 0 === n) return o[o.length - 2] === t && o[o.length - 1] === e || o.push(t, e), null; var d = a * a + h * h, p = u * u + l * l, f = a * u + h * l, m = n * Math.sqrt(d) / c, v = n * Math.sqrt(p) / c, g = m * f / d, y = v * f / p, _ = m * l + v * h, x = m * u + v * a, b = h * (v + g), E = a * (v + g), T = l * (m + y), S = u * (m + y); return { cx: _ + t, cy: x + e, radius: n, startAngle: Math.atan2(E - x, b - _), endAngle: Math.atan2(S - x, T - _), anticlockwise: h * u > l * a } }, t.arc = function (t, e, r, i, n, o, s, a, h) { for (var u = s - o, l = fo._segmentsCount(Math.abs(u) * n, 40 * Math.ceil(Math.abs(u) / ge)), c = u / (2 * l), d = 2 * c, p = Math.cos(c), f = Math.sin(c), m = l - 1, v = m % 1 / m, g = 0; g <= m; ++g) { var y = c + o + d * (g + v * g), _ = Math.cos(y), x = -Math.sin(y); h.push((p * _ + f * x) * n + r, (p * -x + f * _) * n + i) } }, t }(), Mo = function () { function t() { } return t.curveLength = function (t, e, r, i, n, o, s, a) { for (var h = 0, u = 0, l = 0, c = 0, d = 0, p = 0, f = 0, m = 0, v = 0, g = 0, y = 0, _ = t, x = e, b = 1; b <= 10; ++b)g = _ - (m = (f = (p = (d = 1 - (u = b / 10)) * d) * d) * t + 3 * p * u * r + 3 * d * (l = u * u) * n + (c = l * u) * s), y = x - (v = f * e + 3 * p * u * i + 3 * d * l * o + c * a), _ = m, x = v, h += Math.sqrt(g * g + y * y); return h }, t.curveTo = function (e, r, i, n, o, s, a) { var h = a[a.length - 2], u = a[a.length - 1]; a.length -= 2; var l = fo._segmentsCount(t.curveLength(h, u, e, r, i, n, o, s)), c = 0, d = 0, p = 0, f = 0, m = 0; a.push(h, u); for (var v = 1, g = 0; v <= l; ++v)p = (d = (c = 1 - (g = v / l)) * c) * c, m = (f = g * g) * g, a.push(p * h + 3 * d * g * e + 3 * c * f * i + m * o, p * u + 3 * d * g * r + 3 * c * f * n + m * s) }, t }(), Do = function () { function t() { } return t.curveLength = function (t, e, r, i, n, o) { var s = t - 2 * r + n, a = e - 2 * i + o, h = 2 * r - 2 * t, u = 2 * i - 2 * e, l = 4 * (s * s + a * a), c = 4 * (s * h + a * u), d = h * h + u * u, p = 2 * Math.sqrt(l + c + d), f = Math.sqrt(l), m = 2 * l * f, v = 2 * Math.sqrt(d), g = c / f; return (m * p + f * c * (p - v) + (4 * d * l - c * c) * Math.log((2 * f + g + p) / (g + v))) / (4 * m) }, t.curveTo = function (e, r, i, n, o) { for (var s = o[o.length - 2], a = o[o.length - 1], h = fo._segmentsCount(t.curveLength(s, a, e, r, i, n)), u = 0, l = 0, c = 1; c <= h; ++c) { var d = c / h; u = s + (e - s) * d, l = a + (r - a) * d, o.push(u + (e + (i - e) * d - u) * d, l + (r + (n - r) * d - l) * d) } }, t }(), Co = function () { function t() { this.reset() } return t.prototype.begin = function (t, e, r) { this.reset(), this.style = t, this.start = e, this.attribStart = r }, t.prototype.end = function (t, e) { this.attribSize = e - this.attribStart, this.size = t - this.start }, t.prototype.reset = function () { this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0 }, t }(), Ro = ((Io = {})[t.SHAPES.POLY] = yo, Io[t.SHAPES.CIRC] = _o, Io[t.SHAPES.ELIP] = _o, Io[t.SHAPES.RECT] = xo, Io[t.SHAPES.RREC] = To, Io), Lo = [], No = [], Fo = { buildPoly: yo, buildCircle: _o, buildRectangle: xo, buildRoundedRectangle: To, FILL_COMMANDS: Ro, BATCH_POOL: Lo, DRAW_CALL_POOL: No, buildLine: Po, Star: Ao, ArcUtils: Oo, BezierUtils: Mo, QuadraticUtils: Do, BatchPart: Co }, Bo = function () { function t(t, e, r, i) { void 0 === e && (e = null), void 0 === r && (r = null), void 0 === i && (i = null), this.shape = t, this.lineStyle = r, this.fillStyle = e, this.matrix = i, this.type = t.type, this.points = [], this.holes = [] } return t.prototype.clone = function () { return new t(this.shape, this.fillStyle, this.lineStyle, this.matrix) }, t.prototype.destroy = function () { this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null }, t }(), Uo = new we, ko = new Be, Xo = function (e) { function r() { var t = e.call(this) || this; return t.uvsFloat32 = null, t.indicesUint16 = null, t.points = [], t.colors = [], t.uvs = [], t.indices = [], t.textureIds = [], t.graphicsData = [], t.dirty = 0, t.batchDirty = -1, t.cacheDirty = -1, t.clearDirty = 0, t.drawCalls = [], t.batches = [], t.shapeIndex = 0, t._bounds = new Be, t.boundsDirty = -1, t.boundsPadding = 0, t.batchable = !1, t.indicesUint16 = null, t.uvsFloat32 = null, t.closePointEps = 1e-4, t } return go(r, e), Object.defineProperty(r.prototype, "bounds", { get: function () { return this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds }, enumerable: !1, configurable: !0 }), r.prototype.invalidate = function () { this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0; for (var t = 0; t < this.drawCalls.length; t++)this.drawCalls[t].texArray.clear(), No.push(this.drawCalls[t]); this.drawCalls.length = 0; for (t = 0; t < this.batches.length; t++) { var e = this.batches[t]; e.reset(), Lo.push(e) } this.batches.length = 0 }, r.prototype.clear = function () { return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this }, r.prototype.drawShape = function (t, e, r, i) { void 0 === e && (e = null), void 0 === r && (r = null), void 0 === i && (i = null); var n = new Bo(t, e, r, i); return this.graphicsData.push(n), this.dirty++, this }, r.prototype.drawHole = function (t, e) { if (void 0 === e && (e = null), !this.graphicsData.length) return null; var r = new Bo(t, null, null, e), i = this.graphicsData[this.graphicsData.length - 1]; return r.lineStyle = i.lineStyle, i.holes.push(r), this.dirty++, this }, r.prototype.destroy = function () { e.prototype.destroy.call(this); for (var t = 0; t < this.graphicsData.length; ++t)this.graphicsData[t].destroy(); this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null }, r.prototype.containsPoint = function (t) { for (var e = this.graphicsData, r = 0; r < e.length; ++r) { var i = e[r]; if (i.fillStyle.visible && (i.shape && (i.matrix ? i.matrix.applyInverse(t, Uo) : Uo.copyFrom(t), i.shape.contains(Uo.x, Uo.y)))) { var n = !1; if (i.holes) for (var o = 0; o < i.holes.length; o++) { if (i.holes[o].shape.contains(Uo.x, Uo.y)) { n = !0; break } } if (!n) return !0 } } return !1 }, r.prototype.updateBatches = function (e) { if (this.graphicsData.length) { if (this.validateBatching()) { this.cacheDirty = this.dirty; var r = this.uvs, i = this.graphicsData, n = null, o = null; this.batches.length > 0 && (o = (n = this.batches[this.batches.length - 1]).style); for (var s = this.shapeIndex; s < i.length; s++) { this.shapeIndex++; var a = i[s], h = a.fillStyle, u = a.lineStyle; Ro[a.type].build(a), a.matrix && this.transformPoints(a.points, a.matrix); for (var l = 0; l < 2; l++) { var c = 0 === l ? h : u; if (c.visible) { var d = c.texture.baseTexture, p = this.indices.length, f = this.points.length / 2; d.wrapMode = t.WRAP_MODES.REPEAT, 0 === l ? this.processFill(a) : this.processLine(a); var m = this.points.length / 2 - f; 0 !== m && (n && !this._compareStyles(o, c) && (n.end(p, f), n = null), n || ((n = Lo.pop() || new Co).begin(c, p, f), this.batches.push(n), o = c), this.addUvs(this.points, r, c.texture, f, m, c.matrix)) } } } var v = this.indices.length, g = this.points.length / 2; if (n && n.end(v, g), 0 !== this.batches.length) { if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) this.indicesUint16.set(this.indices); else { var y = g > 65535 && e; this.indicesUint16 = y ? new Uint32Array(this.indices) : new Uint16Array(this.indices) } this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls() } else this.batchable = !0 } } else this.batchable = !0 }, r.prototype._compareStyles = function (t, e) { return !(!t || !e) && (t.texture.baseTexture === e.texture.baseTexture && (t.color + t.alpha === e.color + e.alpha && !!t.native == !!e.native)) }, r.prototype.validateBatching = function () { if (this.dirty === this.cacheDirty || !this.graphicsData.length) return !1; for (var t = 0, e = this.graphicsData.length; t < e; t++) { var r = this.graphicsData[t], i = r.fillStyle, n = r.lineStyle; if (i && !i.texture.baseTexture.valid) return !1; if (n && !n.texture.baseTexture.valid) return !1 } return !0 }, r.prototype.packBatches = function () { this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs); for (var t = this.batches, e = 0, r = t.length; e < r; e++)for (var i = t[e], n = 0; n < i.size; n++) { var o = i.start + n; this.indicesUint16[o] = this.indicesUint16[o] - i.attribStart } }, r.prototype.isBatchable = function () { if (this.points.length > 131070) return !1; for (var t = this.batches, e = 0; e < t.length; e++)if (t[e].style.native) return !1; return this.points.length < 2 * r.BATCHABLE_SIZE }, r.prototype.buildDrawCalls = function () { for (var e = ++gr._globalBatch, r = 0; r < this.drawCalls.length; r++)this.drawCalls[r].texArray.clear(), No.push(this.drawCalls[r]); this.drawCalls.length = 0; var i = this.colors, n = this.textureIds, o = No.pop(); o || ((o = new _n).texArray = new xn), o.texArray.count = 0, o.start = 0, o.size = 0, o.type = t.DRAW_MODES.TRIANGLES; var s = 0, a = null, h = 0, u = !1, l = t.DRAW_MODES.TRIANGLES, c = 0; this.drawCalls.push(o); for (r = 0; r < this.batches.length; r++) { var d = this.batches[r], p = d.style, f = p.texture.baseTexture; u !== !!p.native && (l = (u = !!p.native) ? t.DRAW_MODES.LINES : t.DRAW_MODES.TRIANGLES, a = null, s = 8, e++), a !== f && (a = f, f._batchEnabled !== e && (8 === s && (e++, s = 0, o.size > 0 && ((o = No.pop()) || ((o = new _n).texArray = new xn), this.drawCalls.push(o)), o.start = c, o.size = 0, o.texArray.count = 0, o.type = l), f.touched = 1, f._batchEnabled = e, f._batchLocation = s, f.wrapMode = 10497, o.texArray.elements[o.texArray.count++] = f, s++)), o.size += d.size, c += d.size, h = f._batchLocation, this.addColors(i, p.color, p.alpha, d.attribSize), this.addTextureIds(n, h, d.attribSize) } gr._globalBatch = e, this.packAttributes() }, r.prototype.packAttributes = function () { for (var t = this.points, e = this.uvs, r = this.colors, i = this.textureIds, n = new ArrayBuffer(3 * t.length * 4), o = new Float32Array(n), s = new Uint32Array(n), a = 0, h = 0; h < t.length / 2; h++)o[a++] = t[2 * h], o[a++] = t[2 * h + 1], o[a++] = e[2 * h], o[a++] = e[2 * h + 1], s[a++] = r[h], o[a++] = i[h]; this._buffer.update(n), this._indexBuffer.update(this.indicesUint16) }, r.prototype.processFill = function (t) { t.holes.length ? (this.processHoles(t.holes), yo.triangulate(t, this)) : Ro[t.type].triangulate(t, this) }, r.prototype.processLine = function (t) { Po(t, this); for (var e = 0; e < t.holes.length; e++)Po(t.holes[e], this) }, r.prototype.processHoles = function (t) { for (var e = 0; e < t.length; e++) { var r = t[e]; Ro[r.type].build(r), r.matrix && this.transformPoints(r.points, r.matrix) } }, r.prototype.calculateBounds = function () { var e = this._bounds, r = ko, i = Ie.IDENTITY; this._bounds.clear(), r.clear(); for (var n = 0; n < this.graphicsData.length; n++) { var o = this.graphicsData[n], s = o.shape, a = o.type, h = o.lineStyle, u = o.matrix || Ie.IDENTITY, l = 0; if (h && h.visible) { var c = h.alignment; l = h.width, a === t.SHAPES.POLY ? l *= .5 + Math.abs(.5 - c) : l *= Math.max(0, c) } if (i !== u && (r.isEmpty() || (e.addBoundsMatrix(r, i), r.clear()), i = u), a === t.SHAPES.RECT || a === t.SHAPES.RREC) { var d = s; r.addFramePad(d.x, d.y, d.x + d.width, d.y + d.height, l, l) } else if (a === t.SHAPES.CIRC) { var p = s; r.addFramePad(p.x, p.y, p.x, p.y, p.radius + l, p.radius + l) } else if (a === t.SHAPES.ELIP) { var f = s; r.addFramePad(f.x, f.y, f.x, f.y, f.width + l, f.height + l) } else { var m = s; e.addVerticesMatrix(i, m.points, 0, m.points.length, l, l) } } r.isEmpty() || e.addBoundsMatrix(r, i), e.pad(this.boundsPadding, this.boundsPadding) }, r.prototype.transformPoints = function (t, e) { for (var r = 0; r < t.length / 2; r++) { var i = t[2 * r], n = t[2 * r + 1]; t[2 * r] = e.a * i + e.c * n + e.tx, t[2 * r + 1] = e.b * i + e.d * n + e.ty } }, r.prototype.addColors = function (t, e, r, i) { for (var n = Vt((e >> 16) + (65280 & e) + ((255 & e) << 16), r); i-- > 0;)t.push(n) }, r.prototype.addTextureIds = function (t, e, r) { for (; r-- > 0;)t.push(e) }, r.prototype.addUvs = function (t, e, r, i, n, o) { void 0 === o && (o = null); for (var s = 0, a = e.length, h = r.frame; s < n;) { var u = t[2 * (i + s)], l = t[2 * (i + s) + 1]; if (o) { var c = o.a * u + o.c * l + o.tx; l = o.b * u + o.d * l + o.ty, u = c } s++, e.push(u / h.width, l / h.height) } var d = r.baseTexture; (h.width < d.width || h.height < d.height) && this.adjustUvs(e, r, a, n) }, r.prototype.adjustUvs = function (t, e, r, i) { for (var n = e.baseTexture, o = r + 2 * i, s = e.frame, a = s.width / n.width, h = s.height / n.height, u = s.x / s.width, l = s.y / s.height, c = Math.floor(t[r] + 1e-6), d = Math.floor(t[r + 1] + 1e-6), p = r + 2; p < o; p += 2)c = Math.min(c, Math.floor(t[p] + 1e-6)), d = Math.min(d, Math.floor(t[p + 1] + 1e-6)); u -= c, l -= d; for (p = r; p < o; p += 2)t[p] = (t[p] + u) * a, t[p + 1] = (t[p + 1] + l) * h }, r.BATCHABLE_SIZE = 100, r }(Sn), jo = function (e) { function r() { var r = null !== e && e.apply(this, arguments) || this; return r.width = 0, r.alignment = .5, r.native = !1, r.cap = t.LINE_CAP.BUTT, r.join = t.LINE_JOIN.MITER, r.miterLimit = 10, r } return go(r, e), r.prototype.clone = function () { var t = new r; return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t.width = this.width, t.alignment = this.alignment, t.native = this.native, t.cap = this.cap, t.join = this.join, t.miterLimit = this.miterLimit, t }, r.prototype.reset = function () { e.prototype.reset.call(this), this.color = 0, this.alignment = .5, this.width = 0, this.native = !1 }, r }(mo), Ho = new Float32Array(3), Go = {}, Yo = function (e) { function r(r) { void 0 === r && (r = null); var i = e.call(this) || this; return i._geometry = r || new Xo, i._geometry.refCount++, i.shader = null, i.state = Ni.for2d(), i._fillStyle = new mo, i._lineStyle = new jo, i._matrix = null, i._holeMode = !1, i.currentPath = null, i.batches = [], i.batchTint = -1, i.batchDirty = -1, i.vertexData = null, i.pluginName = "batch", i._transformID = -1, i.tint = 16777215, i.blendMode = t.BLEND_MODES.NORMAL, i } return go(r, e), Object.defineProperty(r.prototype, "geometry", { get: function () { return this._geometry }, enumerable: !1, configurable: !0 }), r.prototype.clone = function () { return this.finishPoly(), new r(this._geometry) }, Object.defineProperty(r.prototype, "blendMode", { get: function () { return this.state.blendMode }, set: function (t) { this.state.blendMode = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "tint", { get: function () { return this._tint }, set: function (t) { this._tint = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "fill", { get: function () { return this._fillStyle }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "line", { get: function () { return this._lineStyle }, enumerable: !1, configurable: !0 }), r.prototype.lineStyle = function (t) { if (void 0 === t && (t = null), "number" == typeof t) { var e = arguments; t = { width: e[0] || 0, color: e[1] || 0, alpha: void 0 !== e[2] ? e[2] : 1, alignment: void 0 !== e[3] ? e[3] : .5, native: !!e[4] } } return this.lineTextureStyle(t) }, r.prototype.lineTextureStyle = function (e) { if ("number" == typeof e) { oe("v5.2.0", "Please use object-based options for Graphics#lineTextureStyle"); var r = arguments, i = r[0], n = r[1], o = r[2], s = r[3], a = r[4], h = r[5], u = r[6]; e = { width: i, texture: n, color: o, alpha: s, matrix: a, alignment: h, native: u }, Object.keys(e).forEach(function (t) { return void 0 === e[t] && delete e[t] }) } e = Object.assign({ width: 0, texture: Lr.WHITE, color: e && e.texture ? 16777215 : 0, alpha: 1, matrix: null, alignment: .5, native: !1, cap: t.LINE_CAP.BUTT, join: t.LINE_JOIN.MITER, miterLimit: 10 }, e), this.currentPath && this.startPoly(); var l = e.width > 0 && e.alpha > 0; return l ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, { visible: l }, e)) : this._lineStyle.reset(), this }, r.prototype.startPoly = function () { if (this.currentPath) { var t = this.currentPath.points, e = this.currentPath.points.length; e > 2 && (this.drawShape(this.currentPath), this.currentPath = new Te, this.currentPath.closeStroke = !1, this.currentPath.points.push(t[e - 2], t[e - 1])) } else this.currentPath = new Te, this.currentPath.closeStroke = !1 }, r.prototype.finishPoly = function () { this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0) }, r.prototype.moveTo = function (t, e) { return this.startPoly(), this.currentPath.points[0] = t, this.currentPath.points[1] = e, this }, r.prototype.lineTo = function (t, e) { this.currentPath || this.moveTo(0, 0); var r = this.currentPath.points, i = r[r.length - 2], n = r[r.length - 1]; return i === t && n === e || r.push(t, e), this }, r.prototype._initCurve = function (t, e) { void 0 === t && (t = 0), void 0 === e && (e = 0), this.currentPath ? 0 === this.currentPath.points.length && (this.currentPath.points = [t, e]) : this.moveTo(t, e) }, r.prototype.quadraticCurveTo = function (t, e, r, i) { this._initCurve(); var n = this.currentPath.points; return 0 === n.length && this.moveTo(0, 0), Do.curveTo(t, e, r, i, n), this }, r.prototype.bezierCurveTo = function (t, e, r, i, n, o) { return this._initCurve(), Mo.curveTo(t, e, r, i, n, o, this.currentPath.points), this }, r.prototype.arcTo = function (t, e, r, i, n) { this._initCurve(t, e); var o = this.currentPath.points, s = Oo.curveTo(t, e, r, i, n, o); if (s) { var a = s.cx, h = s.cy, u = s.radius, l = s.startAngle, c = s.endAngle, d = s.anticlockwise; this.arc(a, h, u, l, c, d) } return this }, r.prototype.arc = function (t, e, r, i, n, o) { if (void 0 === o && (o = !1), i === n) return this; if (!o && n <= i ? n += ge : o && i <= n && (i += ge), 0 === n - i) return this; var s = t + Math.cos(i) * r, a = e + Math.sin(i) * r, h = this._geometry.closePointEps, u = this.currentPath ? this.currentPath.points : null; if (u) { var l = Math.abs(u[u.length - 2] - s), c = Math.abs(u[u.length - 1] - a); l < h && c < h || u.push(s, a) } else this.moveTo(s, a), u = this.currentPath.points; return Oo.arc(s, a, t, e, r, i, n, o, u), this }, r.prototype.beginFill = function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 1), this.beginTextureFill({ texture: Lr.WHITE, color: t, alpha: e }) }, r.prototype.beginTextureFill = function (t) { if (t instanceof Lr) { oe("v5.2.0", "Please use object-based options for Graphics#beginTextureFill"); var e = arguments, r = e[0], i = e[1], n = e[2], o = e[3]; t = { texture: r, color: i, alpha: n, matrix: o }, Object.keys(t).forEach(function (e) { return void 0 === t[e] && delete t[e] }) } t = Object.assign({ texture: Lr.WHITE, color: 16777215, alpha: 1, matrix: null }, t), this.currentPath && this.startPoly(); var s = t.alpha > 0; return s ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._fillStyle, { visible: s }, t)) : this._fillStyle.reset(), this }, r.prototype.endFill = function () { return this.finishPoly(), this._fillStyle.reset(), this }, r.prototype.drawRect = function (t, e, r, i) { return this.drawShape(new xe(t, e, r, i)) }, r.prototype.drawRoundedRect = function (t, e, r, i, n) { return this.drawShape(new Se(t, e, r, i, n)) }, r.prototype.drawCircle = function (t, e, r) { return this.drawShape(new be(t, e, r)) }, r.prototype.drawEllipse = function (t, e, r, i) { return this.drawShape(new Ee(t, e, r, i)) }, r.prototype.drawPolygon = function () { for (var t, e = arguments, r = [], i = 0; i < arguments.length; i++)r[i] = e[i]; var n = !0, o = r[0]; o.points ? (n = o.closeStroke, t = o.points) : t = Array.isArray(r[0]) ? r[0] : r; var s = new Te(t); return s.closeStroke = n, this.drawShape(s), this }, r.prototype.drawShape = function (t) { return this._holeMode ? this._geometry.drawHole(t, this._matrix) : this._geometry.drawShape(t, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this }, r.prototype.drawStar = function (t, e, r, i, n, o) { return void 0 === o && (o = 0), this.drawPolygon(new Ao(t, e, r, i, n, o)) }, r.prototype.clear = function () { return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this }, r.prototype.isFastRect = function () { var e = this._geometry.graphicsData; return 1 === e.length && e[0].shape.type === t.SHAPES.RECT && !(e[0].lineStyle.visible && e[0].lineStyle.width) }, r.prototype._render = function (t) { this.finishPoly(); var e = this._geometry, r = t.context.supports.uint32Indices; e.updateBatches(r), e.batchable ? (this.batchDirty !== e.batchDirty && this._populateBatches(), this._renderBatched(t)) : (t.batch.flush(), this._renderDirect(t)) }, r.prototype._populateBatches = function () { var t = this._geometry, e = this.blendMode, r = t.batches.length; this.batchTint = -1, this._transformID = -1, this.batchDirty = t.batchDirty, this.batches.length = r, this.vertexData = new Float32Array(t.points); for (var i = 0; i < r; i++) { var n = t.batches[i], o = n.style.color, s = new Float32Array(this.vertexData.buffer, 4 * n.attribStart * 2, 2 * n.attribSize), a = new Float32Array(t.uvsFloat32.buffer, 4 * n.attribStart * 2, 2 * n.attribSize), h = { vertexData: s, blendMode: e, indices: new Uint16Array(t.indicesUint16.buffer, 2 * n.start, n.size), uvs: a, _batchRGB: kt(o), _tintRGB: o, _texture: n.style.texture, alpha: n.style.alpha, worldAlpha: 1 }; this.batches[i] = h } }, r.prototype._renderBatched = function (t) { if (this.batches.length) { t.batch.setObjectRenderer(t.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints(); for (var e = 0, r = this.batches.length; e < r; e++) { var i = this.batches[e]; i.worldAlpha = this.worldAlpha * i.alpha, t.plugins[this.pluginName].render(i) } } }, r.prototype._renderDirect = function (t) { var e = this._resolveDirectShader(t), r = this._geometry, i = this.tint, n = this.worldAlpha, o = e.uniforms, s = r.drawCalls; o.translationMatrix = this.transform.worldTransform, o.tint[0] = (i >> 16 & 255) / 255 * n, o.tint[1] = (i >> 8 & 255) / 255 * n, o.tint[2] = (255 & i) / 255 * n, o.tint[3] = n, t.shader.bind(e), t.geometry.bind(r, e), t.state.set(this.state); for (var a = 0, h = s.length; a < h; a++)this._renderDrawCallDirect(t, r.drawCalls[a]) }, r.prototype._renderDrawCallDirect = function (t, e) { for (var r = e.texArray, i = e.type, n = e.size, o = e.start, s = r.count, a = 0; a < s; a++)t.texture.bind(r.elements[a], a); t.geometry.draw(i, n, o) }, r.prototype._resolveDirectShader = function (t) { var e = this.shader, r = this.pluginName; if (!e) { if (!Go[r]) { for (var i = t.plugins.batch.MAX_TEXTURES, n = new Int32Array(i), o = 0; o < i; o++)n[o] = o; var s = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new Ie, default: Zr.from({ uSamplers: n }, !0) }, a = t.plugins[r]._shader.program; Go[r] = new Li(a, s) } e = Go[r] } return e }, r.prototype._calculateBounds = function () { this.finishPoly(); var t = this._geometry; if (t.graphicsData.length) { var e = t.bounds, r = e.minX, i = e.minY, n = e.maxX, o = e.maxY; this._bounds.addFrame(this.transform, r, i, n, o) } }, r.prototype.containsPoint = function (t) { return this.worldTransform.applyInverse(t, r._TEMP_POINT), this._geometry.containsPoint(r._TEMP_POINT) }, r.prototype.calculateTints = function () { if (this.batchTint !== this.tint) { this.batchTint = this.tint; for (var t = kt(this.tint, Ho), e = 0; e < this.batches.length; e++) { var r = this.batches[e], i = r._batchRGB, n = (t[0] * i[0] * 255 << 16) + (t[1] * i[1] * 255 << 8) + (0 | t[2] * i[2] * 255); r._tintRGB = (n >> 16) + (65280 & n) + ((255 & n) << 16) } } }, r.prototype.calculateVertices = function () { var t = this.transform._worldID; if (this._transformID !== t) { this._transformID = t; for (var e = this.transform.worldTransform, r = e.a, i = e.b, n = e.c, o = e.d, s = e.tx, a = e.ty, h = this._geometry.points, u = this.vertexData, l = 0, c = 0; c < h.length; c += 2) { var d = h[c], p = h[c + 1]; u[l++] = r * d + n * p + s, u[l++] = o * p + i * d + a } } }, r.prototype.closePath = function () { var t = this.currentPath; return t && (t.closeStroke = !0), this }, r.prototype.setMatrix = function (t) { return this._matrix = t, this }, r.prototype.beginHole = function () { return this.finishPoly(), this._holeMode = !0, this }, r.prototype.endHole = function () { return this.finishPoly(), this._holeMode = !1, this }, r.prototype.destroy = function (t) { this._geometry.refCount--, 0 === this._geometry.refCount && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, e.prototype.destroy.call(this, t) }, r._TEMP_POINT = new we, r }(Ge), zo = function (t, e) { return (zo = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; var Vo, Wo = new we, qo = new Uint16Array([0, 1, 2, 0, 2, 3]), Ko = function (e) { function r(r) { var i = e.call(this) || this; return i._anchor = new Pe(i._onAnchorUpdate, i, r ? r.defaultAnchor.x : 0, r ? r.defaultAnchor.y : 0), i._texture = null, i._width = 0, i._height = 0, i._tint = null, i._tintRGB = null, i.tint = 16777215, i.blendMode = t.BLEND_MODES.NORMAL, i._cachedTint = 16777215, i.uvs = null, i.texture = r || Lr.EMPTY, i.vertexData = new Float32Array(8), i.vertexTrimmedData = null, i._transformID = -1, i._textureID = -1, i._transformTrimmedID = -1, i._textureTrimmedID = -1, i.indices = qo, i.pluginName = "batch", i.isSprite = !0, i._roundPixels = D.ROUND_PIXELS, i } return function (t, e) { function r() { this.constructor = t } zo(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) }(r, e), r.prototype._onTextureUpdate = function () { this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = ee(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = ee(this.scale.y) * this._height / this._texture.orig.height) }, r.prototype._onAnchorUpdate = function () { this._transformID = -1, this._transformTrimmedID = -1 }, r.prototype.calculateVertices = function () { var t = this._texture; if (this._transformID !== this.transform._worldID || this._textureID !== t._updateID) { this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t._updateID; var e = this.transform.worldTransform, r = e.a, i = e.b, n = e.c, o = e.d, s = e.tx, a = e.ty, h = this.vertexData, u = t.trim, l = t.orig, c = this._anchor, d = 0, p = 0, f = 0, m = 0; if (u ? (d = (p = u.x - c._x * l.width) + u.width, f = (m = u.y - c._y * l.height) + u.height) : (d = (p = -c._x * l.width) + l.width, f = (m = -c._y * l.height) + l.height), h[0] = r * p + n * m + s, h[1] = o * m + i * p + a, h[2] = r * d + n * m + s, h[3] = o * m + i * d + a, h[4] = r * d + n * f + s, h[5] = o * f + i * d + a, h[6] = r * p + n * f + s, h[7] = o * f + i * p + a, this._roundPixels) for (var v = D.RESOLUTION, g = 0; g < h.length; ++g)h[g] = Math.round((h[g] * v | 0) / v) } }, r.prototype.calculateTrimmedVertices = function () { if (this.vertexTrimmedData) { if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return } else this.vertexTrimmedData = new Float32Array(8); this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID; var t = this._texture, e = this.vertexTrimmedData, r = t.orig, i = this._anchor, n = this.transform.worldTransform, o = n.a, s = n.b, a = n.c, h = n.d, u = n.tx, l = n.ty, c = -i._x * r.width, d = c + r.width, p = -i._y * r.height, f = p + r.height; e[0] = o * c + a * p + u, e[1] = h * p + s * c + l, e[2] = o * d + a * p + u, e[3] = h * p + s * d + l, e[4] = o * d + a * f + u, e[5] = h * f + s * d + l, e[6] = o * c + a * f + u, e[7] = h * f + s * c + l }, r.prototype._render = function (t) { this.calculateVertices(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this) }, r.prototype._calculateBounds = function () { var t = this._texture.trim, e = this._texture.orig; !t || t.width === e.width && t.height === e.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData)) }, r.prototype.getLocalBounds = function (t) { return 0 === this.children.length ? (this._bounds.minX = this._texture.orig.width * -this._anchor._x, this._bounds.minY = this._texture.orig.height * -this._anchor._y, this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y), t || (this._localBoundsRect || (this._localBoundsRect = new xe), t = this._localBoundsRect), this._bounds.getRectangle(t)) : e.prototype.getLocalBounds.call(this, t) }, r.prototype.containsPoint = function (t) { this.worldTransform.applyInverse(t, Wo); var e = this._texture.orig.width, r = this._texture.orig.height, i = -e * this.anchor.x, n = 0; return Wo.x >= i && Wo.x < i + e && (n = -r * this.anchor.y, Wo.y >= n && Wo.y < n + r) }, r.prototype.destroy = function (t) { if (e.prototype.destroy.call(this, t), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, "boolean" == typeof t ? t : t && t.texture) { var r = "boolean" == typeof t ? t : t && t.baseTexture; this._texture.destroy(!!r) } this._texture = null }, r.from = function (t, e) { return new r(t instanceof Lr ? t : Lr.from(t, e)) }, Object.defineProperty(r.prototype, "roundPixels", { get: function () { return this._roundPixels }, set: function (t) { this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "width", { get: function () { return Math.abs(this.scale.x) * this._texture.orig.width }, set: function (t) { var e = ee(this.scale.x) || 1; this.scale.x = e * t / this._texture.orig.width, this._width = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "height", { get: function () { return Math.abs(this.scale.y) * this._texture.orig.height }, set: function (t) { var e = ee(this.scale.y) || 1; this.scale.y = e * t / this._texture.orig.height, this._height = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "anchor", { get: function () { return this._anchor }, set: function (t) { this._anchor.copyFrom(t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "tint", { get: function () { return this._tint }, set: function (t) { this._tint = t, this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16) }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "texture", { get: function () { return this._texture }, set: function (t) { this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = t || Lr.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this))) }, enumerable: !1, configurable: !0 }), r }(Ge), Zo = function (t, e) { return (Zo = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; (Vo = t.TEXT_GRADIENT || (t.TEXT_GRADIENT = {}))[Vo.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", Vo[Vo.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL"; var Jo = { align: "left", breakWords: !1, dropShadow: !1, dropShadowAlpha: 1, dropShadowAngle: Math.PI / 6, dropShadowBlur: 0, dropShadowColor: "black", dropShadowDistance: 5, fill: "black", fillGradientType: t.TEXT_GRADIENT.LINEAR_VERTICAL, fillGradientStops: [], fontFamily: "Arial", fontSize: 26, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", letterSpacing: 0, lineHeight: 0, lineJoin: "miter", miterLimit: 10, padding: 0, stroke: "black", strokeThickness: 0, textBaseline: "alphabetic", trim: !1, whiteSpace: "pre", wordWrap: !1, wordWrapWidth: 100, leading: 0 }, Qo = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"], $o = function () { function t(t) { this.styleID = 0, this.reset(), rs(this, t, t) } return t.prototype.clone = function () { var e = {}; return rs(e, this, Jo), new t(e) }, t.prototype.reset = function () { rs(this, Jo, Jo) }, Object.defineProperty(t.prototype, "align", { get: function () { return this._align }, set: function (t) { this._align !== t && (this._align = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "breakWords", { get: function () { return this._breakWords }, set: function (t) { this._breakWords !== t && (this._breakWords = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dropShadow", { get: function () { return this._dropShadow }, set: function (t) { this._dropShadow !== t && (this._dropShadow = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dropShadowAlpha", { get: function () { return this._dropShadowAlpha }, set: function (t) { this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dropShadowAngle", { get: function () { return this._dropShadowAngle }, set: function (t) { this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dropShadowBlur", { get: function () { return this._dropShadowBlur }, set: function (t) { this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dropShadowColor", { get: function () { return this._dropShadowColor }, set: function (t) { var e = es(t); this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dropShadowDistance", { get: function () { return this._dropShadowDistance }, set: function (t) { this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fill", { get: function () { return this._fill }, set: function (t) { var e = es(t); this._fill !== e && (this._fill = e, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fillGradientType", { get: function () { return this._fillGradientType }, set: function (t) { this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fillGradientStops", { get: function () { return this._fillGradientStops }, set: function (t) { (function (t, e) { if (!Array.isArray(t) || !Array.isArray(e)) return !1; if (t.length !== e.length) return !1; for (var r = 0; r < t.length; ++r)if (t[r] !== e[r]) return !1; return !0 })(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fontFamily", { get: function () { return this._fontFamily }, set: function (t) { this.fontFamily !== t && (this._fontFamily = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fontSize", { get: function () { return this._fontSize }, set: function (t) { this._fontSize !== t && (this._fontSize = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fontStyle", { get: function () { return this._fontStyle }, set: function (t) { this._fontStyle !== t && (this._fontStyle = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fontVariant", { get: function () { return this._fontVariant }, set: function (t) { this._fontVariant !== t && (this._fontVariant = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fontWeight", { get: function () { return this._fontWeight }, set: function (t) { this._fontWeight !== t && (this._fontWeight = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "letterSpacing", { get: function () { return this._letterSpacing }, set: function (t) { this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "lineHeight", { get: function () { return this._lineHeight }, set: function (t) { this._lineHeight !== t && (this._lineHeight = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "leading", { get: function () { return this._leading }, set: function (t) { this._leading !== t && (this._leading = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "lineJoin", { get: function () { return this._lineJoin }, set: function (t) { this._lineJoin !== t && (this._lineJoin = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "miterLimit", { get: function () { return this._miterLimit }, set: function (t) { this._miterLimit !== t && (this._miterLimit = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "padding", { get: function () { return this._padding }, set: function (t) { this._padding !== t && (this._padding = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "stroke", { get: function () { return this._stroke }, set: function (t) { var e = es(t); this._stroke !== e && (this._stroke = e, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "strokeThickness", { get: function () { return this._strokeThickness }, set: function (t) { this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "textBaseline", { get: function () { return this._textBaseline }, set: function (t) { this._textBaseline !== t && (this._textBaseline = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "trim", { get: function () { return this._trim }, set: function (t) { this._trim !== t && (this._trim = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "whiteSpace", { get: function () { return this._whiteSpace }, set: function (t) { this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "wordWrap", { get: function () { return this._wordWrap }, set: function (t) { this._wordWrap !== t && (this._wordWrap = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "wordWrapWidth", { get: function () { return this._wordWrapWidth }, set: function (t) { this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++) }, enumerable: !1, configurable: !0 }), t.prototype.toFontString = function () { var t = "number" == typeof this.fontSize ? this.fontSize + "px" : this.fontSize, e = this.fontFamily; Array.isArray(this.fontFamily) || (e = this.fontFamily.split(",")); for (var r = e.length - 1; r >= 0; r--) { var i = e[r].trim(); !/([\"\'])[^\'\"]+\1/.test(i) && Qo.indexOf(i) < 0 && (i = '"' + i + '"'), e[r] = i } return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t + " " + e.join(",") }, t }(); function ts(t) { return "number" == typeof t ? Xt(t) : ("string" == typeof t && 0 === t.indexOf("0x") && (t = t.replace("0x", "#")), t) } function es(t) { if (Array.isArray(t)) { for (var e = 0; e < t.length; ++e)t[e] = ts(t[e]); return t } return ts(t) } function rs(t, e, r) { for (var i in r) Array.isArray(e[i]) ? t[i] = e[i].slice() : t[i] = e[i] } var is = function () { function t(t, e, r, i, n, o, s, a, h) { this.text = t, this.style = e, this.width = r, this.height = i, this.lines = n, this.lineWidths = o, this.lineHeight = s, this.maxLineWidth = a, this.fontProperties = h } return t.measureText = function (e, r, i, n) { void 0 === n && (n = t._canvas), i = null == i ? r.wordWrap : i; var o = r.toFontString(), s = t.measureFont(o); 0 === s.fontSize && (s.fontSize = r.fontSize, s.ascent = r.fontSize); var a = n.getContext("2d"); a.font = o; for (var h = (i ? t.wordWrap(e, r, n) : e).split(/(?:\r\n|\r|\n)/), u = new Array(h.length), l = 0, c = 0; c < h.length; c++) { var d = a.measureText(h[c]).width + (h[c].length - 1) * r.letterSpacing; u[c] = d, l = Math.max(l, d) } var p = l + r.strokeThickness; r.dropShadow && (p += r.dropShadowDistance); var f = r.lineHeight || s.fontSize + r.strokeThickness, m = Math.max(f, s.fontSize + r.strokeThickness) + (h.length - 1) * (f + r.leading); return r.dropShadow && (m += r.dropShadowDistance), new t(e, r, p, m, h, u, f + r.leading, l, s) }, t.wordWrap = function (e, r, i) { void 0 === i && (i = t._canvas); for (var n = i.getContext("2d"), o = 0, s = "", a = "", h = Object.create(null), u = r.letterSpacing, l = r.whiteSpace, c = t.collapseSpaces(l), d = t.collapseNewlines(l), p = !c, f = r.wordWrapWidth + u, m = t.tokenize(e), v = 0; v < m.length; v++) { var g = m[v]; if (t.isNewline(g)) { if (!d) { a += t.addLine(s), p = !c, s = "", o = 0; continue } g = " " } if (c) { var y = t.isBreakingSpace(g), _ = t.isBreakingSpace(s[s.length - 1]); if (y && _) continue } var x = t.getFromCache(g, u, h, n); if (x > f) if ("" !== s && (a += t.addLine(s), s = "", o = 0), t.canBreakWords(g, r.breakWords)) for (var b = t.wordWrapSplit(g), E = 0; E < b.length; E++) { for (var T = b[E], S = 1; b[E + S];) { var w = b[E + S], P = T[T.length - 1]; if (t.canBreakChars(P, w, g, E, r.breakWords)) break; T += w, S++ } E += T.length - 1; var I = t.getFromCache(T, u, h, n); I + o > f && (a += t.addLine(s), p = !1, s = "", o = 0), s += T, o += I } else { s.length > 0 && (a += t.addLine(s), s = "", o = 0); var A = v === m.length - 1; a += t.addLine(g, !A), p = !1, s = "", o = 0 } else x + o > f && (p = !1, a += t.addLine(s), s = "", o = 0), (s.length > 0 || !t.isBreakingSpace(g) || p) && (s += g, o += x) } return a += t.addLine(s, !1) }, t.addLine = function (e, r) { return void 0 === r && (r = !0), e = t.trimRight(e), e = r ? e + "\n" : e }, t.getFromCache = function (t, e, r, i) { var n = r[t]; if ("number" != typeof n) { var o = t.length * e; n = i.measureText(t).width + o, r[t] = n } return n }, t.collapseSpaces = function (t) { return "normal" === t || "pre-line" === t }, t.collapseNewlines = function (t) { return "normal" === t }, t.trimRight = function (e) { if ("string" != typeof e) return ""; for (var r = e.length - 1; r >= 0; r--) { var i = e[r]; if (!t.isBreakingSpace(i)) break; e = e.slice(0, -1) } return e }, t.isNewline = function (e) { return "string" == typeof e && t._newlines.indexOf(e.charCodeAt(0)) >= 0 }, t.isBreakingSpace = function (e) { return "string" == typeof e && t._breakingSpaces.indexOf(e.charCodeAt(0)) >= 0 }, t.tokenize = function (e) { var r = [], i = ""; if ("string" != typeof e) return r; for (var n = 0; n < e.length; n++) { var o = e[n]; t.isBreakingSpace(o) || t.isNewline(o) ? ("" !== i && (r.push(i), i = ""), r.push(o)) : i += o } return "" !== i && r.push(i), r }, t.canBreakWords = function (t, e) { return e }, t.canBreakChars = function (t, e, r, i, n) { return !0 }, t.wordWrapSplit = function (t) { return t.split("") }, t.measureFont = function (e) { if (t._fonts[e]) return t._fonts[e]; var r = { ascent: 0, descent: 0, fontSize: 0 }, i = t._canvas, n = t._context; n.font = e; var o = t.METRICS_STRING + t.BASELINE_SYMBOL, s = Math.ceil(n.measureText(o).width), a = Math.ceil(n.measureText(t.BASELINE_SYMBOL).width), h = 2 * a; a = a * t.BASELINE_MULTIPLIER | 0, i.width = s, i.height = h, n.fillStyle = "#f00", n.fillRect(0, 0, s, h), n.font = e, n.textBaseline = "alphabetic", n.fillStyle = "#000", n.fillText(o, 0, a); var u = n.getImageData(0, 0, s, h).data, l = u.length, c = 4 * s, d = 0, p = 0, f = !1; for (d = 0; d < a; ++d) { for (var m = 0; m < c; m += 4)if (255 !== u[p + m]) { f = !0; break } if (f) break; p += c } for (r.ascent = a - d, p = l - c, f = !1, d = h; d > a; --d) { for (m = 0; m < c; m += 4)if (255 !== u[p + m]) { f = !0; break } if (f) break; p -= c } return r.descent = d - a, r.fontSize = r.ascent + r.descent, t._fonts[e] = r, r }, t.clearMetrics = function (e) { void 0 === e && (e = ""), e ? delete t._fonts[e] : t._fonts = {} }, t }(), ns = function () { try { var t = new OffscreenCanvas(0, 0), e = t.getContext("2d"); return e && e.measureText ? t : document.createElement("canvas") } catch (t) { return document.createElement("canvas") } }(); ns.width = ns.height = 10, is._canvas = ns, is._context = ns.getContext("2d"), is._fonts = {}, is.METRICS_STRING = "|ÉqÅ", is.BASELINE_SYMBOL = "M", is.BASELINE_MULTIPLIER = 1.4, is._newlines = [10, 13], is._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288]; var os = { texture: !0, children: !1, baseTexture: !0 }, ss = function (e) { function r(t, r, i) { var n = this, o = !1; i || (i = document.createElement("canvas"), o = !0), i.width = 3, i.height = 3; var s = Lr.from(i); return s.orig = new xe, s.trim = new xe, (n = e.call(this, s) || this)._ownCanvas = o, n.canvas = i, n.context = n.canvas.getContext("2d"), n._resolution = D.RESOLUTION, n._autoResolution = !0, n._text = null, n._style = null, n._styleListener = null, n._font = "", n.text = t, n.style = r, n.localStyleID = -1, n } return function (t, e) { function r() { this.constructor = t } Zo(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) }(r, e), r.prototype.updateText = function (t) { var e = this._style; if (this.localStyleID !== e.styleID && (this.dirty = !0, this.localStyleID = e.styleID), this.dirty || !t) { this._font = this._style.toFontString(); var r, i, n = this.context, o = is.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), s = o.width, a = o.height, h = o.lines, u = o.lineHeight, l = o.lineWidths, c = o.maxLineWidth, d = o.fontProperties; this.canvas.width = Math.ceil((Math.max(1, s) + 2 * e.padding) * this._resolution), this.canvas.height = Math.ceil((Math.max(1, a) + 2 * e.padding) * this._resolution), n.scale(this._resolution, this._resolution), n.clearRect(0, 0, this.canvas.width, this.canvas.height), n.font = this._font, n.lineWidth = e.strokeThickness, n.textBaseline = e.textBaseline, n.lineJoin = e.lineJoin, n.miterLimit = e.miterLimit; for (var p = e.dropShadow ? 2 : 1, f = 0; f < p; ++f) { var m = e.dropShadow && 0 === f, v = m ? Math.ceil(Math.max(1, a) + 2 * e.padding) : 0, g = v * this._resolution; if (m) { n.fillStyle = "black", n.strokeStyle = "black"; var y = e.dropShadowColor, _ = kt("number" == typeof y ? y : jt(y)); n.shadowColor = "rgba(" + 255 * _[0] + "," + 255 * _[1] + "," + 255 * _[2] + "," + e.dropShadowAlpha + ")", n.shadowBlur = e.dropShadowBlur, n.shadowOffsetX = Math.cos(e.dropShadowAngle) * e.dropShadowDistance, n.shadowOffsetY = Math.sin(e.dropShadowAngle) * e.dropShadowDistance + g } else n.fillStyle = this._generateFillStyle(e, h, o), n.strokeStyle = e.stroke, n.shadowColor = "black", n.shadowBlur = 0, n.shadowOffsetX = 0, n.shadowOffsetY = 0; for (var x = 0; x < h.length; x++)r = e.strokeThickness / 2, i = e.strokeThickness / 2 + x * u + d.ascent, "right" === e.align ? r += c - l[x] : "center" === e.align && (r += (c - l[x]) / 2), e.stroke && e.strokeThickness && this.drawLetterSpacing(h[x], r + e.padding, i + e.padding - v, !0), e.fill && this.drawLetterSpacing(h[x], r + e.padding, i + e.padding - v) } this.updateTexture() } }, r.prototype.drawLetterSpacing = function (t, e, r, i) { void 0 === i && (i = !1); var n = this._style.letterSpacing; if (0 !== n) for (var o = e, s = Array.from ? Array.from(t) : t.split(""), a = this.context.measureText(t).width, h = 0, u = 0; u < s.length; ++u) { var l = s[u]; i ? this.context.strokeText(l, o, r) : this.context.fillText(l, o, r), o += a - (h = this.context.measureText(t.substring(u + 1)).width) + n, a = h } else i ? this.context.strokeText(t, e, r) : this.context.fillText(t, e, r) }, r.prototype.updateTexture = function () { var t = this.canvas; if (this._style.trim) { var e = le(t); e.data && (t.width = e.width, t.height = e.height, this.context.putImageData(e.data, 0, 0)) } var r = this._texture, i = this._style, n = i.trim ? 0 : i.padding, o = r.baseTexture; r.trim.width = r._frame.width = Math.ceil(t.width / this._resolution), r.trim.height = r._frame.height = Math.ceil(t.height / this._resolution), r.trim.x = -n, r.trim.y = -n, r.orig.width = r._frame.width - 2 * n, r.orig.height = r._frame.height - 2 * n, this._onTextureUpdate(), o.setRealSize(t.width, t.height, this._resolution), this._recursivePostUpdateTransform(), this.dirty = !1 }, r.prototype._render = function (t) { this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution, this.dirty = !0), this.updateText(!0), e.prototype._render.call(this, t) }, r.prototype.getLocalBounds = function (t) { return this.updateText(!0), e.prototype.getLocalBounds.call(this, t) }, r.prototype._calculateBounds = function () { this.updateText(!0), this.calculateVertices(), this._bounds.addQuad(this.vertexData) }, r.prototype._generateFillStyle = function (e, r, i) { var n, o = e.fill; if (!Array.isArray(o)) return o; if (1 === o.length) return o[0]; var s = e.dropShadow ? e.dropShadowDistance : 0, a = e.padding || 0, h = Math.ceil(this.canvas.width / this._resolution) - s - 2 * a, u = Math.ceil(this.canvas.height / this._resolution) - s - 2 * a, l = o.slice(), c = e.fillGradientStops.slice(); if (!c.length) for (var d = l.length + 1, p = 1; p < d; ++p)c.push(p / d); if (l.unshift(o[0]), c.unshift(0), l.push(o[o.length - 1]), c.push(1), e.fillGradientType === t.TEXT_GRADIENT.LINEAR_VERTICAL) { n = this.context.createLinearGradient(h / 2, a, h / 2, u + a); var f = 0, m = (i.fontProperties.fontSize + e.strokeThickness) / u; for (p = 0; p < r.length; p++)for (var v = i.lineHeight * p, g = 0; g < l.length; g++) { var y = v / u + ("number" == typeof c[g] ? c[g] : g / l.length) * m, _ = Math.max(f, y); _ = Math.min(_, 1), n.addColorStop(_, l[g]), f = _ } } else { n = this.context.createLinearGradient(a, u / 2, h + a, u / 2); var x = l.length + 1, b = 1; for (p = 0; p < l.length; p++) { var E = void 0; E = "number" == typeof c[p] ? c[p] : b / x, n.addColorStop(E, l[p]), b++ } } return n }, r.prototype.destroy = function (t) { "boolean" == typeof t && (t = { children: t }), t = Object.assign({}, os, t), e.prototype.destroy.call(this, t), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null }, Object.defineProperty(r.prototype, "width", { get: function () { return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width }, set: function (t) { this.updateText(!0); var e = ee(this.scale.x) || 1; this.scale.x = e * t / this._texture.orig.width, this._width = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "height", { get: function () { return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height }, set: function (t) { this.updateText(!0); var e = ee(this.scale.y) || 1; this.scale.y = e * t / this._texture.orig.height, this._height = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "style", { get: function () { return this._style }, set: function (t) { t = t || {}, this._style = t instanceof $o ? t : new $o(t), this.localStyleID = -1, this.dirty = !0 }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "text", { get: function () { return this._text }, set: function (t) { t = String(null == t ? "" : t), this._text !== t && (this._text = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "resolution", { get: function () { return this._resolution }, set: function (t) { this._autoResolution = !1, this._resolution !== t && (this._resolution = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), r }(Ko); D.UPLOADS_PER_FRAME = 4; var as = function (t, e) { return (as = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; var hs = function () { function t(t) { this.maxItemsPerFrame = t, this.itemsLeft = 0 } return t.prototype.beginFrame = function () { this.itemsLeft = this.maxItemsPerFrame }, t.prototype.allowedToUpload = function () { return this.itemsLeft-- > 0 }, t }(); function us(t, e) { var r = !1; if (t && t._textures && t._textures.length) for (var i = 0; i < t._textures.length; i++)if (t._textures[i] instanceof Lr) { var n = t._textures[i].baseTexture; -1 === e.indexOf(n) && (e.push(n), r = !0) } return r } function ls(t, e) { if (t.baseTexture instanceof gr) { var r = t.baseTexture; return -1 === e.indexOf(r) && e.push(r), !0 } return !1 } function cs(t, e) { if (t._texture && t._texture instanceof Lr) { var r = t._texture.baseTexture; return -1 === e.indexOf(r) && e.push(r), !0 } return !1 } function ds(t, e) { return e instanceof ss && (e.updateText(!0), !0) } function ps(t, e) { if (e instanceof $o) { var r = e.toFontString(); return is.measureFont(r), !0 } return !1 } function fs(t, e) { if (t instanceof ss) { -1 === e.indexOf(t.style) && e.push(t.style), -1 === e.indexOf(t) && e.push(t); var r = t._texture.baseTexture; return -1 === e.indexOf(r) && e.push(r), !0 } return !1 } function ms(t, e) { return t instanceof $o && (-1 === e.indexOf(t) && e.push(t), !0) } var vs = function () { function e(t) { var e = this; this.limiter = new hs(D.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function () { e.queue && e.prepareItems() }, this.registerFindHook(fs), this.registerFindHook(ms), this.registerFindHook(us), this.registerFindHook(ls), this.registerFindHook(cs), this.registerUploadHook(ds), this.registerUploadHook(ps) } return e.prototype.upload = function (e, r) { "function" == typeof e && (r = e, e = null), e && this.add(e), this.queue.length ? (r && this.completes.push(r), this.ticking || (this.ticking = !0, Qe.system.addOnce(this.tick, this, t.UPDATE_PRIORITY.UTILITY))) : r && r() }, e.prototype.tick = function () { setTimeout(this.delayedTick, 0) }, e.prototype.prepareItems = function () { for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload();) { var e = this.queue[0], r = !1; if (e && !e._destroyed) for (var i = 0, n = this.uploadHooks.length; i < n; i++)if (this.uploadHooks[i](this.uploadHookHelper, e)) { this.queue.shift(), r = !0; break } r || this.queue.shift() } if (this.queue.length) Qe.system.addOnce(this.tick, this, t.UPDATE_PRIORITY.UTILITY); else { this.ticking = !1; var o = this.completes.slice(0); this.completes.length = 0; for (i = 0, n = o.length; i < n; i++)o[i]() } }, e.prototype.registerFindHook = function (t) { return t && this.addHooks.push(t), this }, e.prototype.registerUploadHook = function (t) { return t && this.uploadHooks.push(t), this }, e.prototype.add = function (t) { for (var e = 0, r = this.addHooks.length; e < r && !this.addHooks[e](t, this.queue); e++); if (t instanceof Ge) for (e = t.children.length - 1; e >= 0; e--)this.add(t.children[e]); return this }, e.prototype.destroy = function () { this.ticking && Qe.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null }, e }(); function gs(t, e) { return e instanceof gr && (e._glTextures[t.CONTEXT_UID] || t.texture.bind(e), !0) } function ys(t, e) { if (!(e instanceof Yo)) return !1; var r = e.geometry; e.finishPoly(), r.updateBatches(); for (var i = r.batches, n = 0; n < i.length; n++) { var o = i[n].style.texture; o && gs(t, o.baseTexture) } return r.batchable || t.geometry.bind(r, e._resolveDirectShader(t)), !0 } function _s(t, e) { return t instanceof Yo && (e.push(t), !0) } var xs = function (t) { function e(e) { var r = t.call(this, e) || this; return r.uploadHookHelper = r.renderer, r.registerFindHook(_s), r.registerUploadHook(gs), r.registerUploadHook(ys), r } return function (t, e) { function r() { this.constructor = t } as(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) }(e, t), e }(vs), bs = function () { function t(t) { this.maxMilliseconds = t, this.frameStart = 0 } return t.prototype.beginFrame = function () { this.frameStart = Date.now() }, t.prototype.allowedToUpload = function () { return Date.now() - this.frameStart < this.maxMilliseconds }, t }(), Es = function () { function t(t, e, r) { void 0 === r && (r = null), this._texture = t instanceof Lr ? t : null, this.baseTexture = t instanceof gr ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e; var i = this.baseTexture.resource; this.resolution = this._updateResolution(r || (i ? i.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null } return t.prototype._updateResolution = function (t) { void 0 === t && (t = null); var e = this.data.meta.scale, r = fe(t, null); return null === r && (r = void 0 !== e ? parseFloat(e) : 1), 1 !== r && this.baseTexture.setResolution(r), r }, t.prototype.parse = function (e) { this._batchIndex = 0, this._callback = e, this._frameKeys.length <= t.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch() }, t.prototype._processFrames = function (e) { for (var r = e, i = t.BATCH_SIZE; r - e < i && r < this._frameKeys.length;) { var n = this._frameKeys[r], o = this._frames[n], s = o.frame; if (s) { var a = null, h = null, u = !1 !== o.trimmed && o.sourceSize ? o.sourceSize : o.frame, l = new xe(0, 0, Math.floor(u.w) / this.resolution, Math.floor(u.h) / this.resolution); a = o.rotated ? new xe(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.h) / this.resolution, Math.floor(s.w) / this.resolution) : new xe(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution), !1 !== o.trimmed && o.spriteSourceSize && (h = new xe(Math.floor(o.spriteSourceSize.x) / this.resolution, Math.floor(o.spriteSourceSize.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution)), this.textures[n] = new Lr(this.baseTexture, a, l, h, o.rotated ? 2 : 0, o.anchor), Lr.addToCache(this.textures[n], n) } r++ } }, t.prototype._processAnimations = function () { var t = this.data.animations || {}; for (var e in t) { this.animations[e] = []; for (var r = 0; r < t[e].length; r++) { var i = t[e][r]; this.animations[e].push(this.textures[i]) } } }, t.prototype._parseComplete = function () { var t = this._callback; this._callback = null, this._batchIndex = 0, t.call(this, this.textures) }, t.prototype._nextBatch = function () { var e = this; this._processFrames(this._batchIndex * t.BATCH_SIZE), this._batchIndex++, setTimeout(function () { e._batchIndex * t.BATCH_SIZE < e._frameKeys.length ? e._nextBatch() : (e._processAnimations(), e._parseComplete()) }, 0) }, t.prototype.destroy = function (t) { var e; for (var r in void 0 === t && (t = !1), this.textures) this.textures[r].destroy(); this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && (null === (e = this._texture) || void 0 === e || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null }, t.BATCH_SIZE = 1e3, t }(), Ts = function () { function t() { } return t.use = function (e, r) { var i = e.name + "_image"; if (e.data && e.type === $n.TYPE.JSON && e.data.frames && !this.resources[i]) { var n = { crossOrigin: e.crossOrigin, metadata: e.metadata.imageMetadata, parentResource: e }, o = t.getResourcePath(e, this.baseUrl); this.add(i, o, n, function (t) { if (t.error) r(t.error); else { var i = new Es(t.texture, e.data, e.url); i.parse(function () { e.spritesheet = i, e.textures = i.textures, r() }) } }) } else r() }, t.getResourcePath = function (t, e) { return t.isDataUrl ? t.data.meta.image : Rt.resolve(t.url.replace(e, ""), t.data.meta.image) }, t }(), Ss = function (t, e) { return (Ss = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; function ws(t, e) { function r() { this.constructor = t } Ss(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var Ps = new we, Is = function (t) { function e(e, r, i) { void 0 === r && (r = 100), void 0 === i && (i = 100); var n = t.call(this, e) || this; return n.tileTransform = new Fe, n._width = r, n._height = i, n.uvMatrix = n.texture.uvMatrix || new Xi(e), n.pluginName = "tilingSprite", n.uvRespectAnchor = !1, n } return ws(e, t), Object.defineProperty(e.prototype, "clampMargin", { get: function () { return this.uvMatrix.clampMargin }, set: function (t) { this.uvMatrix.clampMargin = t, this.uvMatrix.update(!0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "tileScale", { get: function () { return this.tileTransform.scale }, set: function (t) { this.tileTransform.scale.copyFrom(t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "tilePosition", { get: function () { return this.tileTransform.position }, set: function (t) { this.tileTransform.position.copyFrom(t) }, enumerable: !1, configurable: !0 }), e.prototype._onTextureUpdate = function () { this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215 }, e.prototype._render = function (t) { var e = this._texture; e && e.valid && (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this)) }, e.prototype._calculateBounds = function () { var t = this._width * -this._anchor._x, e = this._height * -this._anchor._y, r = this._width * (1 - this._anchor._x), i = this._height * (1 - this._anchor._y); this._bounds.addFrame(this.transform, t, e, r, i) }, e.prototype.getLocalBounds = function (e) { return 0 === this.children.length ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new xe), e = this._localBoundsRect), this._bounds.getRectangle(e)) : t.prototype.getLocalBounds.call(this, e) }, e.prototype.containsPoint = function (t) { this.worldTransform.applyInverse(t, Ps); var e = this._width, r = this._height, i = -e * this.anchor._x; if (Ps.x >= i && Ps.x < i + e) { var n = -r * this.anchor._y; if (Ps.y >= n && Ps.y < n + r) return !0 } return !1 }, e.prototype.destroy = function (e) { t.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null }, e.from = function (t, r) { return "number" == typeof r && (oe("5.3.0", "TilingSprite.from use options instead of width and height args"), r = { width: r, height: arguments[2] }), new e(Lr.from(t, r), r.width, r.height) }, Object.defineProperty(e.prototype, "width", { get: function () { return this._width }, set: function (t) { this._width = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "height", { get: function () { return this._height }, set: function (t) { this._height = t }, enumerable: !1, configurable: !0 }), e }(Ko), As = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n", Os = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture2D(uSampler, coord);\n    gl_FragColor = texSample * uColor;\n}\n", Ms = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 sample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = sample * uColor;\n}\n", Ds = new Ie, Cs = function (e) { function r(t) { var r = e.call(this, t) || this, i = { globals: r.renderer.globalUniforms }; return r.shader = Li.from(As, Os, i), r.simpleShader = Li.from(As, Ms, i), r.quad = new qr, r.state = Ni.for2d(), r } return ws(r, e), r.prototype.render = function (e) { var r = this.renderer, i = this.quad, n = i.vertices; n[0] = n[6] = e._width * -e.anchor.x, n[1] = n[3] = e._height * -e.anchor.y, n[2] = n[4] = e._width * (1 - e.anchor.x), n[5] = n[7] = e._height * (1 - e.anchor.y), e.uvRespectAnchor && ((n = i.uvs)[0] = n[6] = -e.anchor.x, n[1] = n[3] = -e.anchor.y, n[2] = n[4] = 1 - e.anchor.x, n[5] = n[7] = 1 - e.anchor.y), i.invalidate(); var o = e._texture, s = o.baseTexture, a = e.tileTransform.localTransform, h = e.uvMatrix, u = s.isPowerOfTwo && o.frame.width === s.width && o.frame.height === s.height; u && (s._glTextures[r.CONTEXT_UID] ? u = s.wrapMode !== t.WRAP_MODES.CLAMP : s.wrapMode === t.WRAP_MODES.CLAMP && (s.wrapMode = t.WRAP_MODES.REPEAT)); var l = u ? this.simpleShader : this.shader, c = o.width, d = o.height, p = e._width, f = e._height; Ds.set(a.a * c / p, a.b * c / f, a.c * d / p, a.d * d / f, a.tx / p, a.ty / f), Ds.invert(), u ? Ds.prepend(h.mapCoord) : (l.uniforms.uMapCoord = h.mapCoord.toArray(!0), l.uniforms.uClampFrame = h.uClampFrame, l.uniforms.uClampOffset = h.uClampOffset), l.uniforms.uTransform = Ds.toArray(!0), l.uniforms.uColor = Wt(e.tint, e.worldAlpha, l.uniforms.uColor, s.alphaMode), l.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0), l.uniforms.uSampler = o, r.shader.bind(l), r.geometry.bind(i), this.state.blendMode = Yt(e.blendMode, s.alphaMode), r.state.set(this.state), r.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0) }, r }($r), Rs = function (t, e) { return (Rs = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; function Ls(t, e) { function r() { this.constructor = t } Rs(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var Ns = function () { function t(t, e) { this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0 } return t.prototype.update = function (t) { if (t || this._bufferUpdateId !== this.uvBuffer._updateID || this._textureUpdateId !== this.uvMatrix._updateID) { this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID; var e = this.uvBuffer.data; this.data && this.data.length === e.length || (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++ } }, t }(), Fs = new we, Bs = new Te, Us = function (e) { function r(r, i, n, o) { void 0 === o && (o = t.DRAW_MODES.TRIANGLES); var s = e.call(this) || this; return s.geometry = r, r.refCount++, s.shader = i, s.state = n || Ni.for2d(), s.drawMode = o, s.start = 0, s.size = 0, s.uvs = null, s.indices = null, s.vertexData = new Float32Array(1), s.vertexDirty = 0, s._transformID = -1, s._roundPixels = D.ROUND_PIXELS, s.batchUvs = null, s } return Ls(r, e), Object.defineProperty(r.prototype, "uvBuffer", { get: function () { return this.geometry.buffers[1] }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "verticesBuffer", { get: function () { return this.geometry.buffers[0] }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "material", { get: function () { return this.shader }, set: function (t) { this.shader = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "blendMode", { get: function () { return this.state.blendMode }, set: function (t) { this.state.blendMode = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "roundPixels", { get: function () { return this._roundPixels }, set: function (t) { this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "tint", { get: function () { return this.shader.tint }, set: function (t) { this.shader.tint = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "texture", { get: function () { return this.shader.texture }, set: function (t) { this.shader.texture = t }, enumerable: !1, configurable: !0 }), r.prototype._render = function (e) { var i = this.geometry.buffers[0].data; this.shader.batchable && this.drawMode === t.DRAW_MODES.TRIANGLES && i.length < 2 * r.BATCHABLE_SIZE ? this._renderToBatch(e) : this._renderDefault(e) }, r.prototype._renderDefault = function (t) { var e = this.shader; e.alpha = this.worldAlpha, e.update && e.update(), t.batch.flush(), e.program.uniformData.translationMatrix && (e.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0)), t.shader.bind(e), t.state.set(this.state), t.geometry.bind(this.geometry, e), t.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount) }, r.prototype._renderToBatch = function (t) { var e = this.geometry; this.shader.uvMatrix && (this.shader.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = e.indexBuffer.data, this._tintRGB = this.shader._tintRGB, this._texture = this.shader.texture; var r = this.material.pluginName; t.batch.setObjectRenderer(t.plugins[r]), t.plugins[r].render(this) }, r.prototype.calculateVertices = function () { var t = this.geometry, e = t.buffers[0].data; if (t.vertexDirtyId !== this.vertexDirty || this._transformID !== this.transform._worldID) { this._transformID = this.transform._worldID, this.vertexData.length !== e.length && (this.vertexData = new Float32Array(e.length)); for (var r = this.transform.worldTransform, i = r.a, n = r.b, o = r.c, s = r.d, a = r.tx, h = r.ty, u = this.vertexData, l = 0; l < u.length / 2; l++) { var c = e[2 * l], d = e[2 * l + 1]; u[2 * l] = i * c + o * d + a, u[2 * l + 1] = n * c + s * d + h } if (this._roundPixels) { var p = D.RESOLUTION; for (l = 0; l < u.length; ++l)u[l] = Math.round((u[l] * p | 0) / p) } this.vertexDirty = t.vertexDirtyId } }, r.prototype.calculateUvs = function () { var t = this.geometry.buffers[1]; this.shader.uvMatrix.isSimple ? this.uvs = t.data : (this.batchUvs || (this.batchUvs = new Ns(t, this.shader.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data) }, r.prototype._calculateBounds = function () { this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length) }, r.prototype.containsPoint = function (t) { if (!this.getBounds().contains(t.x, t.y)) return !1; this.worldTransform.applyInverse(t, Fs); for (var e = this.geometry.getBuffer("aVertexPosition").data, r = Bs.points, i = this.geometry.getIndex().data, n = i.length, o = 4 === this.drawMode ? 3 : 1, s = 0; s + 2 < n; s += o) { var a = 2 * i[s], h = 2 * i[s + 1], u = 2 * i[s + 2]; if (r[0] = e[a], r[1] = e[a + 1], r[2] = e[h], r[3] = e[h + 1], r[4] = e[u], r[5] = e[u + 1], Bs.contains(Fs.x, Fs.y)) return !0 } return !1 }, r.prototype.destroy = function (t) { e.prototype.destroy.call(this, t), this.geometry.refCount--, 0 === this.geometry.refCount && this.geometry.dispose(), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null }, r.BATCHABLE_SIZE = 100, r }(Ge), ks = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n", Xs = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n", js = function (t) { function e(e, r) { var i = this, n = { uSampler: e, alpha: 1, uTextureMatrix: Ie.IDENTITY, uColor: new Float32Array([1, 1, 1, 1]) }; return (r = Object.assign({ tint: 16777215, alpha: 1, pluginName: "batch" }, r)).uniforms && Object.assign(n, r.uniforms), (i = t.call(this, r.program || Ri.from(Xs, ks), n) || this)._colorDirty = !1, i.uvMatrix = new Xi(e), i.batchable = void 0 === r.program, i.pluginName = r.pluginName, i.tint = r.tint, i.alpha = r.alpha, i } return Ls(e, t), Object.defineProperty(e.prototype, "texture", { get: function () { return this.uniforms.uSampler }, set: function (t) { this.uniforms.uSampler !== t && (this.uniforms.uSampler = t, this.uvMatrix.texture = t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "alpha", { get: function () { return this._alpha }, set: function (t) { t !== this._alpha && (this._alpha = t, this._colorDirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "tint", { get: function () { return this._tint }, set: function (t) { t !== this._tint && (this._tint = t, this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16), this._colorDirty = !0) }, enumerable: !1, configurable: !0 }), e.prototype.update = function () { if (this._colorDirty) { this._colorDirty = !1; var t = this.texture.baseTexture; Wt(this._tint, this._alpha, this.uniforms.uColor, t.alphaMode) } this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord) }, e }(Li), Hs = function (e) { function r(r, i, n) { var o = e.call(this) || this, s = new Xr(r), a = new Xr(i, !0), h = new Xr(n, !0, !0); return o.addAttribute("aVertexPosition", s, 2, !1, t.TYPES.FLOAT).addAttribute("aTextureCoord", a, 2, !1, t.TYPES.FLOAT).addIndex(h), o._updateId = -1, o } return Ls(r, e), Object.defineProperty(r.prototype, "vertexDirtyId", { get: function () { return this.buffers[0]._updateID }, enumerable: !1, configurable: !0 }), r }(Vr), Gs = function (t, e) { return (Gs = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; var Ys = function () { return function () { this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [] } }(), zs = function () { function t() { } return t.test = function (t) { return "string" == typeof t && 0 === t.indexOf("info face=") }, t.parse = function (t) { var e = t.match(/^[a-z]+\s+.+$/gm), r = { info: [], common: [], page: [], char: [], chars: [], kerning: [], kernings: [] }; for (var i in e) { var n = e[i].match(/^[a-z]+/gm)[0], o = e[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), s = {}; for (var a in o) { var h = o[a].split("="), u = h[0], l = h[1].replace(/"/gm, ""), c = parseFloat(l), d = isNaN(c) ? l : c; s[u] = d } r[n].push(s) } var p = new Ys; return r.info.forEach(function (t) { return p.info.push({ face: t.face, size: parseInt(t.size, 10) }) }), r.common.forEach(function (t) { return p.common.push({ lineHeight: parseInt(t.lineHeight, 10) }) }), r.page.forEach(function (t) { return p.page.push({ id: parseInt(t.id, 10), file: t.file }) }), r.char.forEach(function (t) { return p.char.push({ id: parseInt(t.id, 10), page: parseInt(t.page, 10), x: parseInt(t.x, 10), y: parseInt(t.y, 10), width: parseInt(t.width, 10), height: parseInt(t.height, 10), xoffset: parseInt(t.xoffset, 10), yoffset: parseInt(t.yoffset, 10), xadvance: parseInt(t.xadvance, 10) }) }), r.kerning.forEach(function (t) { return p.kerning.push({ first: parseInt(t.first, 10), second: parseInt(t.second, 10), amount: parseInt(t.amount, 10) }) }), p }, t }(), Vs = function () { function t() { } return t.test = function (t) { return t instanceof XMLDocument && t.getElementsByTagName("page").length && null !== t.getElementsByTagName("info")[0].getAttribute("face") }, t.parse = function (t) { for (var e = new Ys, r = t.getElementsByTagName("info"), i = t.getElementsByTagName("common"), n = t.getElementsByTagName("page"), o = t.getElementsByTagName("char"), s = t.getElementsByTagName("kerning"), a = 0; a < r.length; a++)e.info.push({ face: r[a].getAttribute("face"), size: parseInt(r[a].getAttribute("size"), 10) }); for (a = 0; a < i.length; a++)e.common.push({ lineHeight: parseInt(i[a].getAttribute("lineHeight"), 10) }); for (a = 0; a < n.length; a++)e.page.push({ id: parseInt(n[a].getAttribute("id"), 10) || 0, file: n[a].getAttribute("file") }); for (a = 0; a < o.length; a++) { var h = o[a]; e.char.push({ id: parseInt(h.getAttribute("id"), 10), page: parseInt(h.getAttribute("page"), 10) || 0, x: parseInt(h.getAttribute("x"), 10), y: parseInt(h.getAttribute("y"), 10), width: parseInt(h.getAttribute("width"), 10), height: parseInt(h.getAttribute("height"), 10), xoffset: parseInt(h.getAttribute("xoffset"), 10), yoffset: parseInt(h.getAttribute("yoffset"), 10), xadvance: parseInt(h.getAttribute("xadvance"), 10) }) } for (a = 0; a < s.length; a++)e.kerning.push({ first: parseInt(s[a].getAttribute("first"), 10), second: parseInt(s[a].getAttribute("second"), 10), amount: parseInt(s[a].getAttribute("amount"), 10) }); return e }, t }(), Ws = function () { function t() { } return t.test = function (t) { if ("string" == typeof t && t.indexOf("<font>") > -1) { var e = (new self.DOMParser).parseFromString(t, "text/xml"); return Vs.test(e) } return !1 }, t.parse = function (t) { var e = (new window.DOMParser).parseFromString(t, "text/xml"); return Vs.parse(e) }, t }(), qs = [zs, Vs, Ws]; function Ks(t) { for (var e = 0; e < qs.length; e++)if (qs[e].test(t)) return qs[e]; return null } function Zs(e, r, i, n, o, s) { var a, h = i.fill; if (!Array.isArray(h)) return h; if (1 === h.length) return h[0]; var u = i.dropShadow ? i.dropShadowDistance : 0, l = i.padding || 0, c = Math.ceil(e.width / n) - u - 2 * l, d = Math.ceil(e.height / n) - u - 2 * l, p = h.slice(), f = i.fillGradientStops.slice(); if (!f.length) for (var m = p.length + 1, v = 1; v < m; ++v)f.push(v / m); if (p.unshift(h[0]), f.unshift(0), p.push(h[h.length - 1]), f.push(1), i.fillGradientType === t.TEXT_GRADIENT.LINEAR_VERTICAL) { a = r.createLinearGradient(c / 2, l, c / 2, d + l); var g = 0, y = (s.fontProperties.fontSize + i.strokeThickness) / d; for (v = 0; v < o.length; v++)for (var _ = s.lineHeight * v, x = 0; x < p.length; x++) { var b = _ / d + ("number" == typeof f[x] ? f[x] : x / p.length) * y, E = Math.max(g, b); E = Math.min(E, 1), a.addColorStop(E, p[x]), g = E } } else { a = r.createLinearGradient(l, d / 2, c + l, d / 2); var T = p.length + 1, S = 1; for (v = 0; v < p.length; v++) { var w = void 0; w = "number" == typeof f[v] ? f[v] : S / T, a.addColorStop(w, p[v]), S++ } } return a } function Js(t, e, r, i, n, o, s) { var a = r.text, h = r.fontProperties; e.translate(i, n), e.scale(o, o); var u = s.strokeThickness / 2, l = -s.strokeThickness / 2; e.font = s.toFontString(), e.lineWidth = s.strokeThickness, e.textBaseline = s.textBaseline, e.lineJoin = s.lineJoin, e.miterLimit = s.miterLimit, e.fillStyle = Zs(t, e, s, o, [a], r), e.strokeStyle = s.stroke, e.font = s.toFontString(), e.lineWidth = s.strokeThickness, e.textBaseline = s.textBaseline, e.lineJoin = s.lineJoin, e.miterLimit = s.miterLimit, e.fillStyle = Zs(t, e, s, o, [a], r), e.strokeStyle = s.stroke; var c = s.dropShadowColor, d = kt("number" == typeof c ? c : jt(c)); s.dropShadow ? (e.shadowColor = "rgba(" + 255 * d[0] + "," + 255 * d[1] + "," + 255 * d[2] + "," + s.dropShadowAlpha + ")", e.shadowBlur = s.dropShadowBlur, e.shadowOffsetX = Math.cos(s.dropShadowAngle) * s.dropShadowDistance, e.shadowOffsetY = Math.sin(s.dropShadowAngle) * s.dropShadowDistance) : (e.shadowColor = "black", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0), s.stroke && s.strokeThickness && e.strokeText(a, u, l + r.lineHeight - h.descent), s.fill && e.fillText(a, u, l + r.lineHeight - h.descent), e.setTransform(1, 0, 0, 1, 0, 0), e.fillStyle = "rgba(0, 0, 0, 0)" } var Qs = function () { function t(t, e) { var r = t.info[0], i = t.common[0], n = fe(t.page[0].file), o = {}; this.font = r.face, this.size = r.size, this.lineHeight = i.lineHeight / n, this.chars = {}, this.pageTextures = o; for (var s = 0; s < t.page.length; s++) { var a = t.page[s], h = a.id, u = a.file; o[h] = e instanceof Array ? e[s] : e[u] } for (s = 0; s < t.char.length; s++) { var l = t.char[s], c = (h = l.id, l.page), d = t.char[s], p = d.x, f = d.y, m = d.width, v = d.height, g = d.xoffset, y = d.yoffset, _ = d.xadvance; f /= n, m /= n, v /= n, g /= n, y /= n, _ /= n; var x = new xe((p /= n) + o[c].frame.x / n, f + o[c].frame.y / n, m, v); this.chars[h] = { xOffset: g, yOffset: y, xAdvance: _, kerning: {}, texture: new Lr(o[c].baseTexture, x), page: c } } for (s = 0; s < t.kerning.length; s++) { var b = t.kerning[s], E = b.first, T = b.second, S = b.amount; E /= n, T /= n, S /= n, this.chars[T] && (this.chars[T].kerning[E] = S) } } return t.prototype.destroy = function () { for (var t in this.chars) this.chars[t].texture.destroy(), this.chars[t].texture = null; for (var t in this.pageTextures) this.pageTextures[t].destroy(!0), this.pageTextures[t] = null; this.chars = null, this.pageTextures = null }, t.install = function (e, r) { var i; if (e instanceof Ys) i = e; else { var n = Ks(e); if (!n) throw new Error("Unrecognized data format for font."); i = n.parse(e) } r instanceof Lr && (r = [r]); var o = new t(i, r); return t.available[o.font] = o, o }, t.uninstall = function (e) { var r = t.available[e]; if (!r) throw new Error("No font found named '" + e + "'"); r.destroy(), delete t.available[e] }, t.from = function (e, r, i) { if (!e) throw new Error("[BitmapFont] Property `name` is required."); var n = Object.assign({}, t.defaultOptions, i), o = n.chars, s = n.padding, a = n.resolution, h = n.textureWidth, u = n.textureHeight, l = function (t) { "string" == typeof t && (t = [t]); for (var e = [], r = 0, i = t.length; r < i; r++) { var n = t[r]; if (Array.isArray(n)) { if (2 !== n.length) throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + n.length + "."); var o = n[0].charCodeAt(0), s = n[1].charCodeAt(0); if (s < o) throw new Error("[BitmapFont]: Invalid character range."); for (var a = o, h = s; a <= h; a++)e.push(String.fromCharCode(a)) } else e.push.apply(e, n.split("")) } if (0 === e.length) throw new Error("[BitmapFont]: Empty set when resolving characters."); return e }(o), c = r instanceof $o ? r : new $o(r), d = h, p = new Ys; p.info[0] = { face: c.fontFamily, size: c.fontSize }, p.common[0] = { lineHeight: c.fontSize }; for (var f, m, v, g = 0, y = 0, _ = 0, x = [], b = 0; b < l.length; b++) { f || ((f = document.createElement("canvas")).width = h, f.height = u, m = f.getContext("2d"), v = new gr(f, { resolution: a }), x.push(new Lr(v)), p.page.push({ id: x.length - 1, file: "" })); var E = is.measureText(l[b], c, !1, f), T = E.width, S = Math.ceil(E.height), w = Math.ceil(("italic" === c.fontStyle ? 2 : 1) * T); if (y >= u - S * a) { if (0 === y) throw new Error("[BitmapFont] textureHeight " + u + "px is too small for " + c.fontSize + "px fonts"); --b, f = null, m = null, v = null, y = 0, g = 0, _ = 0 } else if (_ = Math.max(S + E.fontProperties.descent, _), w * a + g >= d) --b, y += _ * a, y = Math.ceil(y), g = 0, _ = 0; else { Js(f, m, E, g, y, a, c); var P = E.text.charCodeAt(0); p.char.push({ id: P, page: x.length - 1, x: g / a, y: y / a, width: w, height: S, xoffset: 0, yoffset: 0, xadvance: Math.ceil(T - (c.dropShadow ? c.dropShadowDistance : 0) - (c.stroke ? c.strokeThickness : 0)) }), g += (w + 2 * s) * a, g = Math.ceil(g) } } var I = new t(p, x); return void 0 !== t.available[e] && t.uninstall(e), t.available[e] = I, I }, t.ALPHA = [["a", "z"], ["A", "Z"], " "], t.NUMERIC = [["0", "9"]], t.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], t.ASCII = [[" ", "~"]], t.defaultOptions = { resolution: 1, textureWidth: 512, textureHeight: 512, padding: 4, chars: t.ALPHANUMERIC }, t.available = {}, t }(), $s = [], ta = [], ea = function (t) { function e(r, i) { void 0 === i && (i = {}); var n = t.call(this) || this; n._tint = 16777215, i.font && (oe("5.3.0", "PIXI.BitmapText constructor style.font property is deprecated."), n._upgradeStyle(i)); var o = Object.assign({}, e.styleDefaults, i), s = o.align, a = o.tint, h = o.maxWidth, u = o.letterSpacing, l = o.fontName, c = o.fontSize; if (!Qs.available[l]) throw new Error('Missing BitmapFont "' + l + '"'); return n._activePagesMeshData = [], n._textWidth = 0, n._textHeight = 0, n._align = s, n._tint = a, n._fontName = l, n._fontSize = c || Qs.available[l].size, n._text = r, n._maxWidth = h, n._maxLineHeight = 0, n._letterSpacing = u, n._anchor = new Pe(function () { n.dirty = !0 }, n, 0, 0), n._roundPixels = D.ROUND_PIXELS, n.dirty = !0, n._textureCache = {}, n } return function (t, e) { function r() { this.constructor = t } Gs(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) }(e, t), e.prototype.updateText = function () { for (var t, e = Qs.available[this._fontName], r = this._fontSize / e.size, i = new we, n = [], o = [], s = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ", a = s.length, h = this._maxWidth * e.size / this._fontSize, u = null, l = 0, c = 0, d = 0, p = -1, f = 0, m = 0, v = 0, g = 0; g < a; g++) { var y = s.charCodeAt(g), _ = s.charAt(g); if (/(?:\s)/.test(_) && (p = g, f = l), "\r" !== _ && "\n" !== _) { var x = e.chars[y]; if (x) { u && x.kerning[u] && (i.x += x.kerning[u]); var b = ta.pop() || { texture: Lr.EMPTY, line: 0, charCode: 0, position: new we }; b.texture = x.texture, b.line = d, b.charCode = y, b.position.x = i.x + x.xOffset + this._letterSpacing / 2, b.position.y = i.y + x.yOffset, n.push(b), i.x += x.xAdvance + this._letterSpacing, l = i.x, v = Math.max(v, x.yOffset + x.texture.height), u = y, -1 !== p && h > 0 && i.x > h && (te(n, 1 + p - ++m, 1 + g - p), g = p, p = -1, o.push(f), c = Math.max(c, f), d++, i.x = 0, i.y += e.lineHeight, u = null) } } else o.push(l), c = Math.max(c, l), ++d, ++m, i.x = 0, i.y += e.lineHeight, u = null } var E = s.charAt(s.length - 1); "\r" !== E && "\n" !== E && (/(?:\s)/.test(E) && (l = f), o.push(l), c = Math.max(c, l)); var T = []; for (g = 0; g <= d; g++) { var S = 0; "right" === this._align ? S = c - o[g] : "center" === this._align && (S = (c - o[g]) / 2), T.push(S) } var w = n.length, P = {}, I = [], A = this._activePagesMeshData; for (g = 0; g < A.length; g++)$s.push(A[g]); for (g = 0; g < w; g++) { var O = (U = n[g].texture).baseTexture.uid; if (!P[O]) { if (!(z = $s.pop())) { var M = new Hs, D = new js(Lr.EMPTY); z = { index: 0, indexCount: 0, vertexCount: 0, uvsCount: 0, total: 0, mesh: new Us(M, D), vertices: null, uvs: null, indices: null } } z.index = 0, z.indexCount = 0, z.vertexCount = 0, z.uvsCount = 0, z.total = 0; var C = this._textureCache; C[O] = C[O] || new Lr(U.baseTexture), z.mesh.texture = C[O], z.mesh.tint = this._tint, I.push(z), P[O] = z } P[O].total++ } for (g = 0; g < A.length; g++)-1 === I.indexOf(A[g]) && this.removeChild(A[g].mesh); for (g = 0; g < I.length; g++)I[g].mesh.parent !== this && this.addChild(I[g].mesh); for (var g in this._activePagesMeshData = I, P) { var R = (z = P[g]).total; if (!((null === (t = z.indices) || void 0 === t ? void 0 : t.length) > 6 * R) || z.vertices.length < 2 * Us.BATCHABLE_SIZE) z.vertices = new Float32Array(8 * R), z.uvs = new Float32Array(8 * R), z.indices = new Uint16Array(6 * R); else for (var L = z.total, N = z.vertices, F = 4 * L * 2; F < N.length; F++)N[F] = 0; z.mesh.size = 6 * R } for (g = 0; g < w; g++) { var B = (_ = n[g]).position.x + T[_.line]; this._roundPixels && (B = Math.round(B)); var U, k = B * r, X = _.position.y * r, j = P[(U = _.texture).baseTexture.uid], H = U.frame, G = U._uvs, Y = j.index++; j.indices[6 * Y + 0] = 0 + 4 * Y, j.indices[6 * Y + 1] = 1 + 4 * Y, j.indices[6 * Y + 2] = 2 + 4 * Y, j.indices[6 * Y + 3] = 0 + 4 * Y, j.indices[6 * Y + 4] = 2 + 4 * Y, j.indices[6 * Y + 5] = 3 + 4 * Y, j.vertices[8 * Y + 0] = k, j.vertices[8 * Y + 1] = X, j.vertices[8 * Y + 2] = k + H.width * r, j.vertices[8 * Y + 3] = X, j.vertices[8 * Y + 4] = k + H.width * r, j.vertices[8 * Y + 5] = X + H.height * r, j.vertices[8 * Y + 6] = k, j.vertices[8 * Y + 7] = X + H.height * r, j.uvs[8 * Y + 0] = G.x0, j.uvs[8 * Y + 1] = G.y0, j.uvs[8 * Y + 2] = G.x1, j.uvs[8 * Y + 3] = G.y1, j.uvs[8 * Y + 4] = G.x2, j.uvs[8 * Y + 5] = G.y2, j.uvs[8 * Y + 6] = G.x3, j.uvs[8 * Y + 7] = G.y3 } for (var g in this._textWidth = c * r, this._textHeight = (i.y + e.lineHeight) * r, P) { var z = P[g]; if (0 !== this.anchor.x || 0 !== this.anchor.y) for (var V = 0, W = this._textWidth * this.anchor.x, q = this._textHeight * this.anchor.y, K = 0; K < z.total; K++)z.vertices[V++] -= W, z.vertices[V++] -= q, z.vertices[V++] -= W, z.vertices[V++] -= q, z.vertices[V++] -= W, z.vertices[V++] -= q, z.vertices[V++] -= W, z.vertices[V++] -= q; this._maxLineHeight = v * r; var Z = z.mesh.geometry.getBuffer("aVertexPosition"), J = z.mesh.geometry.getBuffer("aTextureCoord"), Q = z.mesh.geometry.getIndex(); Z.data = z.vertices, J.data = z.uvs, Q.data = z.indices, Z.update(), J.update(), Q.update() } for (g = 0; g < n.length; g++)ta.push(n[g]) }, e.prototype.updateTransform = function () { this.validate(), this.containerUpdateTransform() }, e.prototype.getLocalBounds = function () { return this.validate(), t.prototype.getLocalBounds.call(this) }, e.prototype.validate = function () { this.dirty && (this.updateText(), this.dirty = !1) }, Object.defineProperty(e.prototype, "tint", { get: function () { return this._tint }, set: function (t) { if (this._tint !== t) { this._tint = t; for (var e = 0; e < this._activePagesMeshData.length; e++)this._activePagesMeshData[e].mesh.tint = t } }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "align", { get: function () { return this._align }, set: function (t) { this._align !== t && (this._align = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "fontName", { get: function () { return this._fontName }, set: function (t) { if (!Qs.available[t]) throw new Error('Missing BitmapFont "' + t + '"'); this._fontName !== t && (this._fontName = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "fontSize", { get: function () { return this._fontSize }, set: function (t) { this._fontSize !== t && (this._fontSize = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "anchor", { get: function () { return this._anchor }, set: function (t) { "number" == typeof t ? this._anchor.set(t) : this._anchor.copyFrom(t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "text", { get: function () { return this._text }, set: function (t) { t = String(null == t ? "" : t), this._text !== t && (this._text = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "maxWidth", { get: function () { return this._maxWidth }, set: function (t) { this._maxWidth !== t && (this._maxWidth = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "maxLineHeight", { get: function () { return this.validate(), this._maxLineHeight }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "textWidth", { get: function () { return this.validate(), this._textWidth }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "letterSpacing", { get: function () { return this._letterSpacing }, set: function (t) { this._letterSpacing !== t && (this._letterSpacing = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "roundPixels", { get: function () { return this._roundPixels }, set: function (t) { t !== this._roundPixels && (this._roundPixels = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "textHeight", { get: function () { return this.validate(), this._textHeight }, enumerable: !1, configurable: !0 }), e.prototype._upgradeStyle = function (t) { if ("string" == typeof t.font) { var e = t.font.split(" "); t.fontName = 1 === e.length ? e[0] : e.slice(1).join(" "), e.length >= 2 && (t.fontSize = parseInt(e[0], 10)) } else t.fontName = t.font.name, t.fontSize = "number" == typeof t.font.size ? t.font.size : parseInt(t.font.size, 10) }, e.prototype.destroy = function (e) { var r = this._textureCache; for (var i in r) { r[i].destroy(), delete r[i] } this._textureCache = null, t.prototype.destroy.call(this, e) }, e.registerFont = function (t, e) { return oe("5.3.0", "PIXI.BitmapText.registerFont is deprecated, use PIXI.BitmapFont.install"), Qs.install(t, e) }, Object.defineProperty(e, "fonts", { get: function () { return oe("5.3.0", "PIXI.BitmapText.fonts is deprecated, use PIXI.BitmapFont.available"), Qs.available }, enumerable: !1, configurable: !0 }), e.styleDefaults = { align: "left", tint: 16777215, maxWidth: 0, letterSpacing: 0 }, e }(Ge), ra = function () { function t() { } return t.add = function () { $n.setExtensionXhrType("fnt", $n.XHR_RESPONSE_TYPE.TEXT) }, t.use = function (e, r) { var i = Ks(e.data); if (i) for (var n = t.getBaseUrl(this, e), o = i.parse(e.data), s = {}, a = function (t) { s[t.metadata.pageFile] = t.texture, Object.keys(s).length === o.page.length && (e.bitmapFont = Qs.install(o, s), r()) }, h = 0; h < o.page.length; ++h) { var u = o.page[h].file, l = n + u, c = !1; for (var d in this.resources) { var p = this.resources[d]; if (p.url === l) { p.metadata.pageFile = u, p.texture ? a(p) : p.onAfterMiddleware.add(a), c = !0; break } } if (!c) { var f = { crossOrigin: e.crossOrigin, loadType: $n.LOAD_TYPE.IMAGE, metadata: Object.assign({ pageFile: u }, e.metadata.imageMetadata), parentResource: e }; this.add(l, f, a) } } else r() }, t.getBaseUrl = function (e, r) { var i = r.isDataUrl ? "" : t.dirname(r.url); return r.isDataUrl && ("." === i && (i = ""), e.baseUrl && i && "/" === e.baseUrl.charAt(e.baseUrl.length - 1) && (i += "/")), (i = i.replace(e.baseUrl, "")) && "/" !== i.charAt(i.length - 1) && (i += "/"), i }, t.dirname = function (t) { var e = t.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, ""); return e === t ? "." : "" === e ? "/" : e }, t }(), ia = function (t, e) { return (ia = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; var na = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n", oa = function (t) { function e(e) { void 0 === e && (e = 1); var r = t.call(this, gn, na, { uAlpha: 1 }) || this; return r.alpha = e, r } return function (t, e) { function r() { this.constructor = t } ia(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) }(e, t), Object.defineProperty(e.prototype, "alpha", { get: function () { return this.uniforms.uAlpha }, set: function (t) { this.uniforms.uAlpha = t }, enumerable: !1, configurable: !0 }), e }(Fi), sa = function (t, e) { return (sa = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; function aa(t, e) { function r() { this.constructor = t } sa(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var ha = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }"; var ua, la, ca, da, pa, fa, ma, va, ga, ya, _a, xa, ba, Ea, Ta, Sa, wa, Pa = { 5: [.153388, .221461, .250301], 7: [.071303, .131514, .189879, .214607], 9: [.028532, .067234, .124009, .179044, .20236], 11: [.0093, .028002, .065984, .121703, .175713, .198596], 13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641], 15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448] }, Ia = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join("\n"); !function (t) { t[t.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t[t.WEBGL = 1] = "WEBGL", t[t.WEBGL2 = 2] = "WEBGL2" }(ua || (ua = {})), function (t) { t[t.UNKNOWN = 0] = "UNKNOWN", t[t.WEBGL = 1] = "WEBGL", t[t.CANVAS = 2] = "CANVAS" }(la || (la = {})), function (t) { t[t.COLOR = 16384] = "COLOR", t[t.DEPTH = 256] = "DEPTH", t[t.STENCIL = 1024] = "STENCIL" }(ca || (ca = {})), function (t) { t[t.NORMAL = 0] = "NORMAL", t[t.ADD = 1] = "ADD", t[t.MULTIPLY = 2] = "MULTIPLY", t[t.SCREEN = 3] = "SCREEN", t[t.OVERLAY = 4] = "OVERLAY", t[t.DARKEN = 5] = "DARKEN", t[t.LIGHTEN = 6] = "LIGHTEN", t[t.COLOR_DODGE = 7] = "COLOR_DODGE", t[t.COLOR_BURN = 8] = "COLOR_BURN", t[t.HARD_LIGHT = 9] = "HARD_LIGHT", t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT", t[t.DIFFERENCE = 11] = "DIFFERENCE", t[t.EXCLUSION = 12] = "EXCLUSION", t[t.HUE = 13] = "HUE", t[t.SATURATION = 14] = "SATURATION", t[t.COLOR = 15] = "COLOR", t[t.LUMINOSITY = 16] = "LUMINOSITY", t[t.NORMAL_NPM = 17] = "NORMAL_NPM", t[t.ADD_NPM = 18] = "ADD_NPM", t[t.SCREEN_NPM = 19] = "SCREEN_NPM", t[t.NONE = 20] = "NONE", t[t.SRC_OVER = 0] = "SRC_OVER", t[t.SRC_IN = 21] = "SRC_IN", t[t.SRC_OUT = 22] = "SRC_OUT", t[t.SRC_ATOP = 23] = "SRC_ATOP", t[t.DST_OVER = 24] = "DST_OVER", t[t.DST_IN = 25] = "DST_IN", t[t.DST_OUT = 26] = "DST_OUT", t[t.DST_ATOP = 27] = "DST_ATOP", t[t.ERASE = 26] = "ERASE", t[t.SUBTRACT = 28] = "SUBTRACT", t[t.XOR = 29] = "XOR" }(da || (da = {})), function (t) { t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN" }(pa || (pa = {})), function (t) { t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL" }(fa || (fa = {})), function (t) { t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z" }(ma || (ma = {})), function (t) { t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.FLOAT = 5126] = "FLOAT", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT" }(va || (va = {})), function (t) { t[t.NEAREST = 0] = "NEAREST", t[t.LINEAR = 1] = "LINEAR" }(ga || (ga = {})), function (t) { t[t.CLAMP = 33071] = "CLAMP", t[t.REPEAT = 10497] = "REPEAT", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT" }(ya || (ya = {})), function (t) { t[t.OFF = 0] = "OFF", t[t.POW2 = 1] = "POW2", t[t.ON = 2] = "ON" }(_a || (_a = {})), function (t) { t[t.NPM = 0] = "NPM", t[t.UNPACK = 1] = "UNPACK", t[t.PMA = 2] = "PMA", t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t[t.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA" }(xa || (xa = {})), function (t) { t[t.NO = 0] = "NO", t[t.YES = 1] = "YES", t[t.AUTO = 2] = "AUTO", t[t.BLEND = 0] = "BLEND", t[t.CLEAR = 1] = "CLEAR", t[t.BLIT = 2] = "BLIT" }(ba || (ba = {})), function (t) { t[t.AUTO = 0] = "AUTO", t[t.MANUAL = 1] = "MANUAL" }(Ea || (Ea = {})), function (t) { t.LOW = "lowp", t.MEDIUM = "mediump", t.HIGH = "highp" }(Ta || (Ta = {})), function (t) { t[t.NONE = 0] = "NONE", t[t.SCISSOR = 1] = "SCISSOR", t[t.STENCIL = 2] = "STENCIL", t[t.SPRITE = 3] = "SPRITE" }(Sa || (Sa = {})), function (t) { t[t.NONE = 0] = "NONE", t[t.LOW = 2] = "LOW", t[t.MEDIUM = 4] = "MEDIUM", t[t.HIGH = 8] = "HIGH" }(wa || (wa = {})); var Aa = function (t) { function e(e, r, i, n, o) { void 0 === r && (r = 8), void 0 === i && (i = 4), void 0 === n && (n = D.FILTER_RESOLUTION), void 0 === o && (o = 5); var s = this, a = function (t, e) { var r, i = Math.ceil(t / 2), n = ha, o = ""; r = e ? "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);"; for (var s = 0; s < t; s++) { var a = r.replace("%index%", s.toString()); o += a = a.replace("%sampleIndex%", s - (i - 1) + ".0"), o += "\n" } return n = (n = n.replace("%blur%", o)).replace("%size%", t.toString()) }(o, e), h = function (t) { for (var e, r = Pa[t], i = r.length, n = Ia, o = "", s = 0; s < t; s++) { var a = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;".replace("%index%", s.toString()); e = s, s >= i && (e = t - s - 1), o += a = a.replace("%value%", r[e].toString()), o += "\n" } return n = (n = n.replace("%blur%", o)).replace("%size%", t.toString()) }(o); return (s = t.call(this, a, h) || this).horizontal = e, s.resolution = n, s._quality = 0, s.quality = i, s.blur = r, s } return aa(e, t), e.prototype.apply = function (t, e, r, i) { if (r ? this.horizontal ? this.uniforms.strength = 1 / r.width * (r.width / e.width) : this.uniforms.strength = 1 / r.height * (r.height / e.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / e.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / e.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, 1 === this.passes) t.applyFilter(this, e, r, i); else { var n = t.getFilterTexture(), o = t.renderer, s = e, a = n; this.state.blend = !1, t.applyFilter(this, s, a, ba.CLEAR); for (var h = 1; h < this.passes - 1; h++) { t.bindAndClear(s, ba.BLIT), this.uniforms.uSampler = a; var u = a; a = s, s = u, o.shader.bind(this), o.geometry.draw(5) } this.state.blend = !0, t.applyFilter(this, a, r, i), t.returnFilterTexture(n) } }, Object.defineProperty(e.prototype, "blur", { get: function () { return this.strength }, set: function (t) { this.padding = 1 + 2 * Math.abs(t), this.strength = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "quality", { get: function () { return this._quality }, set: function (t) { this._quality = t, this.passes = t }, enumerable: !1, configurable: !0 }), e }(Fi), Oa = function (t) { function e(e, r, i, n) { void 0 === e && (e = 8), void 0 === r && (r = 4), void 0 === i && (i = D.FILTER_RESOLUTION), void 0 === n && (n = 5); var o = t.call(this) || this; return o.blurXFilter = new Aa(!0, e, r, i, n), o.blurYFilter = new Aa(!1, e, r, i, n), o.resolution = i, o.quality = r, o.blur = e, o.repeatEdgePixels = !1, o } return aa(e, t), e.prototype.apply = function (t, e, r, i) { var n = Math.abs(this.blurXFilter.strength), o = Math.abs(this.blurYFilter.strength); if (n && o) { var s = t.getFilterTexture(); this.blurXFilter.apply(t, e, s, ba.CLEAR), this.blurYFilter.apply(t, s, r, i), t.returnFilterTexture(s) } else o ? this.blurYFilter.apply(t, e, r, i) : this.blurXFilter.apply(t, e, r, i) }, e.prototype.updatePadding = function () { this._repeatEdgePixels ? this.padding = 0 : this.padding = 2 * Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) }, Object.defineProperty(e.prototype, "blur", { get: function () { return this.blurXFilter.blur }, set: function (t) { this.blurXFilter.blur = this.blurYFilter.blur = t, this.updatePadding() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "quality", { get: function () { return this.blurXFilter.quality }, set: function (t) { this.blurXFilter.quality = this.blurYFilter.quality = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "blurX", { get: function () { return this.blurXFilter.blur }, set: function (t) { this.blurXFilter.blur = t, this.updatePadding() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "blurY", { get: function () { return this.blurYFilter.blur }, set: function (t) { this.blurYFilter.blur = t, this.updatePadding() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "blendMode", { get: function () { return this.blurYFilter.blendMode }, set: function (t) { this.blurYFilter.blendMode = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "repeatEdgePixels", { get: function () { return this._repeatEdgePixels }, set: function (t) { this._repeatEdgePixels = t, this.updatePadding() }, enumerable: !1, configurable: !0 }), e }(Fi), Ma = function (t, e) { return (Ma = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; var Da = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n", Ca = function (t) { function e() { var e = this, r = { m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]), uAlpha: 1 }; return (e = t.call(this, yn, Da, r) || this).alpha = 1, e } return function (t, e) { function r() { this.constructor = t } Ma(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) }(e, t), e.prototype._loadMatrix = function (t, e) { void 0 === e && (e = !1); var r = t; e && (this._multiply(r, this.uniforms.m, t), r = this._colorMatrix(r)), this.uniforms.m = r }, e.prototype._multiply = function (t, e, r) { return t[0] = e[0] * r[0] + e[1] * r[5] + e[2] * r[10] + e[3] * r[15], t[1] = e[0] * r[1] + e[1] * r[6] + e[2] * r[11] + e[3] * r[16], t[2] = e[0] * r[2] + e[1] * r[7] + e[2] * r[12] + e[3] * r[17], t[3] = e[0] * r[3] + e[1] * r[8] + e[2] * r[13] + e[3] * r[18], t[4] = e[0] * r[4] + e[1] * r[9] + e[2] * r[14] + e[3] * r[19] + e[4], t[5] = e[5] * r[0] + e[6] * r[5] + e[7] * r[10] + e[8] * r[15], t[6] = e[5] * r[1] + e[6] * r[6] + e[7] * r[11] + e[8] * r[16], t[7] = e[5] * r[2] + e[6] * r[7] + e[7] * r[12] + e[8] * r[17], t[8] = e[5] * r[3] + e[6] * r[8] + e[7] * r[13] + e[8] * r[18], t[9] = e[5] * r[4] + e[6] * r[9] + e[7] * r[14] + e[8] * r[19] + e[9], t[10] = e[10] * r[0] + e[11] * r[5] + e[12] * r[10] + e[13] * r[15], t[11] = e[10] * r[1] + e[11] * r[6] + e[12] * r[11] + e[13] * r[16], t[12] = e[10] * r[2] + e[11] * r[7] + e[12] * r[12] + e[13] * r[17], t[13] = e[10] * r[3] + e[11] * r[8] + e[12] * r[13] + e[13] * r[18], t[14] = e[10] * r[4] + e[11] * r[9] + e[12] * r[14] + e[13] * r[19] + e[14], t[15] = e[15] * r[0] + e[16] * r[5] + e[17] * r[10] + e[18] * r[15], t[16] = e[15] * r[1] + e[16] * r[6] + e[17] * r[11] + e[18] * r[16], t[17] = e[15] * r[2] + e[16] * r[7] + e[17] * r[12] + e[18] * r[17], t[18] = e[15] * r[3] + e[16] * r[8] + e[17] * r[13] + e[18] * r[18], t[19] = e[15] * r[4] + e[16] * r[9] + e[17] * r[14] + e[18] * r[19] + e[19], t }, e.prototype._colorMatrix = function (t) { var e = new Float32Array(t); return e[4] /= 255, e[9] /= 255, e[14] /= 255, e[19] /= 255, e }, e.prototype.brightness = function (t, e) { var r = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(r, e) }, e.prototype.greyscale = function (t, e) { var r = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(r, e) }, e.prototype.blackAndWhite = function (t) { this._loadMatrix([.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0], t) }, e.prototype.hue = function (t, e) { t = (t || 0) / 180 * Math.PI; var r = Math.cos(t), i = Math.sin(t), n = 1 / 3, o = (0, Math.sqrt)(n), s = [r + (1 - r) * n, n * (1 - r) - o * i, n * (1 - r) + o * i, 0, 0, n * (1 - r) + o * i, r + n * (1 - r), n * (1 - r) - o * i, 0, 0, n * (1 - r) - o * i, n * (1 - r) + o * i, r + n * (1 - r), 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(s, e) }, e.prototype.contrast = function (t, e) { var r = (t || 0) + 1, i = -.5 * (r - 1), n = [r, 0, 0, 0, i, 0, r, 0, 0, i, 0, 0, r, 0, i, 0, 0, 0, 1, 0]; this._loadMatrix(n, e) }, e.prototype.saturate = function (t, e) { void 0 === t && (t = 0); var r = 2 * t / 3 + 1, i = -.5 * (r - 1), n = [r, i, i, 0, 0, i, r, i, 0, 0, i, i, r, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(n, e) }, e.prototype.desaturate = function () { this.saturate(-1) }, e.prototype.negative = function (t) { this._loadMatrix([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], t) }, e.prototype.sepia = function (t) { this._loadMatrix([.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0], t) }, e.prototype.technicolor = function (t) { this._loadMatrix([1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], t) }, e.prototype.polaroid = function (t) { this._loadMatrix([1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0], t) }, e.prototype.toBGR = function (t) { this._loadMatrix([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], t) }, e.prototype.kodachrome = function (t) { this._loadMatrix([1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], t) }, e.prototype.browni = function (t) { this._loadMatrix([.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], t) }, e.prototype.vintage = function (t) { this._loadMatrix([.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], t) }, e.prototype.colorTone = function (t, e, r, i, n) { var o = ((r = r || 16770432) >> 16 & 255) / 255, s = (r >> 8 & 255) / 255, a = (255 & r) / 255, h = ((i = i || 3375104) >> 16 & 255) / 255, u = (i >> 8 & 255) / 255, l = (255 & i) / 255, c = [.3, .59, .11, 0, 0, o, s, a, t = t || .2, 0, h, u, l, e = e || .15, 0, o - h, s - u, a - l, 0, 0]; this._loadMatrix(c, n) }, e.prototype.night = function (t, e) { var r = [-2 * (t = t || .1), -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, 2 * t, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(r, e) }, e.prototype.predator = function (t, e) { var r = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0]; this._loadMatrix(r, e) }, e.prototype.lsd = function (t) { this._loadMatrix([2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0], t) }, e.prototype.reset = function () { this._loadMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], !1) }, Object.defineProperty(e.prototype, "matrix", { get: function () { return this.uniforms.m }, set: function (t) { this.uniforms.m = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "alpha", { get: function () { return this.uniforms.uAlpha }, set: function (t) { this.uniforms.uAlpha = t }, enumerable: !1, configurable: !0 }), e }(Fi); Ca.prototype.grayscale = Ca.prototype.greyscale; var Ra = function (t, e) { return (Ra = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; var La = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n", Na = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n", Fa = function (t) { function e(e, r) { var i = this, n = new Ie; return e.renderable = !1, (i = t.call(this, Na, La, { mapSampler: e._texture, filterMatrix: n, scale: { x: 1, y: 1 }, rotation: new Float32Array([1, 0, 0, 1]) }) || this).maskSprite = e, i.maskMatrix = n, null == r && (r = 20), i.scale = new we(r, r), i } return function (t, e) { function r() { this.constructor = t } Ra(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) }(e, t), e.prototype.apply = function (t, e, r, i) { this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y; var n = this.maskSprite.worldTransform, o = Math.sqrt(n.a * n.a + n.b * n.b), s = Math.sqrt(n.c * n.c + n.d * n.d); 0 !== o && 0 !== s && (this.uniforms.rotation[0] = n.a / o, this.uniforms.rotation[1] = n.b / o, this.uniforms.rotation[2] = n.c / s, this.uniforms.rotation[3] = n.d / s), t.applyFilter(this, e, r, i) }, Object.defineProperty(e.prototype, "map", { get: function () { return this.uniforms.mapSampler }, set: function (t) { this.uniforms.mapSampler = t }, enumerable: !1, configurable: !0 }), e }(Fi), Ba = function (t, e) { return (Ba = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; var Ua = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputPixel;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n", ka = 'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputPixel;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n', Xa = function (t) { function e() { return t.call(this, Ua, ka) || this } return function (t, e) { function r() { this.constructor = t } Ba(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) }(e, t), e }(Fi), ja = function (t, e) { return (ja = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; var Ha = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n", Ga = function (t) { function e(e, r) { void 0 === e && (e = .5), void 0 === r && (r = Math.random()); var i = t.call(this, yn, Ha, { uNoise: 0, uSeed: 0 }) || this; return i.noise = e, i.seed = r, i } return function (t, e) { function r() { this.constructor = t } ja(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) }(e, t), Object.defineProperty(e.prototype, "noise", { get: function () { return this.uniforms.uNoise }, set: function (t) { this.uniforms.uNoise = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "seed", { get: function () { return this.uniforms.uSeed }, set: function (t) { this.uniforms.uSeed = t }, enumerable: !1, configurable: !0 }), e }(Fi), Ya = new Ie; Xe.prototype._cacheAsBitmap = !1, Xe.prototype._cacheData = null; var za = function () { return function () { this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null } }(); Object.defineProperties(Xe.prototype, { cacheAsBitmap: { get: function () { return this._cacheAsBitmap }, set: function (t) { var e; this._cacheAsBitmap !== t && (this._cacheAsBitmap = t, t ? (this._cacheData || (this._cacheData = new za), (e = this._cacheData).originalRender = this.render, e.originalRenderCanvas = this.renderCanvas, e.originalUpdateTransform = this.updateTransform, e.originalCalculateBounds = this.calculateBounds, e.originalGetLocalBounds = this.getLocalBounds, e.originalDestroy = this.destroy, e.originalContainsPoint = this.containsPoint, e.originalMask = this._mask, e.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : ((e = this._cacheData).sprite && this._destroyCachedDisplayObject(), this.render = e.originalRender, this.renderCanvas = e.originalRenderCanvas, this.calculateBounds = e.originalCalculateBounds, this.getLocalBounds = e.originalGetLocalBounds, this.destroy = e.originalDestroy, this.updateTransform = e.originalUpdateTransform, this.containsPoint = e.originalContainsPoint, this._mask = e.originalMask, this.filterArea = e.originalFilterArea)) } } }), Xe.prototype._renderCached = function (t) { !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t)) }, Xe.prototype._initCachedDisplayObject = function (t) { if (!this._cacheData || !this._cacheData.sprite) { var e = this.alpha; this.alpha = 1, t.batch.flush(); var r = this.getLocalBounds(null, !0).clone(); if (this.filters) { var i = this.filters[0].padding; r.pad(i) } r.ceil(D.RESOLUTION); var n = t.renderTexture.current, o = t.renderTexture.sourceFrame.clone(), s = t.projection.transform, a = Fr.create({ width: r.width, height: r.height }), h = "cacheAsBitmap_" + ie(); this._cacheData.textureCacheId = h, gr.addToCache(a.baseTexture, h), Lr.addToCache(a, h); var u = this.transform.localTransform.copyTo(Ya).invert().translate(-r.x, -r.y); this.render = this._cacheData.originalRender, t.render(this, a, !0, u, !1), t.projection.transform = s, t.renderTexture.bind(n, o), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null; var l = new Ko(a); l.transform.worldTransform = this.transform.worldTransform, l.anchor.x = -r.x / r.width, l.anchor.y = -r.y / r.height, l.alpha = e, l._bounds = this._bounds, this._cacheData.sprite = l, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = l.containsPoint.bind(l) } }, Xe.prototype._renderCachedCanvas = function (t) { !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t)) }, Xe.prototype._initCachedDisplayObjectCanvas = function (t) { if (!this._cacheData || !this._cacheData.sprite) { var e = this.getLocalBounds(null, !0), r = this.alpha; this.alpha = 1; var i = t.context, n = t._projTransform; e.ceil(D.RESOLUTION); var o = Fr.create({ width: e.width, height: e.height }), s = "cacheAsBitmap_" + ie(); this._cacheData.textureCacheId = s, gr.addToCache(o.baseTexture, s), Lr.addToCache(o, s); var a = Ya; this.transform.localTransform.copyTo(a), a.invert(), a.tx -= e.x, a.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, o, !0, a, !1), t.context = i, t._projTransform = n, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null; var h = new Ko(o); h.transform.worldTransform = this.transform.worldTransform, h.anchor.x = -e.x / e.width, h.anchor.y = -e.y / e.height, h.alpha = r, h._bounds = this._bounds, this._cacheData.sprite = h, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = h.containsPoint.bind(h) } }, Xe.prototype._calculateCachedBounds = function () { this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID }, Xe.prototype._getCachedLocalBounds = function () { return this._cacheData.sprite.getLocalBounds(null) }, Xe.prototype._destroyCachedDisplayObject = function () { this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, gr.removeFromCache(this._cacheData.textureCacheId), Lr.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null }, Xe.prototype._cacheAsBitmapDestroy = function (t) { this.cacheAsBitmap = !1, this.destroy(t) }, Xe.prototype.name = null, Ge.prototype.getChildByName = function (t, e) { for (var r = 0, i = this.children.length; r < i; r++)if (this.children[r].name === t) return this.children[r]; if (e) for (r = 0, i = this.children.length; r < i; r++) { if (this.children[r].getChildByName) { var n = this.children[r].getChildByName(t, !0); if (n) return n } } return null }, Xe.prototype.getGlobalPosition = function (t, e) { return void 0 === t && (t = new we), void 0 === e && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t }; var Va = function (t, e) { return (Va = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; function Wa(t, e) { function r() { this.constructor = t } Va(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var qa = function (t) { function e(e, r, i, n) { void 0 === e && (e = 100), void 0 === r && (r = 100), void 0 === i && (i = 10), void 0 === n && (n = 10); var o = t.call(this) || this; return o.segWidth = i, o.segHeight = n, o.width = e, o.height = r, o.build(), o } return Wa(e, t), e.prototype.build = function () { for (var t = this.segWidth * this.segHeight, e = [], r = [], i = [], n = this.segWidth - 1, o = this.segHeight - 1, s = this.width / n, a = this.height / o, h = 0; h < t; h++) { var u = h % this.segWidth, l = h / this.segWidth | 0; e.push(u * s, l * a), r.push(u / n, l / o) } var c = n * o; for (h = 0; h < c; h++) { var d = h % n, p = h / n | 0, f = p * this.segWidth + d, m = p * this.segWidth + d + 1, v = (p + 1) * this.segWidth + d, g = (p + 1) * this.segWidth + d + 1; i.push(f, m, v, m, g, v) } this.buffers[0].data = new Float32Array(e), this.buffers[1].data = new Float32Array(r), this.indexBuffer.data = new Uint16Array(i), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update() }, e }(Hs), Ka = function (t) { function e(e, r, i) { void 0 === e && (e = 200), void 0 === i && (i = 0); var n = t.call(this, new Float32Array(4 * r.length), new Float32Array(4 * r.length), new Uint16Array(6 * (r.length - 1))) || this; return n.points = r, n._width = e, n.textureScale = i, n.build(), n } return Wa(e, t), Object.defineProperty(e.prototype, "width", { get: function () { return this._width }, enumerable: !1, configurable: !0 }), e.prototype.build = function () { var t = this.points; if (t) { var e = this.getBuffer("aVertexPosition"), r = this.getBuffer("aTextureCoord"), i = this.getIndex(); if (!(t.length < 1)) { e.data.length / 4 !== t.length && (e.data = new Float32Array(4 * t.length), r.data = new Float32Array(4 * t.length), i.data = new Uint16Array(6 * (t.length - 1))); var n = r.data, o = i.data; n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1; for (var s = 0, a = t[0], h = this._width * this.textureScale, u = t.length, l = 0; l < u; l++) { var c = 4 * l; if (this.textureScale > 0) { var d = a.x - t[l].x, p = a.y - t[l].y, f = Math.sqrt(d * d + p * p); a = t[l], s += f / h } else s = l / (u - 1); n[c] = s, n[c + 1] = 0, n[c + 2] = s, n[c + 3] = 1 } var m = 0; for (l = 0; l < u - 1; l++) { c = 2 * l; o[m++] = c, o[m++] = c + 1, o[m++] = c + 2, o[m++] = c + 2, o[m++] = c + 1, o[m++] = c + 3 } r.update(), i.update(), this.updateVertices() } } }, e.prototype.updateVertices = function () { var t = this.points; if (!(t.length < 1)) { for (var e, r = t[0], i = 0, n = 0, o = this.buffers[0].data, s = t.length, a = 0; a < s; a++) { var h = t[a], u = 4 * a; n = -((e = a < t.length - 1 ? t[a + 1] : h).x - r.x), i = e.y - r.y; var l = Math.sqrt(i * i + n * n), c = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2; i /= l, n /= l, i *= c, n *= c, o[u] = h.x + i, o[u + 1] = h.y + n, o[u + 2] = h.x - i, o[u + 3] = h.y - n, r = h } this.buffers[0].update() } }, e.prototype.update = function () { this.textureScale > 0 ? this.build() : this.updateVertices() }, e }(Hs), Za = function (e) { function r(r, i, n) { void 0 === n && (n = 0); var o = this, s = new Ka(r.height, i, n), a = new js(r); return n > 0 && (r.baseTexture.wrapMode = t.WRAP_MODES.REPEAT), (o = e.call(this, s, a) || this).autoUpdate = !0, o } return Wa(r, e), r.prototype._render = function (t) { var r = this.geometry; (this.autoUpdate || r._width !== this.shader.texture.height) && (r._width = this.shader.texture.height, r.update()), e.prototype._render.call(this, t) }, r }(Us), Ja = function (t) { function e(e, r, i) { var n = this, o = new qa(e.width, e.height, r, i), s = new js(Lr.WHITE); return (n = t.call(this, o, s) || this).texture = e, n } return Wa(e, t), e.prototype.textureUpdated = function () { this._textureID = this.shader.texture._updateID; var t = this.geometry; t.width = this.shader.texture.width, t.height = this.shader.texture.height, t.build() }, Object.defineProperty(e.prototype, "texture", { get: function () { return this.shader.texture }, set: function (t) { this.shader.texture !== t && (this.shader.texture = t, this._textureID = -1, t.baseTexture.valid ? this.textureUpdated() : t.once("update", this.textureUpdated, this)) }, enumerable: !1, configurable: !0 }), e.prototype._render = function (e) { this._textureID !== this.shader.texture._updateID && this.textureUpdated(), t.prototype._render.call(this, e) }, e.prototype.destroy = function (e) { this.shader.texture.off("update", this.textureUpdated, this), t.prototype.destroy.call(this, e) }, e }(Us), Qa = function (t) { function e(e, r, i, n, o) { void 0 === e && (e = Lr.EMPTY); var s = this, a = new Hs(r, i, n); a.getBuffer("aVertexPosition").static = !1; var h = new js(e); return (s = t.call(this, a, h, null, o) || this).autoUpdate = !0, s } return Wa(e, t), Object.defineProperty(e.prototype, "vertices", { get: function () { return this.geometry.getBuffer("aVertexPosition").data }, set: function (t) { this.geometry.getBuffer("aVertexPosition").data = t }, enumerable: !1, configurable: !0 }), e.prototype._render = function (e) { this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), t.prototype._render.call(this, e) }, e }(Us), $a = 10, th = function (t) { function e(e, r, i, n, o) { void 0 === r && (r = $a), void 0 === i && (i = $a), void 0 === n && (n = $a), void 0 === o && (o = $a); var s = t.call(this, Lr.WHITE, 4, 4) || this; return s._origWidth = e.orig.width, s._origHeight = e.orig.height, s._width = s._origWidth, s._height = s._origHeight, s._leftWidth = r, s._rightWidth = n, s._topHeight = i, s._bottomHeight = o, s.texture = e, s } return Wa(e, t), e.prototype.textureUpdated = function () { this._textureID = this.shader.texture._updateID, this._refresh() }, Object.defineProperty(e.prototype, "vertices", { get: function () { return this.geometry.getBuffer("aVertexPosition").data }, set: function (t) { this.geometry.getBuffer("aVertexPosition").data = t }, enumerable: !1, configurable: !0 }), e.prototype.updateHorizontalVertices = function () { var t = this.vertices, e = this._getMinScale(); t[9] = t[11] = t[13] = t[15] = this._topHeight * e, t[17] = t[19] = t[21] = t[23] = this._height - this._bottomHeight * e, t[25] = t[27] = t[29] = t[31] = this._height }, e.prototype.updateVerticalVertices = function () { var t = this.vertices, e = this._getMinScale(); t[2] = t[10] = t[18] = t[26] = this._leftWidth * e, t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * e, t[6] = t[14] = t[22] = t[30] = this._width }, e.prototype._getMinScale = function () { var t = this._leftWidth + this._rightWidth, e = this._width > t ? 1 : this._width / t, r = this._topHeight + this._bottomHeight, i = this._height > r ? 1 : this._height / r; return Math.min(e, i) }, Object.defineProperty(e.prototype, "width", { get: function () { return this._width }, set: function (t) { this._width = t, this._refresh() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "height", { get: function () { return this._height }, set: function (t) { this._height = t, this._refresh() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "leftWidth", { get: function () { return this._leftWidth }, set: function (t) { this._leftWidth = t, this._refresh() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "rightWidth", { get: function () { return this._rightWidth }, set: function (t) { this._rightWidth = t, this._refresh() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "topHeight", { get: function () { return this._topHeight }, set: function (t) { this._topHeight = t, this._refresh() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "bottomHeight", { get: function () { return this._bottomHeight }, set: function (t) { this._bottomHeight = t, this._refresh() }, enumerable: !1, configurable: !0 }), e.prototype._refresh = function () { var t = this.texture, e = this.geometry.buffers[1].data; this._origWidth = t.orig.width, this._origHeight = t.orig.height; var r = 1 / this._origWidth, i = 1 / this._origHeight; e[0] = e[8] = e[16] = e[24] = 0, e[1] = e[3] = e[5] = e[7] = 0, e[6] = e[14] = e[22] = e[30] = 1, e[25] = e[27] = e[29] = e[31] = 1, e[2] = e[10] = e[18] = e[26] = r * this._leftWidth, e[4] = e[12] = e[20] = e[28] = 1 - r * this._rightWidth, e[9] = e[11] = e[13] = e[15] = i * this._topHeight, e[17] = e[19] = e[21] = e[23] = 1 - i * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update() }, e }(Ja), eh = function (t, e) { return (eh = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; var rh = function (e) { function r(t, r) { void 0 === r && (r = !0); var i = e.call(this, t[0] instanceof Lr ? t[0] : t[0].texture) || this; return i._textures = null, i._durations = null, i._autoUpdate = r, i._isConnectedToTicker = !1, i.animationSpeed = 1, i.loop = !0, i.updateAnchor = !1, i.onComplete = null, i.onFrameChange = null, i.onLoop = null, i._currentTime = 0, i._playing = !1, i._previousFrame = null, i.textures = t, i } return function (t, e) { function r() { this.constructor = t } eh(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) }(r, e), r.prototype.stop = function () { this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Qe.shared.remove(this.update, this), this._isConnectedToTicker = !1)) }, r.prototype.play = function () { this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Qe.shared.add(this.update, this, t.UPDATE_PRIORITY.HIGH), this._isConnectedToTicker = !0)) }, r.prototype.gotoAndStop = function (t) { this.stop(); var e = this.currentFrame; this._currentTime = t, e !== this.currentFrame && this.updateTexture() }, r.prototype.gotoAndPlay = function (t) { var e = this.currentFrame; this._currentTime = t, e !== this.currentFrame && this.updateTexture(), this.play() }, r.prototype.update = function (t) { if (this._playing) { var e = this.animationSpeed * t, r = this.currentFrame; if (null !== this._durations) { var i = this._currentTime % 1 * this._durations[this.currentFrame]; for (i += e / 60 * 1e3; i < 0;)this._currentTime--, i += this._durations[this.currentFrame]; var n = Math.sign(this.animationSpeed * t); for (this._currentTime = Math.floor(this._currentTime); i >= this._durations[this.currentFrame];)i -= this._durations[this.currentFrame] * n, this._currentTime += n; this._currentTime += i / this._durations[this.currentFrame] } else this._currentTime += e; this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : r !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < r ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > r && this.onLoop()), this.updateTexture()) } }, r.prototype.updateTexture = function () { var t = this.currentFrame; this._previousFrame !== t && (this._previousFrame = t, this._texture = this._textures[t], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame)) }, r.prototype.destroy = function (t) { this.stop(), e.prototype.destroy.call(this, t), this.onComplete = null, this.onFrameChange = null, this.onLoop = null }, r.fromFrames = function (t) { for (var e = [], i = 0; i < t.length; ++i)e.push(Lr.from(t[i])); return new r(e) }, r.fromImages = function (t) { for (var e = [], i = 0; i < t.length; ++i)e.push(Lr.from(t[i])); return new r(e) }, Object.defineProperty(r.prototype, "totalFrames", { get: function () { return this._textures.length }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "textures", { get: function () { return this._textures }, set: function (t) { if (t[0] instanceof Lr) this._textures = t, this._durations = null; else { this._textures = [], this._durations = []; for (var e = 0; e < t.length; e++)this._textures.push(t[e].texture), this._durations.push(t[e].time) } this._previousFrame = null, this.gotoAndStop(0), this.updateTexture() }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "currentFrame", { get: function () { var t = Math.floor(this._currentTime) % this._textures.length; return t < 0 && (t += this._textures.length), t }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "playing", { get: function () { return this._playing }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "autoUpdate", { get: function () { return this._autoUpdate }, set: function (t) { t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (Qe.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Qe.shared.add(this.update, this), this._isConnectedToTicker = !0)) }, enumerable: !1, configurable: !0 }), r }(Ko), ih = function (t, e) { return (ih = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; function nh(t, e) { function r() { this.constructor = t } ih(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var oh = "5.0.0"; mn.registerPlugin("accessibility", Ze), mn.registerPlugin("extract", Cn), mn.registerPlugin("interaction", hr), mn.registerPlugin("particle", po), mn.registerPlugin("prepare", xs), mn.registerPlugin("batch", An), mn.registerPlugin("tilingSprite", Cs), ro.registerPlugin(ra), ro.registerPlugin(Ts), On.registerPlugin($e), On.registerPlugin(io); var sh = { AlphaFilter: oa, BlurFilter: Oa, BlurFilterPass: Aa, ColorMatrixFilter: Ca, DisplacementFilter: Fa, FXAAFilter: Xa, NoiseFilter: Ga }, ah = function (t, e) { return (ah = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; var hh = function () { function e(t) { this.renderer = t, this._foundShapes = [] } return e.prototype.pushMask = function (t) { var e = this.renderer, r = t.maskObject || t; e.context.save(); var i = this._foundShapes; if (this.recursiveFindShapes(r, i), i.length > 0) { var n = e.context; n.beginPath(); for (var o = 0; o < i.length; o++) { var s = i[o], a = s.transform.worldTransform; this.renderer.setContextTransform(a), this.renderGraphicsShape(s) } i.length = 0, n.clip() } }, e.prototype.recursiveFindShapes = function (t, e) { t.geometry && t.geometry.graphicsData && e.push(t); var r = t.children; if (r) for (var i = 0; i < r.length; i++)this.recursiveFindShapes(r[i], e) }, e.prototype.renderGraphicsShape = function (e) { e.finishPoly(); var r = this.renderer.context, i = e.geometry.graphicsData, n = i.length; if (0 !== n) for (var o = 0; o < n; o++) { var s = i[o].shape; if (s.type === t.SHAPES.POLY) { var a = s.points; r.moveTo(a[0], a[1]); for (var h = 1; h < a.length / 2; h++)r.lineTo(a[2 * h], a[2 * h + 1]); a[0] === a[a.length - 2] && a[1] === a[a.length - 1] && r.closePath() } else if (s.type === t.SHAPES.RECT) r.rect(s.x, s.y, s.width, s.height), r.closePath(); else if (s.type === t.SHAPES.CIRC) r.arc(s.x, s.y, s.radius, 0, 2 * Math.PI), r.closePath(); else if (s.type === t.SHAPES.ELIP) { var u = 2 * s.width, l = 2 * s.height, c = s.x - u / 2, d = s.y - l / 2, p = u / 2 * .5522848, f = l / 2 * .5522848, m = c + u, v = d + l, g = c + u / 2, y = d + l / 2; r.moveTo(c, y), r.bezierCurveTo(c, y - f, g - p, d, g, d), r.bezierCurveTo(g + p, d, m, y - f, m, y), r.bezierCurveTo(m, y + f, g + p, v, g, v), r.bezierCurveTo(g - p, v, c, y + f, c, y), r.closePath() } else if (s.type === t.SHAPES.RREC) { var _ = s.x, x = s.y, b = s.width, E = s.height, T = s.radius, S = Math.min(b, E) / 2 | 0; T = T > S ? S : T, r.moveTo(_, x + T), r.lineTo(_, x + E - T), r.quadraticCurveTo(_, x + E, _ + T, x + E), r.lineTo(_ + b - T, x + E), r.quadraticCurveTo(_ + b, x + E, _ + b, x + E - T), r.lineTo(_ + b, x + T), r.quadraticCurveTo(_ + b, x, _ + b - T, x), r.lineTo(_ + T, x), r.quadraticCurveTo(_, x, _, x + T), r.closePath() } } }, e.prototype.popMask = function (t) { t.context.restore(), t.invalidateBlendMode() }, e.prototype.destroy = function () { }, e }(); function uh(t) { var e = document.createElement("canvas"); e.width = 6, e.height = 1; var r = e.getContext("2d"); return r.fillStyle = t, r.fillRect(0, 0, 6, 1), e } function lh() { if ("undefined" == typeof document) return !1; var t = uh("#ff00ff"), e = uh("#ffff00"), r = document.createElement("canvas"); r.width = 6, r.height = 1; var i = r.getContext("2d"); i.globalCompositeOperation = "multiply", i.drawImage(t, 0, 0), i.drawImage(e, 2, 0); var n = i.getImageData(2, 0, 1, 1); if (!n) return !1; var o = n.data; return 255 === o[0] && 0 === o[1] && 0 === o[2] } var ch = new Ie, dh = function (e) { function r(i) { var n, o = e.call(this, t.RENDERER_TYPE.CANVAS, i) || this; if (o.rootContext = o.view.getContext("2d", { alpha: o.transparent }), o.context = o.rootContext, o.refresh = !0, o.maskManager = new hh(o), o.smoothProperty = "imageSmoothingEnabled", !o.rootContext.imageSmoothingEnabled) { var s = o.rootContext; s.webkitImageSmoothingEnabled ? o.smoothProperty = "webkitImageSmoothingEnabled" : s.mozImageSmoothingEnabled ? o.smoothProperty = "mozImageSmoothingEnabled" : s.oImageSmoothingEnabled ? o.smoothProperty = "oImageSmoothingEnabled" : s.msImageSmoothingEnabled && (o.smoothProperty = "msImageSmoothingEnabled") } return o.initPlugins(r.__plugins), o.blendModes = (void 0 === n && (n = []), lh() ? (n[t.BLEND_MODES.NORMAL] = "source-over", n[t.BLEND_MODES.ADD] = "lighter", n[t.BLEND_MODES.MULTIPLY] = "multiply", n[t.BLEND_MODES.SCREEN] = "screen", n[t.BLEND_MODES.OVERLAY] = "overlay", n[t.BLEND_MODES.DARKEN] = "darken", n[t.BLEND_MODES.LIGHTEN] = "lighten", n[t.BLEND_MODES.COLOR_DODGE] = "color-dodge", n[t.BLEND_MODES.COLOR_BURN] = "color-burn", n[t.BLEND_MODES.HARD_LIGHT] = "hard-light", n[t.BLEND_MODES.SOFT_LIGHT] = "soft-light", n[t.BLEND_MODES.DIFFERENCE] = "difference", n[t.BLEND_MODES.EXCLUSION] = "exclusion", n[t.BLEND_MODES.HUE] = "hue", n[t.BLEND_MODES.SATURATION] = "saturate", n[t.BLEND_MODES.COLOR] = "color", n[t.BLEND_MODES.LUMINOSITY] = "luminosity") : (n[t.BLEND_MODES.NORMAL] = "source-over", n[t.BLEND_MODES.ADD] = "lighter", n[t.BLEND_MODES.MULTIPLY] = "source-over", n[t.BLEND_MODES.SCREEN] = "source-over", n[t.BLEND_MODES.OVERLAY] = "source-over", n[t.BLEND_MODES.DARKEN] = "source-over", n[t.BLEND_MODES.LIGHTEN] = "source-over", n[t.BLEND_MODES.COLOR_DODGE] = "source-over", n[t.BLEND_MODES.COLOR_BURN] = "source-over", n[t.BLEND_MODES.HARD_LIGHT] = "source-over", n[t.BLEND_MODES.SOFT_LIGHT] = "source-over", n[t.BLEND_MODES.DIFFERENCE] = "source-over", n[t.BLEND_MODES.EXCLUSION] = "source-over", n[t.BLEND_MODES.HUE] = "source-over", n[t.BLEND_MODES.SATURATION] = "source-over", n[t.BLEND_MODES.COLOR] = "source-over", n[t.BLEND_MODES.LUMINOSITY] = "source-over"), n[t.BLEND_MODES.NORMAL_NPM] = n[t.BLEND_MODES.NORMAL], n[t.BLEND_MODES.ADD_NPM] = n[t.BLEND_MODES.ADD], n[t.BLEND_MODES.SCREEN_NPM] = n[t.BLEND_MODES.SCREEN], n[t.BLEND_MODES.SRC_IN] = "source-in", n[t.BLEND_MODES.SRC_OUT] = "source-out", n[t.BLEND_MODES.SRC_ATOP] = "source-atop", n[t.BLEND_MODES.DST_OVER] = "destination-over", n[t.BLEND_MODES.DST_IN] = "destination-in", n[t.BLEND_MODES.DST_OUT] = "destination-out", n[t.BLEND_MODES.DST_ATOP] = "destination-atop", n[t.BLEND_MODES.XOR] = "xor", n[t.BLEND_MODES.SUBTRACT] = "source-over", n), o._activeBlendMode = null, o._outerBlend = !1, o._projTransform = null, o.renderingToScreen = !1, Bt("Canvas"), o.resize(o.options.width, o.options.height), o } return function (t, e) { function r() { this.constructor = t } ah(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) }(r, e), r.prototype.render = function (e, r, i, n, o) { if (this.view) { this.renderingToScreen = !r, this.emit("prerender"); var s = this.resolution; r ? ((r = r.castToBaseTexture())._canvasRenderTarget || (r._canvasRenderTarget = new ue(r.width, r.height, r.resolution), r.resource = new Ir.CanvasResource(r._canvasRenderTarget.canvas), r.valid = !0), this.context = r._canvasRenderTarget.context, this.resolution = r._canvasRenderTarget.resolution) : this.context = this.rootContext; var a = this.context; if (this._projTransform = n || null, r || (this._lastObjectRendered = e), !o) { var h = e.enableTempParent(); e.updateTransform(), e.disableTempParent(h) } if (a.save(), a.setTransform(1, 0, 0, 1, 0, 0), a.globalAlpha = 1, this._activeBlendMode = t.BLEND_MODES.NORMAL, this._outerBlend = !1, a.globalCompositeOperation = this.blendModes[t.BLEND_MODES.NORMAL], void 0 !== i ? i : this.clearBeforeRender) if (this.renderingToScreen) this.transparent ? a.clearRect(0, 0, this.width, this.height) : (a.fillStyle = this._backgroundColorString, a.fillRect(0, 0, this.width, this.height)); else { (r = r)._canvasRenderTarget.clear(); var u = r.clearColor; u[3] > 0 && (a.fillStyle = Xt(Ht(u)), a.fillRect(0, 0, r.realWidth, r.realHeight)) } var l = this.context; this.context = a, e.renderCanvas(this), this.context = l, a.restore(), this.resolution = s, this._projTransform = null, this.emit("postrender") } }, r.prototype.setContextTransform = function (t, e, r) { var i = t, n = this._projTransform, o = this.resolution; r = r || o, n && ((i = ch).copyFrom(t), i.prepend(n)), e ? this.context.setTransform(i.a * r, i.b * r, i.c * r, i.d * r, i.tx * o | 0, i.ty * o | 0) : this.context.setTransform(i.a * r, i.b * r, i.c * r, i.d * r, i.tx * o, i.ty * o) }, r.prototype.clear = function (t) { var e = this.context; t = t || this._backgroundColorString, !this.transparent && t ? (e.fillStyle = t, e.fillRect(0, 0, this.width, this.height)) : e.clearRect(0, 0, this.width, this.height) }, r.prototype.setBlendMode = function (e, r) { var i = e === t.BLEND_MODES.SRC_IN || e === t.BLEND_MODES.SRC_OUT || e === t.BLEND_MODES.DST_IN || e === t.BLEND_MODES.DST_ATOP; !r && i && (e = t.BLEND_MODES.NORMAL), this._activeBlendMode !== e && (this._activeBlendMode = e, this._outerBlend = i, this.context.globalCompositeOperation = this.blendModes[e]) }, r.prototype.destroy = function (t) { e.prototype.destroy.call(this, t), this.context = null, this.refresh = !0, this.maskManager.destroy(), this.maskManager = null, this.smoothProperty = null }, r.prototype.resize = function (r, i) { e.prototype.resize.call(this, r, i), this.smoothProperty && (this.rootContext[this.smoothProperty] = D.SCALE_MODE === t.SCALE_MODES.LINEAR) }, r.prototype.invalidateBlendMode = function () { this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation) }, r.registerPlugin = function (t, e) { r.__plugins = r.__plugins || {}, r.__plugins[t] = e }, r }(fn), ph = { canvas: null, getTintedCanvas: function (t, e) { var r = t.texture, i = "#" + ("00000" + (0 | (e = ph.roundColor(e))).toString(16)).substr(-6); r.tintCache = r.tintCache || {}; var n, o = r.tintCache[i]; if (o) { if (o.tintId === r._updateID) return r.tintCache[i]; n = r.tintCache[i] } else n = document.createElement("canvas"); if (ph.tintMethod(r, e, n), n.tintId = r._updateID, ph.convertTintToImage) { var s = new Image; s.src = n.toDataURL(), r.tintCache[i] = s } else r.tintCache[i] = n; return n }, getTintedPattern: function (t, e) { var r = "#" + ("00000" + (0 | (e = ph.roundColor(e))).toString(16)).substr(-6); t.patternCache = t.patternCache || {}; var i = t.patternCache[r]; return i && i.tintId === t._updateID ? i : (ph.canvas || (ph.canvas = document.createElement("canvas")), ph.tintMethod(t, e, ph.canvas), (i = ph.canvas.getContext("2d").createPattern(ph.canvas, "repeat")).tintId = t._updateID, t.patternCache[r] = i, i) }, tintWithMultiply: function (t, e, r) { var i = r.getContext("2d"), n = t._frame.clone(), o = t.baseTexture.resolution; n.x *= o, n.y *= o, n.width *= o, n.height *= o, r.width = Math.ceil(n.width), r.height = Math.ceil(n.height), i.save(), i.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), i.fillRect(0, 0, n.width, n.height), i.globalCompositeOperation = "multiply"; var s = t.baseTexture.getDrawableSource(); i.drawImage(s, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), i.globalCompositeOperation = "destination-atop", i.drawImage(s, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), i.restore() }, tintWithOverlay: function (t, e, r) { var i = r.getContext("2d"), n = t._frame.clone(), o = t.baseTexture.resolution; n.x *= o, n.y *= o, n.width *= o, n.height *= o, r.width = Math.ceil(n.width), r.height = Math.ceil(n.height), i.save(), i.globalCompositeOperation = "copy", i.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), i.fillRect(0, 0, n.width, n.height), i.globalCompositeOperation = "destination-atop", i.drawImage(t.baseTexture.getDrawableSource(), n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), i.restore() }, tintWithPerPixel: function (t, e, r) { var i = r.getContext("2d"), n = t._frame.clone(), o = t.baseTexture.resolution; n.x *= o, n.y *= o, n.width *= o, n.height *= o, r.width = Math.ceil(n.width), r.height = Math.ceil(n.height), i.save(), i.globalCompositeOperation = "copy", i.drawImage(t.baseTexture.getDrawableSource(), n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), i.restore(); for (var s = kt(e), a = s[0], h = s[1], u = s[2], l = i.getImageData(0, 0, n.width, n.height), c = l.data, d = 0; d < c.length; d += 4)c[d + 0] *= a, c[d + 1] *= h, c[d + 2] *= u; i.putImageData(l, 0, 0) }, roundColor: function (t) { var e = ph.cacheStepsPerColorChannel, r = kt(t); return r[0] = Math.min(255, r[0] / e * e), r[1] = Math.min(255, r[1] / e * e), r[2] = Math.min(255, r[2] / e * e), Ht(r) }, cacheStepsPerColorChannel: 8, convertTintToImage: !1, canUseMultiply: lh(), tintMethod: null }; ph.tintMethod = ph.canUseMultiply ? ph.tintWithMultiply : ph.tintWithPerPixel; var fh = mn.create; mn.create = function (t) { if (!(t && t.forceCanvas)) try { return fh(t) } catch (t) { } return new dh(t) }, gr.prototype.getDrawableSource = function () { var t = this.resource; return t ? t.bitmap || t.source : null }, Dr.prototype._canvasRenderTarget = null, Lr.prototype.patternCache = null, Lr.prototype.tintCache = null; var mh = function () { function e(t) { this.renderer = t } return e.prototype.render = function (e) { var r = this.renderer, i = e.worldTransform; r.context.globalAlpha = e.worldAlpha, r.setBlendMode(e.blendMode), r.setContextTransform(i, e.roundPixels), e.drawMode !== t.DRAW_MODES.TRIANGLES ? this._renderTriangleMesh(e) : this._renderTriangles(e) }, e.prototype._renderTriangleMesh = function (t) { for (var e = t.geometry.buffers[0].data.length, r = 0; r < e - 2; r++) { var i = 2 * r; this._renderDrawTriangle(t, i, i + 2, i + 4) } }, e.prototype._renderTriangles = function (t) { for (var e = t.geometry.getIndex().data, r = e.length, i = 0; i < r; i += 3) { var n = 2 * e[i], o = 2 * e[i + 1], s = 2 * e[i + 2]; this._renderDrawTriangle(t, n, o, s) } }, e.prototype._renderDrawTriangle = function (t, e, r, i) { var n = this.renderer.context, o = t.geometry.buffers[0].data, s = t.uvs, a = t.texture; if (a.valid) { var h = 16777215 !== t.tint, u = a.baseTexture, l = u.width, c = u.height; h && t._cachedTint !== t.tint && (t._cachedTint = t.tint, t._tintedCanvas = ph.getTintedCanvas(t, t.tint)); var d = h ? t._tintedCanvas : u.getDrawableSource(), p = s[e] * u.width, f = s[r] * u.width, m = s[i] * u.width, v = s[e + 1] * u.height, g = s[r + 1] * u.height, y = s[i + 1] * u.height, _ = o[e], x = o[r], b = o[i], E = o[e + 1], T = o[r + 1], S = o[i + 1], w = t.canvasPadding / this.renderer.resolution; if (w > 0) { var P = w / Math.abs(t.worldTransform.a), I = w / Math.abs(t.worldTransform.d), A = (_ + x + b) / 3, O = (E + T + S) / 3, M = _ - A, D = E - O, C = Math.sqrt(M * M + D * D); _ = A + M / C * (C + P), E = O + D / C * (C + I), D = T - O, x = A + (M = x - A) / (C = Math.sqrt(M * M + D * D)) * (C + P), T = O + D / C * (C + I), D = S - O, b = A + (M = b - A) / (C = Math.sqrt(M * M + D * D)) * (C + P), S = O + D / C * (C + I) } n.save(), n.beginPath(), n.moveTo(_, E), n.lineTo(x, T), n.lineTo(b, S), n.closePath(), n.clip(); var R = p * g + v * m + f * y - g * m - v * f - p * y, L = _ * g + v * b + x * y - g * b - v * x - _ * y, N = p * x + _ * m + f * b - x * m - _ * f - p * b, F = p * g * b + v * x * m + _ * f * y - _ * g * m - v * f * b - p * x * y, B = E * g + v * S + T * y - g * S - v * T - E * y, U = p * T + E * m + f * S - T * m - E * f - p * S, k = p * g * S + v * T * m + E * f * y - E * g * m - v * f * S - p * T * y; n.transform(L / R, B / R, N / R, U / R, F / R, k / R), n.drawImage(d, 0, 0, l * u.resolution, c * u.resolution, 0, 0, l, c), n.restore(), this.renderer.invalidateBlendMode() } }, e.prototype.renderMeshFlat = function (t) { var e = this.renderer.context, r = t.geometry.getBuffer("aVertexPosition").data, i = r.length / 2; e.beginPath(); for (var n = 1; n < i - 2; ++n) { var o = 2 * n, s = r[o], a = r[o + 1], h = r[o + 2], u = r[o + 3], l = r[o + 4], c = r[o + 5]; e.moveTo(s, a), e.lineTo(h, u), e.lineTo(l, c) } e.fillStyle = "#FF0000", e.fill(), e.closePath() }, e.prototype.destroy = function () { this.renderer = null }, e }(); D.MESH_CANVAS_PADDING = 0, js.prototype._renderCanvas = function (t, e) { t.plugins.mesh.render(e) }, th.prototype._cachedTint = 16777215, th.prototype._tintedCanvas = null, th.prototype._canvasUvs = null, th.prototype._renderCanvas = function (t) { var e = t.context, r = this.worldTransform, i = 16777215 !== this.tint, n = this.texture; if (n.valid) { i && this._cachedTint !== this.tint && (this._cachedTint = this.tint, this._tintedCanvas = ph.getTintedCanvas(this, this.tint)); var o = i ? this._tintedCanvas : n.baseTexture.getDrawableSource(); this._canvasUvs || (this._canvasUvs = [0, 0, 0, 0, 0, 0, 0, 0]); var s = this.vertices, a = this._canvasUvs, h = i ? 0 : n.frame.x, u = i ? 0 : n.frame.y, l = h + n.frame.width, c = u + n.frame.height; a[0] = h, a[1] = h + this._leftWidth, a[2] = l - this._rightWidth, a[3] = l, a[4] = u, a[5] = u + this._topHeight, a[6] = c - this._bottomHeight, a[7] = c; for (var d = 0; d < 8; d++)a[d] *= n.baseTexture.resolution; e.globalAlpha = this.worldAlpha, t.setBlendMode(this.blendMode), t.setContextTransform(r, this.roundPixels); for (var p = 0; p < 3; p++)for (var f = 0; f < 3; f++) { var m = 2 * f + 8 * p, v = Math.max(1, a[f + 1] - a[f]), g = Math.max(1, a[p + 5] - a[p + 4]), y = Math.max(1, s[m + 10] - s[m]), _ = Math.max(1, s[m + 11] - s[m + 1]); e.drawImage(o, a[f], a[p + 4], v, g, s[m], s[m + 1], y, _) } } }; var vh = !1; Us.prototype._cachedTint = 16777215, Us.prototype._tintedCanvas = null, Us.prototype._renderCanvas = function (t) { this.shader.uvMatrix && (this.shader.uvMatrix.update(), this.calculateUvs()), this.material._renderCanvas ? this.material._renderCanvas(t, this) : vh || (vh = !0, window.console && console.warn("Mesh with custom shaders are not supported in CanvasRenderer.")) }, Us.prototype._canvasPadding = null, Object.defineProperty(Us.prototype, "canvasPadding", { get: function () { return null !== this._canvasPadding ? this._canvasPadding : D.MESH_CANVAS_PADDING }, set: function (t) { this._canvasPadding = t } }), Qa.prototype._renderCanvas = function (t) { this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), this.shader.update && this.shader.update(), this.calculateUvs(), this.material._renderCanvas(t, this) }, Za.prototype._renderCanvas = function (t) { (this.autoUpdate || this.geometry._width !== this.shader.texture.height) && (this.geometry._width = this.shader.texture.height, this.geometry.update()), this.shader.update && this.shader.update(), this.calculateUvs(), this.material._renderCanvas(t, this) }; var gh, yh = function () { function e(t) { this.renderer = t, this._svgMatrix = null, this._tempMatrix = new Ie } return e.prototype._calcCanvasStyle = function (t, e) { var r; return t.texture && t.texture.baseTexture !== Lr.WHITE.baseTexture ? t.texture.valid ? (r = ph.getTintedPattern(t.texture, e), this.setPatternTransform(r, t.matrix || Ie.IDENTITY)) : r = "#808080" : r = "#" + ("00000" + (0 | e).toString(16)).substr(-6), r }, e.prototype.render = function (e) { var r = this.renderer, i = r.context, n = e.worldAlpha, o = e.transform.worldTransform; r.setContextTransform(o), r.setBlendMode(e.blendMode); for (var s, a, h = e.geometry.graphicsData, u = (e.tint >> 16 & 255) / 255, l = (e.tint >> 8 & 255) / 255, c = (255 & e.tint) / 255, d = 0; d < h.length; d++) { var p = h[d], f = p.shape, m = p.fillStyle, v = p.lineStyle, g = 0 | p.fillStyle.color, y = 0 | p.lineStyle.color; if (p.matrix && r.setContextTransform(o.copyTo(this._tempMatrix).append(p.matrix)), m.visible) { var _ = ((g >> 16 & 255) / 255 * u * 255 << 16) + ((g >> 8 & 255) / 255 * l * 255 << 8) + (255 & g) / 255 * c * 255; s = this._calcCanvasStyle(m, _) } if (v.visible) { var x = ((y >> 16 & 255) / 255 * u * 255 << 16) + ((y >> 8 & 255) / 255 * l * 255 << 8) + (255 & y) / 255 * c * 255; a = this._calcCanvasStyle(v, x) } if (i.lineWidth = v.width, i.lineCap = v.cap, i.lineJoin = v.join, i.miterLimit = v.miterLimit, p.type === t.SHAPES.POLY) { i.beginPath(); var b = (O = f).points, E = p.holes, T = void 0, S = void 0, w = void 0, P = void 0; i.moveTo(b[0], b[1]); for (var I = 2; I < b.length; I += 2)i.lineTo(b[I], b[I + 1]); if (O.closeStroke && i.closePath(), E.length > 0) { T = 0, w = b[0], P = b[1]; for (I = 2; I + 2 < b.length; I += 2)T += (b[I] - w) * (b[I + 3] - P) - (b[I + 2] - w) * (b[I + 1] - P); for (var A = 0; A < E.length; A++)if (b = E[A].shape.points) { S = 0, w = b[0], P = b[1]; for (I = 2; I + 2 < b.length; I += 2)S += (b[I] - w) * (b[I + 3] - P) - (b[I + 2] - w) * (b[I + 1] - P); if (S * T < 0) { i.moveTo(b[0], b[1]); for (I = 2; I < b.length; I += 2)i.lineTo(b[I], b[I + 1]) } else { i.moveTo(b[b.length - 2], b[b.length - 1]); for (I = b.length - 4; I >= 0; I -= 2)i.lineTo(b[I], b[I + 1]) } E[A].shape.closeStroke && i.closePath() } } m.visible && (i.globalAlpha = m.alpha * n, i.fillStyle = s, i.fill()), v.visible && (i.globalAlpha = v.alpha * n, i.strokeStyle = a, i.stroke()) } else if (p.type === t.SHAPES.RECT) { var O = f; m.visible && (i.globalAlpha = m.alpha * n, i.fillStyle = s, i.fillRect(O.x, O.y, O.width, O.height)), v.visible && (i.globalAlpha = v.alpha * n, i.strokeStyle = a, i.strokeRect(O.x, O.y, O.width, O.height)) } else if (p.type === t.SHAPES.CIRC) { O = f; i.beginPath(), i.arc(O.x, O.y, O.radius, 0, 2 * Math.PI), i.closePath(), m.visible && (i.globalAlpha = m.alpha * n, i.fillStyle = s, i.fill()), v.visible && (i.globalAlpha = v.alpha * n, i.strokeStyle = a, i.stroke()) } else if (p.type === t.SHAPES.ELIP) { var M = 2 * (O = f).width, D = 2 * O.height, C = O.x - M / 2, R = O.y - D / 2; i.beginPath(); var L = M / 2 * .5522848, N = D / 2 * .5522848, F = C + M, B = R + D, U = C + M / 2, k = R + D / 2; i.moveTo(C, k), i.bezierCurveTo(C, k - N, U - L, R, U, R), i.bezierCurveTo(U + L, R, F, k - N, F, k), i.bezierCurveTo(F, k + N, U + L, B, U, B), i.bezierCurveTo(U - L, B, C, k + N, C, k), i.closePath(), m.visible && (i.globalAlpha = m.alpha * n, i.fillStyle = s, i.fill()), v.visible && (i.globalAlpha = v.alpha * n, i.strokeStyle = a, i.stroke()) } else if (p.type === t.SHAPES.RREC) { var X = (O = f).x, j = O.y, H = O.width, G = O.height, Y = O.radius, z = Math.min(H, G) / 2 | 0; Y = Y > z ? z : Y, i.beginPath(), i.moveTo(X, j + Y), i.lineTo(X, j + G - Y), i.quadraticCurveTo(X, j + G, X + Y, j + G), i.lineTo(X + H - Y, j + G), i.quadraticCurveTo(X + H, j + G, X + H, j + G - Y), i.lineTo(X + H, j + Y), i.quadraticCurveTo(X + H, j, X + H - Y, j), i.lineTo(X + Y, j), i.quadraticCurveTo(X, j, X, j + Y), i.closePath(), m.visible && (i.globalAlpha = m.alpha * n, i.fillStyle = s, i.fill()), v.visible && (i.globalAlpha = v.alpha * n, i.strokeStyle = a, i.stroke()) } } }, e.prototype.setPatternTransform = function (t, e) { if (!1 !== this._svgMatrix) { if (!this._svgMatrix) { var r = document.createElementNS("http://www.w3.org/2000/svg", "svg"); if (r && r.createSVGMatrix && (this._svgMatrix = r.createSVGMatrix()), !this._svgMatrix || !t.setTransform) return void (this._svgMatrix = !1) } this._svgMatrix.a = e.a, this._svgMatrix.b = e.b, this._svgMatrix.c = e.c, this._svgMatrix.d = e.d, this._svgMatrix.e = e.tx, this._svgMatrix.f = e.ty, t.setTransform(this._svgMatrix.inverse()) } }, e.prototype.destroy = function () { this.renderer = null, this._svgMatrix = null, this._tempMatrix = null }, e }(), _h = new Ie; Yo.prototype.generateCanvasTexture = function (t, e) { void 0 === e && (e = 1); var r = this.getLocalBounds(), i = Fr.create({ width: r.width, height: r.height, scaleMode: t, resolution: e }); gh || (gh = new dh), this.transform.updateLocalTransform(), this.transform.localTransform.copyTo(_h), _h.invert(), _h.tx -= r.x, _h.ty -= r.y, gh.render(this, i, !0, _h); var n = Lr.from(i.baseTexture._canvasRenderTarget.canvas, { scaleMode: t }); return n.baseTexture.setResolution(e), n }, Yo.prototype.cachedGraphicsData = [], Yo.prototype._renderCanvas = function (t) { !0 !== this.isMask && (this.finishPoly(), t.plugins.graphics.render(this)) }; var xh = new Ie, bh = function () { function e(t) { this.renderer = t } return e.prototype.render = function (e) { var r = e._texture, i = this.renderer, n = i.context, o = r._frame.width, s = r._frame.height, a = e.transform.worldTransform, h = 0, u = 0, l = r.baseTexture.getDrawableSource(); if (!(r.orig.width <= 0 || r.orig.height <= 0) && r.valid && l && r.valid) { i.setBlendMode(e.blendMode, !0), i.context.globalAlpha = e.worldAlpha; var c = r.baseTexture.scaleMode === t.SCALE_MODES.LINEAR; i.smoothProperty && i.context[i.smoothProperty] !== c && (n[i.smoothProperty] = c), r.trim ? (h = r.trim.width / 2 + r.trim.x - e.anchor.x * r.orig.width, u = r.trim.height / 2 + r.trim.y - e.anchor.y * r.orig.height) : (h = (.5 - e.anchor.x) * r.orig.width, u = (.5 - e.anchor.y) * r.orig.height), r.rotate && (a.copyTo(xh), a = xh, Ne.matrixAppendRotationInv(a, r.rotate, h, u), h = 0, u = 0), h -= o / 2, u -= s / 2, i.setContextTransform(a, e.roundPixels, 1), e.roundPixels && (h |= 0, u |= 0); var d = r.baseTexture.resolution, p = i._outerBlend; p && (n.save(), n.beginPath(), n.rect(h * i.resolution, u * i.resolution, o * i.resolution, s * i.resolution), n.clip()), 16777215 !== e.tint ? (e._cachedTint === e.tint && e._tintedCanvas.tintId === e._texture._updateID || (e._cachedTint = e.tint, e._tintedCanvas = ph.getTintedCanvas(e, e.tint)), n.drawImage(e._tintedCanvas, 0, 0, Math.floor(o * d), Math.floor(s * d), Math.floor(h * i.resolution), Math.floor(u * i.resolution), Math.floor(o * i.resolution), Math.floor(s * i.resolution))) : n.drawImage(l, r._frame.x * d, r._frame.y * d, Math.floor(o * d), Math.floor(s * d), Math.floor(h * i.resolution), Math.floor(u * i.resolution), Math.floor(o * i.resolution), Math.floor(s * i.resolution)), p && n.restore(), i.setBlendMode(t.BLEND_MODES.NORMAL) } }, e.prototype.destroy = function () { this.renderer = null }, e }(); Ko.prototype._tintedCanvas = null, Ko.prototype._renderCanvas = function (t) { t.plugins.sprite.render(this) }; var Eh = new xe, Th = function () { function t(t) { this.renderer = t } return t.prototype.image = function (t, e, r) { var i = new Image; return i.src = this.base64(t, e, r), i }, t.prototype.base64 = function (t, e, r) { return this.canvas(t).toDataURL(e, r) }, t.prototype.canvas = function (t) { var e, r, i, n, o = this.renderer; t && (n = t instanceof Fr ? t : o.generateTexture(t)), n ? (e = n.baseTexture._canvasRenderTarget.context, r = n.baseTexture._canvasRenderTarget.resolution, i = n.frame) : (e = o.rootContext, r = o.resolution, (i = Eh).width = this.renderer.width, i.height = this.renderer.height); var s = Math.floor(i.width * r + 1e-4), a = Math.floor(i.height * r + 1e-4), h = new ue(s, a, 1), u = e.getImageData(i.x * r, i.y * r, s, a); return h.context.putImageData(u, 0, 0), h.canvas }, t.prototype.pixels = function (t) { var e, r, i, n, o = this.renderer; return t && (n = t instanceof Fr ? t : o.generateTexture(t)), n ? (e = n.baseTexture._canvasRenderTarget.context, r = n.baseTexture._canvasRenderTarget.resolution, i = n.frame) : (e = o.rootContext, (i = Eh).width = o.width, i.height = o.height), e.getImageData(0, 0, i.width * r, i.height * r).data }, t.prototype.destroy = function () { this.renderer = null }, t }(); Object.defineProperty(dh.prototype, "extract", { get: function () { return oe("v5.3.0", "CanvasRenderer#extract is deprecated, use CanvasRenderer#plugins.extract"), this.plugins.extract } }); var Sh = function (t, e) { return (Sh = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) })(t, e) }; var wh = 16; function Ph(t, e) { var r = t; if (e instanceof gr) { var i = e.source, n = 0 === i.width ? r.canvas.width : Math.min(r.canvas.width, i.width), o = 0 === i.height ? r.canvas.height : Math.min(r.canvas.height, i.height); return r.ctx.drawImage(i, 0, 0, n, o, 0, 0, r.canvas.width, r.canvas.height), !0 } return !1 } var Ih = function (t) { function e(e) { var r = t.call(this, e) || this; return r.uploadHookHelper = r, r.canvas = document.createElement("canvas"), r.canvas.width = wh, r.canvas.height = wh, r.ctx = r.canvas.getContext("2d"), r.registerUploadHook(Ph), r } return function (t, e) { function r() { this.constructor = t } Sh(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) }(e, t), e.prototype.destroy = function () { t.prototype.destroy.call(this), this.ctx = null, this.canvas = null }, e }(vs); return Is.prototype._renderCanvas = function (t) { var e = this._texture; if (e.baseTexture.valid) { var r = t.context, i = this.worldTransform, n = e.baseTexture, o = n.getDrawableSource(), s = n.resolution, a = this.tilePosition.x / this.tileScale.x % e._frame.width * s, h = this.tilePosition.y / this.tileScale.y % e._frame.height * s; if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint) { this._textureID = this._texture._updateID; var u = new ue(e._frame.width, e._frame.height, s); 16777215 !== this.tint ? (this._tintedCanvas = ph.getTintedCanvas(this, this.tint), u.context.drawImage(this._tintedCanvas, 0, 0)) : u.context.drawImage(o, -e._frame.x * s, -e._frame.y * s), this._cachedTint = this.tint, this._canvasPattern = u.context.createPattern(u.canvas, "repeat") } r.globalAlpha = this.worldAlpha, t.setBlendMode(this.blendMode), t.setContextTransform(i), r.fillStyle = this._canvasPattern, r.scale(this.tileScale.x / s, this.tileScale.y / s); var l = this.anchor.x * -this._width, c = this.anchor.y * -this._height; this.uvRespectAnchor ? (r.translate(a, h), r.fillRect(-a + l, -h + c, this._width / this.tileScale.x * s, this._height / this.tileScale.y * s)) : (r.translate(a + l, h + c), r.fillRect(-a, -h, this._width / this.tileScale.x * s, this._height / this.tileScale.y * s)) } }, ho.prototype.renderCanvas = function (t) { if (this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable) { var e = t.context, r = this.worldTransform, i = !0, n = 0, o = 0, s = 0, a = 0; t.setBlendMode(this.blendMode), e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform(); for (var h = 0; h < this.children.length; ++h) { var u = this.children[h]; if (u.visible && u._texture.valid) { var l = u._texture.frame; if (e.globalAlpha = this.worldAlpha * u.alpha, u.rotation % (2 * Math.PI) == 0) i && (t.setContextTransform(r, !1, 1), i = !1), n = u.anchor.x * (-l.width * u.scale.x) + u.position.x + .5, o = u.anchor.y * (-l.height * u.scale.y) + u.position.y + .5, s = l.width * u.scale.x, a = l.height * u.scale.y; else { i || (i = !0), u.displayObjectUpdateTransform(); var c = u.worldTransform; t.setContextTransform(c, this.roundPixels, 1), n = u.anchor.x * -l.width + .5, o = u.anchor.y * -l.height + .5, s = l.width, a = l.height } var d = u._texture.baseTexture.resolution; e.drawImage(u._texture.baseTexture.getDrawableSource(), l.x * d, l.y * d, l.width * d, l.height * d, n * t.resolution, o * t.resolution, s * t.resolution, a * t.resolution) } } } }, Ge.prototype._renderCanvas = function (t) { }, Ge.prototype.renderCanvas = function (t) { if (this.visible && !(this.worldAlpha <= 0) && this.renderable) { this._mask && t.maskManager.pushMask(this._mask), this._renderCanvas(t); for (var e = 0, r = this.children.length; e < r; ++e)this.children[e].renderCanvas(t); this._mask && t.maskManager.popMask(t) } }, Xe.prototype.renderCanvas = function (t) { }, ss.prototype._renderCanvas = function (t) { this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution, this.dirty = !0), this.updateText(!0), Ko.prototype._renderCanvas.call(this, t) }, dh.registerPlugin("accessibility", Ze), dh.registerPlugin("extract", Th), dh.registerPlugin("graphics", yh), dh.registerPlugin("interaction", hr), dh.registerPlugin("mesh", mh), dh.registerPlugin("prepare", Ih), dh.registerPlugin("sprite", bh), t.AbstractBatchRenderer = En, t.AbstractRenderer = fn, t.AccessibilityManager = Ze, t.AnimatedSprite = rh, t.AppLoaderPlugin = io, t.Application = On, t.Attribute = Ur, t.BasePrepare = vs, t.BaseRenderTexture = Dr, t.BaseTexture = gr, t.BatchDrawCall = _n, t.BatchGeometry = Sn, t.BatchPluginFactory = In, t.BatchRenderer = An, t.BatchShaderGenerator = Tn, t.BatchTextureArray = xn, t.BitmapFont = Qs, t.BitmapFontData = Ys, t.BitmapFontLoader = ra, t.BitmapText = ea, t.Bounds = Be, t.Buffer = Xr, t.CanvasExtract = Th, t.CanvasGraphicsRenderer = yh, t.CanvasMeshRenderer = mh, t.CanvasPrepare = Ih, t.CanvasRenderer = dh, t.CanvasSpriteRenderer = bh, t.Circle = be, t.Container = Ge, t.CountLimiter = hs, t.DEG_TO_RAD = _e, t.DisplayObject = Xe, t.Ellipse = Ee, t.Extract = Cn, t.FillStyle = mo, t.Filter = Fi, t.FilterState = Jr, t.Framebuffer = Mr, t.GLFramebuffer = ii, t.GLProgram = Qi, t.GLTexture = ln, t.GRAPHICS_CURVES = fo, t.Geometry = Vr, t.Graphics = Yo, t.GraphicsData = Bo, t.GraphicsGeometry = Xo, t.IGLUniformData = Ji, t.InteractionData = tr, t.InteractionEvent = rr, t.InteractionManager = hr, t.InteractionTrackingData = ir, t.LineStyle = jo, t.Loader = ro, t.LoaderResource = $n, t.MaskData = ui, t.Matrix = Ie, t.Mesh = Us, t.MeshBatchUvs = Ns, t.MeshGeometry = Hs, t.MeshMaterial = js, t.NineSlicePlane = th, t.ObjectRenderer = $r, t.ObservablePoint = Pe, t.PI_2 = ge, t.ParticleContainer = ho, t.ParticleRenderer = po, t.PlaneGeometry = qa, t.Point = we, t.Polygon = Te, t.Prepare = xs, t.Program = Ri, t.Quad = Wr, t.QuadUv = qr, t.RAD_TO_DEG = ye, t.Rectangle = xe, t.RenderTexture = Fr, t.RenderTexturePool = Br, t.Renderer = mn, t.RopeGeometry = Ka, t.RoundedRectangle = Se, t.Runner = ur, t.Shader = Li, t.SimpleMesh = Qa, t.SimplePlane = Ja, t.SimpleRope = Za, t.Sprite = Ko, t.SpriteMaskFilter = ji, t.Spritesheet = Es, t.SpritesheetLoader = Ts, t.State = Ni, t.System = Ar, t.TemporaryDisplayObject = je, t.Text = ss, t.TextMetrics = is, t.TextStyle = $o, t.Texture = Lr, t.TextureLoader = eo, t.TextureMatrix = Xi, t.TextureUvs = Cr, t.Ticker = Qe, t.TickerPlugin = $e, t.TilingSprite = Is, t.TilingSpriteRenderer = Cs, t.TimeLimiter = bs, t.Transform = Fe, t.UniformGroup = Zr, t.VERSION = "5.3.8", t.ViewableBuffer = bn, t.accessibleTarget = Ye, t.autoDetectRenderer = vn, t.canvasUtils = ph, t.checkMaxIfStatementsInShader = Mi, t.defaultFilterVertex = yn, t.defaultVertex = gn, t.filters = sh, t.graphicsUtils = Fo, t.groupD8 = Ne, t.interactiveTarget = or, t.isMobile = M, t.resources = Ir, t.settings = D, t.systems = dn, t.uniformParsers = Si, t.useDeprecated = function () { var t = this; Object.defineProperties(t, { SVG_SIZE: { get: function () { return oe(oh, "PIXI.utils.SVG_SIZE property has moved to PIXI.resources.SVGResource.SVG_SIZE"), t.SVGResource.SVG_SIZE } }, TransformStatic: { get: function () { return oe(oh, "PIXI.TransformStatic class has been removed, use PIXI.Transform"), t.Transform } }, TransformBase: { get: function () { return oe(oh, "PIXI.TransformBase class has been removed, use PIXI.Transform"), t.Transform } }, TRANSFORM_MODE: { get: function () { return oe(oh, "PIXI.TRANSFORM_MODE property has been removed"), { STATIC: 0, DYNAMIC: 1 } } }, WebGLRenderer: { get: function () { return oe(oh, "PIXI.WebGLRenderer class has moved to PIXI.Renderer"), t.Renderer } }, CanvasRenderTarget: { get: function () { return oe(oh, "PIXI.CanvasRenderTarget class has moved to PIXI.utils.CanvasRenderTarget"), t.utils.CanvasRenderTarget } }, loader: { get: function () { return oe(oh, "PIXI.loader instance has moved to PIXI.Loader.shared"), t.Loader.shared } }, FilterManager: { get: function () { return oe(oh, "PIXI.FilterManager class has moved to PIXI.systems.FilterSystem"), t.systems.FilterSystem } }, CanvasTinter: { get: function () { return oe("5.2.0", "PIXI.CanvasTinter namespace has moved to PIXI.canvasUtils"), t.canvasUtils } }, GroupD8: { get: function () { return oe("5.2.0", "PIXI.GroupD8 namespace has moved to PIXI.groupD8"), t.groupD8 } } }), t.accessibility = {}, Object.defineProperties(t.accessibility, { AccessibilityManager: { get: function () { return oe("5.3.0", "PIXI.accessibility.AccessibilityManager moved to PIXI.AccessibilityManager"), t.AccessibilityManager } } }), t.interaction = {}, Object.defineProperties(t.interaction, { InteractionManager: { get: function () { return oe("5.3.0", "PIXI.interaction.InteractionManager moved to PIXI.InteractionManager"), t.InteractionManager } }, InteractionData: { get: function () { return oe("5.3.0", "PIXI.interaction.InteractionData moved to PIXI.InteractionData"), t.InteractionData } }, InteractionEvent: { get: function () { return oe("5.3.0", "PIXI.interaction.InteractionEvent moved to PIXI.InteractionEvent"), t.InteractionEvent } } }), t.prepare = {}, Object.defineProperties(t.prepare, { BasePrepare: { get: function () { return oe("5.2.1", "PIXI.prepare.BasePrepare moved to PIXI.BasePrepare"), t.BasePrepare } }, Prepare: { get: function () { return oe("5.2.1", "PIXI.prepare.Prepare moved to PIXI.Prepare"), t.Prepare } }, CanvasPrepare: { get: function () { return oe("5.2.1", "PIXI.prepare.CanvasPrepare moved to PIXI.CanvasPrepare"), t.CanvasPrepare } } }), t.extract = {}, Object.defineProperties(t.extract, { Extract: { get: function () { return oe("5.2.1", "PIXI.extract.Extract moved to PIXI.Extract"), t.Extract } }, CanvasExtract: { get: function () { return oe("5.2.1", "PIXI.extract.CanvasExtract moved to PIXI.CanvasExtract"), t.CanvasExtract } } }), t.extras = {}, Object.defineProperties(t.extras, { TilingSprite: { get: function () { return oe(oh, "PIXI.extras.TilingSprite class has moved to PIXI.TilingSprite"), t.TilingSprite } }, TilingSpriteRenderer: { get: function () { return oe(oh, "PIXI.extras.TilingSpriteRenderer class has moved to PIXI.TilingSpriteRenderer"), t.TilingSpriteRenderer } }, AnimatedSprite: { get: function () { return oe(oh, "PIXI.extras.AnimatedSprite class has moved to PIXI.AnimatedSprite"), t.AnimatedSprite } }, BitmapText: { get: function () { return oe(oh, "PIXI.extras.BitmapText class has moved to PIXI.BitmapText"), t.BitmapText } } }), t.TilingSprite.fromFrame = function (e, r, i) { return oe("5.3.0", "TilingSprite.fromFrame is deprecated, use TilingSprite.from"), t.TilingSprite.from(e, { width: r, height: i }) }, t.TilingSprite.fromImage = function (e, r, i, n) { return void 0 === n && (n = {}), oe("5.3.0", "TilingSprite.fromImage is deprecated, use TilingSprite.from"), n && "object" != typeof n && (n = { scaleMode: arguments[4], resourceOptions: { crossorigin: arguments[3] } }), n.width = r, n.height = i, t.TilingSprite.from(e, n) }, Object.defineProperties(t.utils, { getSvgSize: { get: function () { return oe(oh, "PIXI.utils.getSvgSize function has moved to PIXI.resources.SVGResource.getSize"), t.resources.SVGResource.getSize } } }), t.mesh = {}, Object.defineProperties(t.mesh, { Mesh: { get: function () { return oe(oh, "PIXI.mesh.Mesh class has moved to PIXI.SimpleMesh"), t.SimpleMesh } }, NineSlicePlane: { get: function () { return oe(oh, "PIXI.mesh.NineSlicePlane class has moved to PIXI.NineSlicePlane"), t.NineSlicePlane } }, Plane: { get: function () { return oe(oh, "PIXI.mesh.Plane class has moved to PIXI.SimplePlane"), t.SimplePlane } }, Rope: { get: function () { return oe(oh, "PIXI.mesh.Rope class has moved to PIXI.SimpleRope"), t.SimpleRope } }, RawMesh: { get: function () { return oe(oh, "PIXI.mesh.RawMesh class has moved to PIXI.Mesh"), t.Mesh } }, CanvasMeshRenderer: { get: function () { return oe(oh, "PIXI.mesh.CanvasMeshRenderer class has moved to PIXI.CanvasMeshRenderer"), t.CanvasMeshRenderer } }, MeshRenderer: { get: function () { return oe(oh, "PIXI.mesh.MeshRenderer class has moved to PIXI.MeshRenderer"), t.MeshRenderer } } }), t.particles = {}, Object.defineProperties(t.particles, { ParticleContainer: { get: function () { return oe(oh, "PIXI.particles.ParticleContainer class has moved to PIXI.ParticleContainer"), t.ParticleContainer } }, ParticleRenderer: { get: function () { return oe(oh, "PIXI.particles.ParticleRenderer class has moved to PIXI.ParticleRenderer"), t.ParticleRenderer } } }), t.ticker = {}, Object.defineProperties(t.ticker, { Ticker: { get: function () { return oe(oh, "PIXI.ticker.Ticker class has moved to PIXI.Ticker"), t.Ticker } }, shared: { get: function () { return oe(oh, "PIXI.ticker.shared instance has moved to PIXI.Ticker.shared"), t.Ticker.shared } } }), t.loaders = {}, Object.defineProperties(t.loaders, { Loader: { get: function () { return oe(oh, "PIXI.loaders.Loader class has moved to PIXI.Loader"), t.Loader } }, Resource: { get: function () { return oe(oh, "PIXI.loaders.Resource class has moved to PIXI.LoaderResource"), t.LoaderResource } }, bitmapFontParser: { get: function () { return oe(oh, "PIXI.loaders.bitmapFontParser function has moved to PIXI.BitmapFontLoader.use"), t.BitmapFontLoader.use } }, parseBitmapFontData: { get: function () { oe(oh, "PIXI.loaders.parseBitmapFontData function has removed") } }, spritesheetParser: { get: function () { return oe(oh, "PIXI.loaders.spritesheetParser function has moved to PIXI.SpritesheetLoader.use"), t.SpritesheetLoader.use } }, getResourcePath: { get: function () { return oe(oh, "PIXI.loaders.getResourcePath property has moved to PIXI.SpritesheetLoader.getResourcePath"), t.SpritesheetLoader.getResourcePath } } }), t.Loader.addPixiMiddleware = function (e) { return oe(oh, "PIXI.loaders.Loader.addPixiMiddleware function is deprecated, use PIXI.loaders.Loader.registerPlugin"), t.loaders.Loader.registerPlugin({ use: e() }) }; var e = function (t) { return "on" + t.charAt(0).toUpperCase() + t.slice(1) }; Object.assign(t.Loader.prototype, { on: function (t) { var r = e(t); oe(oh, "PIXI.Loader#on is completely deprecated, use PIXI.Loader#" + r + ".add") }, once: function (t) { var r = e(t); oe(oh, "PIXI.Loader#once is completely deprecated, use PIXI.Loader#" + r + ".once") }, off: function (t) { var r = e(t); oe(oh, "PIXI.Loader#off is completely deprecated, use PIXI.Loader#" + r + ".detach") } }), Object.defineProperty(t.extract, "WebGLExtract", { get: function () { return oe(oh, "PIXI.extract.WebGLExtract method has moved to PIXI.Extract"), t.Extract } }), Object.defineProperty(t.prepare, "WebGLPrepare", { get: function () { return oe(oh, "PIXI.prepare.WebGLPrepare class has moved to PIXI.Prepare"), t.Prepare } }), t.Container.prototype._renderWebGL = function (t) { oe(oh, "PIXI.Container._renderWebGL method has moved to PIXI.Container._render"), this._render(t) }, t.Container.prototype.renderWebGL = function (t) { oe(oh, "PIXI.Container.renderWebGL method has moved to PIXI.Container.render"), this.render(t) }, t.DisplayObject.prototype.renderWebGL = function (t) { oe(oh, "PIXI.DisplayObject.renderWebGL method has moved to PIXI.DisplayObject.render"), this.render(t) }, t.Container.prototype.renderAdvancedWebGL = function (t) { oe(oh, "PIXI.Container.renderAdvancedWebGL method has moved to PIXI.Container.renderAdvanced"), this.renderAdvanced(t) }, Object.defineProperties(t.settings, { TRANSFORM_MODE: { get: function () { return oe(oh, "PIXI.settings.TRANSFORM_MODE property has been removed"), 0 }, set: function () { oe(oh, "PIXI.settings.TRANSFORM_MODE property has been removed") } } }); var r = t.BaseTexture; r.prototype.loadSource = function (e) { oe(oh, "PIXI.BaseTexture.loadSource method has been deprecated"); var r = t.resources.autoDetectResource(e); r.internal = !0, this.setResource(r), this.update() }; var i = !1; Object.defineProperties(r.prototype, { hasLoaded: { get: function () { return oe(oh, "PIXI.BaseTexture.hasLoaded property has been removed, use PIXI.BaseTexture.valid"), this.valid } }, imageUrl: { get: function () { var t; return oe(oh, "PIXI.BaseTexture.imageUrl property has been removed, use PIXI.BaseTexture.resource.url"), null === (t = this.resource) || void 0 === t ? void 0 : t.url }, set: function (t) { oe(oh, "PIXI.BaseTexture.imageUrl property has been removed, use PIXI.BaseTexture.resource.url"), this.resource && (this.resource.url = t) } }, source: { get: function () { return oe(oh, "PIXI.BaseTexture.source property has been moved, use `PIXI.BaseTexture.resource.source`"), this.resource.source }, set: function (t) { oe(oh, "PIXI.BaseTexture.source property has been moved, use `PIXI.BaseTexture.resource.source` if you want to set HTMLCanvasElement. Otherwise, create new BaseTexture."), this.resource && (this.resource.source = t) } }, premultiplyAlpha: { get: function () { return oe("5.2.0", "PIXI.BaseTexture.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), 0 !== this.alphaMode }, set: function (t) { oe("5.2.0", "PIXI.BaseTexture.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), this.alphaMode = Number(t) } }, _id: { get: function () { return i || (oe("5.2.0", "PIXI.BaseTexture._id batch local field has been changed to `_batchLocation`"), i = !0), this._batchLocation }, set: function (t) { this._batchLocation = t } } }), r.fromImage = function (t, e, i, n) { oe(oh, "PIXI.BaseTexture.fromImage method has been replaced with PIXI.BaseTexture.from"); var o = { scale: n, crossorigin: e }; return r.from(t, { scaleMode: i, resourceOptions: o }) }, r.fromCanvas = function (t, e) { return oe(oh, "PIXI.BaseTexture.fromCanvas method has been replaced with PIXI.BaseTexture.from"), r.from(t, { scaleMode: e }) }, r.fromSVG = function (t, e, i, n) { oe(oh, "PIXI.BaseTexture.fromSVG method has been replaced with PIXI.BaseTexture.from"); var o = { scale: n, crossorigin: e }; return r.from(t, { scaleMode: i, resourceOptions: o }) }, Object.defineProperties(t.resources.ImageResource.prototype, { premultiplyAlpha: { get: function () { return oe("5.2.0", "PIXI.resources.ImageResource.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), 0 !== this.alphaMode }, set: function (t) { oe("5.2.0", "PIXI.resources.ImageResource.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), this.alphaMode = Number(t) } } }), t.Point.prototype.copy = function (t) { return oe(oh, "PIXI.Point.copy method has been replaced with PIXI.Point.copyFrom"), this.copyFrom(t) }, t.ObservablePoint.prototype.copy = function (t) { return oe(oh, "PIXI.ObservablePoint.copy method has been replaced with PIXI.ObservablePoint.copyFrom"), this.copyFrom(t) }, t.Rectangle.prototype.copy = function (t) { return oe(oh, "PIXI.Rectangle.copy method has been replaced with PIXI.Rectangle.copyFrom"), this.copyFrom(t) }, t.Matrix.prototype.copy = function (t) { return oe(oh, "PIXI.Matrix.copy method has been replaced with PIXI.Matrix.copyTo"), this.copyTo(t) }, t.systems.StateSystem.prototype.setState = function (t) { return oe("v5.1.0", "StateSystem.setState has been renamed to StateSystem.set"), this.set(t) }, Object.assign(t.systems.FilterSystem.prototype, { getRenderTarget: function (t, e) { return oe(oh, "PIXI.FilterManager.getRenderTarget method has been replaced with PIXI.systems.FilterSystem#getFilterTexture"), this.getFilterTexture(null, e) }, returnRenderTarget: function (t) { oe(oh, "PIXI.FilterManager.returnRenderTarget method has been replaced with PIXI.systems.FilterSystem.returnFilterTexture"), this.returnFilterTexture(t) }, calculateScreenSpaceMatrix: function (t) { oe(oh, "PIXI.systems.FilterSystem.calculateScreenSpaceMatrix method is removed, use `(vTextureCoord * inputSize.xy) + outputFrame.xy` instead"); var e = t.identity(), r = this.activeState, i = r.sourceFrame, n = r.destinationFrame; return e.translate(i.x / n.width, i.y / n.height), e.scale(n.width, n.height), e }, calculateNormalizedScreenSpaceMatrix: function (t) { oe(oh, "PIXI.systems.FilterManager.calculateNormalizedScreenSpaceMatrix method is removed, use `((vTextureCoord * inputSize.xy) + outputFrame.xy) / outputFrame.zw` instead."); var e = this.activeState, r = e.sourceFrame, i = e.destinationFrame, n = t.identity(); n.translate(r.x / i.width, r.y / i.height); var o = i.width / r.width, s = i.height / r.height; return n.scale(o, s), n } }), Object.defineProperties(t.RenderTexture.prototype, { sourceFrame: { get: function () { return oe(oh, "PIXI.RenderTexture.sourceFrame property has been removed"), this.filterFrame } }, size: { get: function () { return oe(oh, "PIXI.RenderTexture.size property has been removed"), this._frame } } }); var n = function (t) { function e(e, r, i, n) { return oe(oh, "PIXI.filters.BlurXFilter class is deprecated, use PIXI.filters.BlurFilterPass"), t.call(this, !0, e, r, i, n) || this } return nh(e, t), e }(t.filters.BlurFilterPass), o = function (t) { function e(e, r, i, n) { return oe(oh, "PIXI.filters.BlurYFilter class is deprecated, use PIXI.filters.BlurFilterPass"), t.call(this, !1, e, r, i, n) || this } return nh(e, t), e }(t.filters.BlurFilterPass); Object.assign(t.filters, { BlurXFilter: n, BlurYFilter: o }); var s = t.Sprite, a = t.Texture, h = t.Graphics; function u(t, e, r, i) { return oe(oh, "PIXI.Sprite." + t + " method is deprecated, use PIXI.Sprite.from"), s.from(e, { resourceOptions: { scale: i, crossorigin: r } }) } function l(t, e, r, i) { return oe(oh, "PIXI.Texture." + t + " method is deprecated, use PIXI.Texture.from"), a.from(e, { resourceOptions: { scale: i, crossorigin: r } }) } h.prototype.generateCanvasTexture || (h.prototype.generateCanvasTexture = function () { oe(oh, 'PIXI.Graphics.generateCanvasTexture method is only available in "pixi.js-legacy"') }), Object.defineProperty(h.prototype, "graphicsData", { get: function () { return oe(oh, "PIXI.Graphics.graphicsData property is deprecated, use PIXI.Graphics.geometry.graphicsData"), this.geometry.graphicsData } }), s.fromImage = u.bind(null, "fromImage"), s.fromSVG = u.bind(null, "fromSVG"), s.fromCanvas = u.bind(null, "fromCanvas"), s.fromVideo = u.bind(null, "fromVideo"), s.fromFrame = u.bind(null, "fromFrame"), a.fromImage = l.bind(null, "fromImage"), a.fromSVG = l.bind(null, "fromSVG"), a.fromCanvas = l.bind(null, "fromCanvas"), a.fromVideo = l.bind(null, "fromVideo"), a.fromFrame = l.bind(null, "fromFrame"), Object.defineProperty(t.AbstractRenderer.prototype, "autoResize", { get: function () { return oe(oh, "PIXI.AbstractRenderer.autoResize property is deprecated, use PIXI.AbstractRenderer.autoDensity"), this.autoDensity }, set: function (t) { oe(oh, "PIXI.AbstractRenderer.autoResize property is deprecated, use PIXI.AbstractRenderer.autoDensity"), this.autoDensity = t } }), Object.defineProperty(t.Renderer.prototype, "textureManager", { get: function () { return oe(oh, "PIXI.Renderer.textureManager property is deprecated, use PIXI.Renderer.texture"), this.texture } }), t.utils.mixins = { mixin: function () { oe(oh, "PIXI.utils.mixins.mixin function is no longer available") }, delayMixin: function () { oe(oh, "PIXI.utils.mixins.delayMixin function is no longer available") }, performMixins: function () { oe(oh, "PIXI.utils.mixins.performMixins function is no longer available") } }, Object.defineProperty(t.BitmapText.prototype, "font", { get: function () { return oe("5.3.0", "PIXI.BitmapText.font property is deprecated, use fontName, fontSize, tint or align properties"), { name: this._fontName, size: this._fontSize, tint: this._tint, align: this._align } }, set: function (e) { if (oe("5.3.0", "PIXI.BitmapText.font property is deprecated, use fontName, fontSize, tint or align properties"), e) { var r = { font: e }; this._upgradeStyle(r), r.fontSize = r.fontSize || t.BitmapFont.available[r.fontName].size, this._fontName = r.fontName, this._fontSize = r.fontSize, this.dirty = !0 } } }) }, t.utils = ve, t }({}); PIXI.useDeprecated();
//# sourceMappingURL=pixi-legacy.min.js.map
// main
var Incremancer;
(() => {
    "use strict";
    var e = {};
    function t(e, t) {
        return Math.sqrt(e * e + t * t);
    }
    function s(e, t, s, i) {
        return Math.sqrt((e - s) * (e - s) + (t - i) * (t - i));
    }
    function i(e, t, s, i) {
        const a = Math.abs(e - s),
            r = Math.abs(t - i);
        return 0.4 * (a + r) + 0.56 * Math.max(a, r);
    }
    function a(e, t) {
        return e[Math.floor(t * e.length)];
    }
    function r(e) {
        return o(e, 2);
    }
    function n(e) {
        return o(e, e > 1e3 ? 2 : 0);
    }
    function o(e, t) {
        return (
            e || (e = 0),
            e >= 1e15 ? e.toExponential(t).replace("+", "") : e >= 1e12 ? (e / 1e12).toFixed(t) + "T" : e >= 1e9 ? (e / 1e9).toFixed(t) + "B" : e >= 1e6 ? (e / 1e6).toFixed(t) + "M" : e >= 1e3 ? (e / 1e3).toFixed(t) + "K" : e.toFixed(t)
        );
    }
    function h(e, t, s, i) {
        return 1 == t ? Math.floor(i / e) : Math.floor(Math.log((i * (t - 1)) / (e * Math.pow(t, s)) + 1) / Math.log(t));
    }
    function l(e, t, s, i) {
        return 1 == t ? e * i : e * ((Math.pow(t, s) * (Math.pow(t, i) - 1)) / (t - 1));
    }
    function d(e, t) {
        const s = document.getElementById("champ-hold").getBoundingClientRect();
        let i = e.clientX - s.x;
        const a = e.clientY - s.y;
        i > s.width / 2 && (i -= t.getElementsByClassName("tooltip")[0].getBoundingClientRect().width), (t.getElementsByClassName("tooltip")[0].style.top = a + 20 + "px"), (t.getElementsByClassName("tooltip")[0].style.left = i + 20 + "px");
    }
    let c, u, p, g, m, b, f, y, x;
    ((e) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 });
    })(e);
    let v,
        S,
        M,
        k,
        w,
        T,
        C,
        D = { x: 800, y: 600, defaultScale: 1 },
        P = { x: 600, y: 600 };
    function z(e) {
        (this.data = e.data),
            (this.dragging = !0),
            (this.dragOffset = this.data.getLocalPosition(this)),
            (this.dragOffset.x *= this.scale.x),
            (this.dragOffset.y *= this.scale.y),
            (this.dragStartX = this.x),
            (this.dragStartY = this.y),
            (B = 0);
    }
    function I() {
        (this.dragging = !1), (this.data = null), (B = 0);
    }
    let B = 0,
        R = 0;
    function H(e) {
        if (T.zombieCursor) {
            T.zombieCursor.position = e.data.getLocalPosition(this.parent);
            const t = e.data.getLocalPosition(x);
            T.mouseOutOfBounds = t.x < 0 || t.y < 0 || t.x > x.width || t.y > x.height;
        }
        if (e.data.originalEvent.touches && e.data.originalEvent.touches.length > 1)
            !(function (e) {
                const t = Math.abs(e.data.originalEvent.touches[0].clientX - e.data.originalEvent.touches[1].clientX);
                B ? R + 50 < Date.now() && Math.abs(t - B) > 10 && (A(t > B ? 1 : -1, null), (R = Date.now()), (B = t)) : (B = t);
            })(e);
        else if (this.dragging) {
            const e = this.data.getLocalPosition(this.parent);
            (this.x = e.x - this.dragOffset.x), (this.y = e.y - this.dragOffset.y), F(this), s(this.dragStartX, this.dragStartY, this.x, this.y) > 5 && (this.hasMoved = !0);
        }
    }
    function F(e) {
        const t = P.x * e.scale.x,
            s = P.y * e.scale.y;
        e.x > 0.5 * D.x && (e.x = 0.5 * D.x), e.x + t < 0.5 * D.x && (e.x = 0.5 * D.x - t), e.y > 0.5 * D.y && (e.y = 0.5 * D.y), e.y + s < 0.5 * D.y && (e.y = 0.5 * D.y - s);
    }
    function E(e) {
        this.hasMoved ||
            v.currentState != v.states.playingLevel ||
            (Y.shift ? T.spawnAllZombies(e.data.getLocalPosition(this).x, e.data.getLocalPosition(this).y) : T.spawnZombie(e.data.getLocalPosition(this).x, e.data.getLocalPosition(this).y)),
            (this.hasMoved = !1);
    }
    function A(e, t) {
        if (R + 50 > Date.now()) return;
        R = Date.now();
        const s = c;
        t || (t = { x: 0.5 * D.x, y: 0.5 * D.y });
        const i = P.x * s.scale.x,
            a = P.y * s.scale.y;
        t.x > s.x + i && (t.x = s.x + i), t.x < s.x && (t.x = s.x), t.y < s.y && (t.y = s.y), t.y > s.y + a && (t.y = s.y + a);
        const r = (t.x - s.x) / s.scale.x,
            n = (t.y - s.y) / s.scale.y;
        e > 0
            ? s.scale.x < 10 && ((s.scale.x = s.scale.y = 1.1 * s.scale.x), T.zombieCursor && T.zombieCursor.scale && (T.zombieCursor.scale.x = T.zombieCursor.scale.y = 1.1 * T.zombieCursor.scale.x))
            : Math.max(i, a) > 0.8 * Math.min(D.y, D.x) && ((s.scale.x = s.scale.y = 0.9 * s.scale.x), T.zombieCursor && T.zombieCursor.scale && (T.zombieCursor.scale.x = T.zombieCursor.scale.y = 0.9 * T.zombieCursor.scale.x)),
            (s.x = t.x - r * s.scale.x),
            (s.y = t.y - n * s.scale.y),
            F(s);
    }
    function L(e) {
        e.preventDefault();
        const t = { x: e.clientX * (D.x / document.body.clientWidth), y: e.clientY * (D.y / document.body.clientHeight) };
        e.deltaY < 0 || e.deltaX < 0 ? A(1, t) : A(-1, t);
    }
    function Z(e = !1) {
        e && ((c.scale.x = D.defaultScale), (c.scale.y = D.defaultScale), T.zombieCursor && (T.zombieCursor.scale.x = T.zombieCursor.scale.y = T.zombieCursorScale * D.defaultScale)),
            (c.x = (D.x - P.x * c.scale.x) / 2),
            (c.y = (D.y - P.y * c.scale.y) / 2);
    }
    const G = {
        x: 0,
        y: 0,
        width: 1e3,
        height: 1e3,
        hideParticle(e, t) {
            return e < this.x || t < this.y || e > this.x + this.width || t > this.y + this.height;
        },
        update() {
            (this.x = -c.x / c.scale.x), (this.y = -c.y / c.scale.y), (this.width = D.x / c.scale.x), (this.height = D.y / c.scale.y);
        },
    },
        X = new PIXI.Matrix();
    function U(e, t) {
        !(function (e) {
            const t = Y;
            let s = !1;
            const i = c;
            t.w && ((i.y += t.scrollSpeed * e), (s = !0)), t.a && ((i.x += t.scrollSpeed * e), (s = !0)), t.s && ((i.y -= t.scrollSpeed * e), (s = !0)), t.d && ((i.x -= t.scrollSpeed * e), (s = !0)), s && F(i);
        })(e),
            G.update(),
            (e *= v.gameSpeed),
            M.update(e),
            C.update(e),
            T.update(e),
            k.update(e),
            w.update(e),
            S.update(e),
            (function (e, t) {
                if ((C.vipEscaping && void 0 !== C.vip ? (y.alpha += e) : ((y.alpha -= e), y.alpha < 0 && (y.alpha = 0)), y.alpha > 0)) {
                    y.alpha > 1 && (y.alpha = 1), (y.visible = !0), (y.x = 5), (y.y = D.y - 305);
                    const e = c.scale.x,
                        s = c.scale.y,
                        i = c.x,
                        a = c.y;
                    c.position.set(0, 0), C.vip && ((X.tx = -2 * C.vip.x + 150), (X.ty = -2 * C.vip.y + 150)), c.scale.set(2, 2), t.renderer.render(c, f, void 0, X), c.scale.set(e, s), c.position.set(i, a);
                } else y.visible = !1;
            })(e, t);
    }
    function N() {
        const e = Math.min(500 + 50 * v.level, 1500),
            t = (Math.random() * e) / 3;
        (P = { x: e + t, y: e - t }), x && ((x.width = P.x), (x.height = P.y)), (c.hitArea = new PIXI.Rectangle(0, 0, P.x, P.y));
    }
    function O() {
        const e = document.body.clientWidth,
            t = document.body.clientHeight;
        (D = { x: e, y: t, defaultScale: Math.max(e, t) / 1e3 }), (Y.scrollSpeed = Math.max(e, t) / 4);
    }
    new Map(),
        (window.onload = function () {
            (v = ne.getInstance()),
                (S = new Qe()),
                (M = new Oe()),
                (k = new Ue()),
                (w = new Xe()),
                (T = new ZombieManager()),
                (C = new HumanManager()),
                v.loadData(),
                v.onReady(),
                O(),
                (function () {
                    PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
                    const e = new PIXI.Application({ width: D.x, height: D.y, backgroundColor: 1066256, resolution: v.persistentData.resolution || 1, antialias: !1, resizeTo: window });
                    document.body.appendChild(e.view),
                        PIXI.utils.isWebGLSupported() || console.error("Warning: WebGL support not detected. Game performance may be slower."),
                        (function (e) {
                            (c = new PIXI.Container()),
                                (u = new PIXI.Container()),
                                (p = new PIXI.Container()),
                                (g = new PIXI.Container()),
                                (g.sortableChildren = !0),
                                (b = new PIXI.Container()),
                                (m = new PIXI.Container()),
                                (f = PIXI.RenderTexture.create({ width: 300, height: 300 })),
                                (y = new PIXI.Sprite(f)),
                                (y.visible = !1),
                                (y.alpha = 0),
                                m.addChild(y),
                                c.addChild(u),
                                c.addChild(p),
                                c.addChild(g),
                                c.addChild(b),
                                e.stage.addChild(c),
                                e.stage.addChild(m),
                                (c.interactive = !0),
                                (c.interactiveChildren = !1),
                                c.on("pointerdown", z),
                                c.on("pointerup", I),
                                c.on("pointerupoutside", I),
                                c.on("pointermove", H),
                                c.on("click", E),
                                c.on("tap", E),
                                (document.getElementsByTagName("canvas")[0].onwheel = L),
                                (document.getElementsByTagName("canvas")[0].oncontextmenu = function (e) {
                                    e.preventDefault();
                                });
                        })(e),
                        e.loader
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/ground.json?updatedAt=1757690629714")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/megagraveyard.png?updatedAt=1757690629622")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/graveyard.json?updatedAt=1757690644247")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/buildings.json?updatedAt=1757690632279")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/humans.json?updatedAt=1757690642810")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/cop.json?updatedAt=1757690635178")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/dogs.json?updatedAt=1757690632992")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/army.json?updatedAt=1757690630412")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/doctor.json?updatedAt=1757690632874")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/zombie.json?updatedAt=1757690636028")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/golem.json?updatedAt=1757690642116")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/bonecollector.json?updatedAt=1757690643245")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/harpy.json?updatedAt=1757690638682")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/objects2.json?updatedAt=1757690641558")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/fenceposts.json?updatedAt=1757690635993")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/trees2.json?updatedAt=1757690633605")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/fortress.json?updatedAt=1757690641792")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/tank.json?updatedAt=1757690644211")
                            .add("https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/sprites/skeleton.json?updatedAt=1757690638530")
                            .load(function () {
                                (v.app = e),
                                    N(),
                                    (x = new PIXI.TilingSprite(PIXI.Texture.from("grass.png"))),
                                    (x.texture.baseTexture.mipmap = PIXI.MIPMAP_MODES.OFF),
                                    (x.width = P.x),
                                    (x.height = P.y),
                                    u.addChild(x),
                                    v.setupLevel(),
                                    setTimeout(function () {
                                        Z(!0);
                                    }),
                                    e.ticker.add((t) => {
                                        U(e.ticker.deltaMS / 1e3, e), (v.frameRate = e.ticker.FPS);
                                    });
                            });
                })(),
                window.self !== window.top &&
                ("" != document.referrer && -1 == document.referrer.indexOf("kongregate.com") && -1 == document.referrer.indexOf("konggames.com") && -1 == document.referrer.indexOf("gti.nz")
                    ? (console.log('rickroll trick failed'))
                    : (-1 === document.referrer.indexOf("kongregate.com") && -1 === document.referrer.indexOf("konggames.com")) ||
                    kongregateAPI.loadAPI(function () {
                        (window.kongregate = kongregateAPI.getAPI()), (v.kongregate = !0), v.loginInUsingPlayFab();
                    })),
                document.addEventListener(
                    "visibilitychange",
                    function () {
                        "hidden" == document.visibilityState ? (v.hidden = !0) : (v.hidden = !1);
                    },
                    !1
                );
        }),
        (window.onresize = function () {
            O();
        });
    const Y = { scrollSpeed: 200, w: !1, a: !1, s: !1, d: !1, shift: !1 };
    (window.onblur = function () {
        (Y.w = Y.a = Y.s = Y.d = !1), (Y.shift = !1);
    }),
        (window.onkeydown = function (e) {
            switch (e.keyCode) {
                case 16:
                case 17:
                    Y.shift = !0;
                    break;
                case 87:
                case 38:
                    Y.w = !0;
                    break;
                case 65:
                case 37:
                    Y.a = !0;
                    break;
                case 83:
                case 40:
                    Y.s = !0;
                    break;
                case 68:
                case 39:
                    Y.d = !0;
                    break;
                default:
                    return !0;
            }
            return !1;
        }),
        (window.onkeyup = function (e) {
            switch (e.keyCode) {
                case 16:
                case 17:
                    Y.shift = !1;
                    break;
                case 87:
                case 38:
                    Y.w = !1;
                    break;
                case 65:
                case 37:
                    Y.a = !1;
                    break;
                case 83:
                case 40:
                    Y.s = !1;
                    break;
                case 68:
                case 39:
                    Y.d = !1;
                    break;
                default:
                    return !0;
            }
            return !1;
        });
    class W {
        constructor(e, t, s, i, a, r, n, o, h) {
            (this.id = e),
                (this.name = t),
                (this.tooltip = s),
                (this.itemText = i),
                (this.cooldown = a),
                (this.duration = r),
                (this.energyCost = n),
                (this.start = o),
                (this.end = h),
                (this.timer = 0),
                (this.onCooldown = !1),
                (this.active = !1),
                (this.cooldownLeft = 0);
        }
    }
    class SpellManager {
        constructor() {
            if (
                ((this.cooldownReduction = 0),
                    (this.timeExtension = 0),
                    (this.costReduction = 0),
                    (this.skeleton = new Xe()),
                    (this.zombies = new ZombieManager()),
                    (this.humans = new HumanManager()),
                    (this.spellMap = new Map()),
                    (this.spells = [
                        new W(
                            1,
                            "Time Warp",
                            "Speed up the flow of time for 30 seconds",
                            "",
                            90,
                            30,
                            0,
                            function () {
                                ne.getInstance().gameSpeed = 2;
                            },
                            function () {
                                ne.getInstance().gameSpeed = 1;
                            }
                        ),
                        new W(
                            2,
                            "Energy Charge",
                            "5x Energy rate for 20 seconds, cost 50 energy",
                            "",
                            160,
                            20,
                            50,
                            function () {
                                ne.getInstance().energySpellMultiplier = 5;
                            },
                            function () {
                                ne.getInstance().energySpellMultiplier = 1;
                            }
                        ),
                        new W(
                            3,
                            "Detonate",
                            "Turns your zombies into fast moving living bombs, cost 69 energy... nice",
                            "",
                            80,
                            8,
                            69,
                            function () {
                                new SpellManager().zombies.detonate = !0;
                            },
                            function () {
                                new SpellManager().zombies.detonate = !1;
                            }
                        ),
                        new W(
                            4,
                            "Earth Freeze",
                            "Freeze all humans in place preventing them from moving for 15 seconds, cost 75 energy",
                            "",
                            50,
                            15,
                            75,
                            function () {
                                new SpellManager().humans.frozen = !0;
                            },
                            function () {
                                new SpellManager().humans.frozen = !1;
                            }
                        ),
                        new W(
                            5,
                            "Gigazombies",
                            "For 5 seconds any zombies spawned will be giants with 10x health and attack damage, cost 100 energy",
                            "",
                            260,
                            5,
                            100,
                            function () {
                                new SpellManager().zombies.super = !0;
                            },
                            function () {
                                new SpellManager().zombies.super = !1;
                            }
                        ),
                        new W(
                            6,
                            "Incinerate",
                            "Burns humans near the skeleton champion",
                            "Has a chance to cast Incinerate when attacking, burning all humans within a large radius of the Skeleton",
                            1,
                            10,
                            10,
                            function () {
                                new SpellManager().skeleton.incinerate(), (this.timer = 1);
                            },
                            function () { }
                        ),
                        new W(
                            7,
                            "Pandemic",
                            "Causes plague to spread",
                            "Has a chance to cast Pandemic when attacking, causing infected humans to spread the plague to each other for 20 seconds",
                            10,
                            20,
                            10,
                            function () {
                                new SpellManager().humans.pandemic = !0;
                            },
                            function () {
                                new SpellManager().humans.pandemic = !1;
                            }
                        ),
                        new W(
                            8,
                            "Part Storm",
                            "Doubles parts",
                            "Has a chance to cast Part Storm when attacking, doubling the parts production of your factory machines for 15 seconds",
                            10,
                            15,
                            10,
                            function () {
                                new se().storm = !0;
                            },
                            function () {
                                new se().storm = !1;
                            }
                        ),
                    ]),
                    SpellManager.instance)
            )
                return SpellManager.instance;
            (SpellManager.instance = this), this.spells.forEach((e) => this.spellMap.set(e.id, e));
        }
        lockAllSpells() {
            for (let e = 0; e < this.spells.length; e++) this.spells[e].unlocked = !1;
        }
        unlockSpell(e) {
            this.spellMap.get(e).unlocked = !0;
        }
        getSpell(e) {
            return this.spellMap.get(e);
        }
        getUnlockedSpells() {
            return this.spells.filter((e) => e.unlocked);
        }
        castSpell(e) {
            const t = ne.getInstance();
            e.onCooldown ||
                e.active ||
                !e.unlocked ||
                e.energyCost - this.costReduction > t.energy ||
                ((t.energy -= e.energyCost - this.costReduction), (e.onCooldown = !0), (e.cooldownLeft = e.cooldown * this.cooldownReduction), (e.active = !0), (e.timer = e.duration + this.timeExtension), e.start(), t.sendMessage(e.name));
        }
        castSpellNoMana(e) {
            const t = this.spellMap.get(e);
            t && !t.active && ((t.active = !0), (t.timer = t.duration + this.timeExtension), t.start(), ne.getInstance().sendMessage(t.name));
        }
        updateSpells(e) {
            for (let t = 0; t < this.spells.length; t++) {
                const s = this.spells[t];
                s.onCooldown && !s.active && ((s.cooldownLeft -= e), s.cooldownLeft <= 0 && (s.onCooldown = !1)), s.active && ((s.timer -= e), s.timer <= 0 && ((s.active = !1), s.end()));
            }
        }
    }
    class V extends PIXI.TilingSprite {
        constructor(e) {
            super(e), (this.collisionX = 0), (this.collisionY = 0), (this.collisionWidth = 0), (this.collisionHeight = 0);
        }
    }
    class j {
        constructor(e, t, s, i, a) {
            (this.id = 0), (this.x = 0), (this.y = 0), (this.width = 0), (this.height = 0), (this.entrance = null), (this.id = e), (this.x = t), (this.y = s), (this.width = i), (this.height = a);
        }
    }
    class $ {
        constructor() {
            (this.attack = 0), (this.scan = 0), (this.smoke = 0), (this.burnTick = 0), (this.ability = 0), (this.dogStun = 0), (this.target = 0);
        }
    }
    class K {
        constructor() {
            (this.burning = !1), (this.infected = !1), (this.dead = !1), (this.golem = !1);
        }
    }
    class Q extends PIXI.AnimatedSprite {
        constructor(e) {
            super(e),
                (this.xSpeed = 0),
                (this.ySpeed = 0),
                (this.health = 0),
                (this.maxHealth = 0),
                (this.zombie = !1),
                (this.targetVector = { x: 0, y: 0 }),
                (this.burnDamage = 0),
                (this.hasIcon = !1),
                (this.flags = new K()),
                (this.timer = new $());
        }
        reset() {
            (this.xSpeed = 0), (this.ySpeed = 0), (this.alpha = 1), (this.visible = !0), (this.burnDamage = 0), (this.currentPoi = null), (this.flags.dead = !1), (this.flags.burning = !1), (this.flags.infected = !1);
        }
    }
    class J extends PIXI.Sprite {
        constructor(e) {
            super(e), (this.xSpeed = 0), (this.ySpeed = 0);
        }
    }
    class _ {
        constructor() {
            (this.sprites = []), (this.discardedSprites = []);
        }
        setup(e, t) {
            (this.container = e), (this.texture = t);
        }
        discardSprite(e) {
            (e.visible = !1), this.discardedSprites.push(e);
        }
        getSprite() {
            if (this.discardedSprites.length > 0) {
                const e = this.discardedSprites.pop();
                return (e.visible = !0), e;
            }
            const e = this.create(this.texture);
            return this.container.addChild(e), this.sprites.push(e), e;
        }
    }
    class MapManager {
        constructor() {
            if (
                ((this.gameModel = ne.getInstance()),
                    (this.humans = new HumanManager()),
                    (this.discardedWalls = []),
                    (this.discardedContainers = []),
                    (this.discardedFloorSprites = []),
                    (this.buildings = []),
                    (this.buildingsByPopularity = []),
                    (this.buildingMap = []),
                    (this.roadSprite = null),
                    (this.roadTexture = null),
                    (this.entranceWidth = 16),
                    (this.entranceDepth = 16),
                    (this.cornerDistance = 16),
                    (this.minBuildings = 3),
                    (this.wallWidth = 4),
                    (this.graveyardCollision = null),
                    (this.graveYardLocation = { x: 0, y: 0 }),
                    (this.graveYardPosition = null),
                    (this.wallCollisionBuffer = 3),
                    (this.fastDistance = i),
                    (this.pathFindStepSize = 5),
                    (this.dx = 0),
                    (this.dy = 0),
                    (this.stepsToTake = 10),
                    (this.hasHit = !1),
                    (this.vector = null),
                    (this.corner = null),
                    (this.hitbuilding = !1),
                    (this.insideBuilding = !1),
                    (this.treeSprites = []),
                    (this.treeTextures = []),
                    (this.armyTextures = []),
                    MapManager.instance)
            )
                return MapManager.instance;
            MapManager.instance = this;
        }
        getRandomBuilding() {
            return a(this.buildingsByPopularity, Math.random());
        }
        roomNoOverlap(e, t) {
            return e.x > t.x + t.width + 50 || e.x + e.width + 50 < t.x || e.y > t.y + t.height + 50 || e.y + e.height + 50 < t.y || void 0;
        }
        isValidPosition(e) {
            if (!this.roomNoOverlap(e, this.graveYardPosition)) return !1;
            for (let t = 0; t < this.buildings.length; t++) if (!this.roomNoOverlap(e, this.buildings[t])) return !1;
            return !(this.gameModel.level % 5 == 0 && !this.gameModel.isBossStage(this.gameModel.level) && e.y < this.roadSprite.y + this.roadSprite.height && e.y + e.height > this.roadSprite.y);
        }
        getWall(e) {
            if (this.discardedWalls.length > 0) {
                const t = this.discardedWalls.pop();
                return (t.texture = e), t;
            }
            return new V(e);
        }
        makeHorizontalWall(e, t, s, i, a, r) {
            if (s) {
                const s = this.getWall(t);
                (s.x = i), (s.y = a), (s.width = r / 2 - this.entranceWidth), (s.height = 4), e.push(s);
                const n = this.getWall(t);
                (n.x = i + r / 2 + this.entranceWidth), (n.y = a), (n.width = r / 2 - this.entranceWidth), (n.height = 4), e.push(n);
            } else {
                const s = this.getWall(t);
                (s.x = i), (s.y = a), (s.width = r), (s.height = 4), e.push(s);
            }
        }
        makeVerticalWall(e, t, s, i, a, r) {
            if (s) {
                const s = this.getWall(t);
                (s.x = i), (s.y = a), (s.width = 4), (s.height = r / 2 - this.entranceWidth), e.push(s);
                const n = this.getWall(t);
                (n.x = i), (n.y = a + r / 2 + this.entranceWidth), (n.width = 4), (n.height = r / 2 - this.entranceWidth), e.push(n);
            } else {
                const s = this.getWall(t);
                (s.x = i), (s.y = a), (s.width = 4), (s.height = r), e.push(s);
            }
        }
        getContainer() {
            return this.discardedContainers.length > 0 ? this.discardedContainers.pop() : new PIXI.Container();
        }
        getFloorSprite() {
            return this.discardedFloorSprites.length > 0 ? this.discardedFloorSprites.pop() : new PIXI.TilingSprite(PIXI.Texture.WHITE);
        }
        addBuilding(e) {
            var t, s;
            (e.container = this.getContainer()),
                (e.container.cacheAsBitmap = !1),
                (e.floorSprite = this.getFloorSprite()),
                (e.floorSprite.tint = ((t = 10 + Math.round(50 * Math.random())), (s = 10 + Math.round(50 * Math.random())), (10 + Math.round(50 * Math.random())) | (s << 8) | (t << 16))),
                (e.floorSprite.alpha = 0.2),
                (e.container.x = e.x),
                (e.container.y = e.y),
                (e.floorSprite.width = e.width),
                (e.floorSprite.height = e.height),
                e.container.addChild(e.floorSprite);
            const r = [
                { x: e.x + e.width / 2, y: e.y, north: !0, inside: { x: e.x + e.width / 2, y: e.y + this.entranceDepth, entrance: !0 }, outside: { x: e.x + e.width / 2, y: e.y - this.entranceDepth, entrance: !0 } },
                {
                    x: e.x + e.width / 2,
                    y: e.y + e.height,
                    south: !0,
                    inside: { x: e.x + e.width / 2, y: e.y + e.height - this.entranceDepth, entrance: !0 },
                    outside: { x: e.x + e.width / 2, y: e.y + e.height + this.entranceDepth, entrance: !0 },
                },
                { x: e.x, y: e.y + e.height / 2, west: !0, inside: { x: e.x + this.entranceDepth, y: e.y + e.height / 2, entrance: !0 }, outside: { x: e.x - this.entranceDepth, y: e.y + e.height / 2, entrance: !0 } },
                {
                    x: e.x + e.width,
                    y: e.y + e.height / 2,
                    east: !0,
                    inside: { x: e.x + e.width - this.entranceDepth, y: e.y + e.height / 2, entrance: !0 },
                    outside: { x: e.x + e.width + this.entranceDepth, y: e.y + e.height / 2, entrance: !0 },
                },
            ];
            let n;
            const o = { x: P.x / 2, y: P.y / 2 };
            let h = 2e3;
            for (let e = 0; e < r.length; e++) {
                const t = i(r[e].x, r[e].y, o.x, o.y);
                t < h && ((h = t), (n = r[e]));
            }
            (e.entrance = n), this.gameModel.level % 5 == 0 && (e.y < P.y / 2 ? (e.entrance = r.filter((e) => e.south)[0]) : (e.entrance = r.filter((e) => e.north)[0])), (e.walls = []);
            const l = a(this.buildingTextures, Math.random());
            this.makeHorizontalWall(e.walls, l, e.entrance.north, -4, -4, e.width + 8),
                this.makeHorizontalWall(e.walls, l, e.entrance.south, -4, e.height, e.width + 8),
                this.makeVerticalWall(e.walls, l, e.entrance.west, -4, -4, e.height + 8),
                this.makeVerticalWall(e.walls, l, e.entrance.east, e.width, -4, e.height + 8);
            for (let t = 0; t < e.walls.length; t++) e.container.addChild(e.walls[t]);
            (e.container.cacheAsBitmap = !0), u.addChild(e.container);
            for (let t = 0; t < e.walls.length; t++)
                (e.walls[t].collisionX = e.x + e.walls[t].x), (e.walls[t].collisionY = e.y + e.walls[t].y), (e.walls[t].collisionWidth = e.walls[t].width), (e.walls[t].collisionHeight = e.walls[t].height);
        }
        addCorners(e) {
            (e.corners = []),
                e.corners.push({ x: e.x - this.cornerDistance, y: e.y - this.cornerDistance }),
                e.corners.push({ x: e.x + e.width + this.cornerDistance, y: e.y - this.cornerDistance }),
                e.corners.push({ x: e.x - this.cornerDistance, y: e.y + e.height + this.cornerDistance }),
                e.corners.push({ x: e.x + e.width + this.cornerDistance, y: e.y + e.height + this.cornerDistance });
        }
        setGraveyardPosition() {
            this.gameModel.level % 5 != 0 || this.gameModel.isBossStage(this.gameModel.level)
                ? (this.graveYardPosition = { x: P.x / 2 - 50, y: P.y / 2 - 50, width: 100, height: 100 })
                : (this.graveYardPosition = { x: Math.random() * P.x * 0.8 - 50 + 0.1 * P.x, y: (Math.random() > 0.5 ? 0.25 * P.y : 0.75 * P.y) - 50, width: 100, height: 100 }),
                (this.graveYardLocation = { x: this.graveYardPosition.x + 50, y: this.graveYardPosition.y + 50 });
        }
        populatePois() {
            if ((this.setGraveyardPosition(), !this.buildingTextures)) {
                this.buildingTextures = [];
                for (let e = 0; e < 2; e++) this.buildingTextures.push(PIXI.Texture.from("floor" + (e + 1) + ".png"));
                for (let e = 0; e < 2; e++) this.buildingTextures.push(PIXI.Texture.from("wall" + (e + 1) + ".png"));
                (this.roadSprite = new PIXI.TilingSprite(PIXI.Texture.from("road.png"))),
                    (this.roadSprite.texture.baseTexture.mipmap = PIXI.MIPMAP_MODES.OFF),
                    (this.roadSprite.width = P.x),
                    this.roadSprite.tileScale.set(3, 3),
                    (this.roadSprite.height = 96),
                    u.addChild(this.roadSprite),
                    (this.roadSprite.visible = !1),
                    this.roadSprite.anchor.set(0, 0);
            }
            if (this.buildings.length > 0)
                for (let e = 0; e < this.buildings.length; e++)
                    u.removeChild(this.buildings[e].container),
                        this.buildings[e].walls.forEach((t) => {
                            this.discardedWalls.push(t), this.buildings[e].container.removeChild(t);
                        }),
                        this.buildings[e].container.removeChild(this.buildings[e].floorSprite),
                        this.discardedFloorSprites.push(this.buildings[e].floorSprite),
                        this.discardedContainers.push(this.buildings[e].container);
            let e = 1;
            (this.buildingsByPopularity = []), (this.buildings = []);
            let t = this.minBuildings,
                s = this.humans.getMaxHumans();
            const i = Math.max(Math.min(50, Math.round(s / 3)), 10);
            for (
                this.roadSprite.visible = !1,
                this.gameModel.isBossStage(this.gameModel.level)
                    ? ((s = 0), (t = 0))
                    : this.gameModel.level % 5 == 0 && ((this.roadSprite.visible = !0), (this.roadSprite.width = P.x), (this.roadSprite.x = 0), (this.roadSprite.y = P.y / 2 - 48));
                s > 0 || t > 0;

            ) {
                t--;
                const a = Math.round(5 + Math.random() * (i - 5)),
                    r = Math.sqrt(500 * a);
                s -= a;
                let n,
                    o = !1,
                    h = 1e3;
                const l = 10;
                for (; !o && h > 0;)
                    h--,
                        (n =
                            this.gameModel.level % 5 == 0
                                ? Math.random() > 0.7
                                    ? { x: l + Math.random() * (P.x - (2 * l + r)), y: l + Math.random() * (P.y - (2 * l + r)), width: r, height: r }
                                    : { x: l + Math.random() * (P.x - (2 * l + r)), y: Math.random() > 0.5 ? P.y / 2 + this.roadSprite.height / 2 + 8 : P.y / 2 - this.roadSprite.height / 2 - 8 - r, width: r, height: r }
                                : { x: l + Math.random() * (P.x - (2 * l + r)), y: l + Math.random() * (P.y - (2 * l + r)), width: r, height: r }),
                        (o = this.isValidPosition(n));
                if (o) {
                    const t = new j(e++, n.x, n.y, r, r);
                    this.addBuilding(t);
                    const s = Math.max(Math.round(r / 10), 1);
                    for (let e = 0; e < s; e++) this.buildingsByPopularity.push(t);
                    this.buildings.push(t), this.addCorners(t);
                }
            }
            this.populateBuildingMap(), this.populateTrees();
        }
        populateBuildingMap() {
            if (((this.buildingMap = []), (this.mapCols = Math.ceil(P.x / 10)), (this.mapRows = Math.ceil(P.y / 10)), 0 != this.buildings.length))
                for (let e = 0; e < this.mapRows; e++) {
                    const t = 10 * e;
                    for (let i = 0; i < this.mapCols; i++) {
                        const a = 10 * i;
                        let r,
                            n = 1e4;
                        for (let e = 0; e < this.buildings.length; e++) {
                            const i = this.buildings[e],
                                o = s(a, t, i.x + i.width / 2, i.y + i.height / 2) - i.width / 2;
                            o < n && ((n = o), (r = i));
                        }
                        this.buildingMap[e * this.mapCols + i] = r;
                    }
                }
        }
        getBuildingFromMap(e, t) {
            return this.buildingMap[Math.round(t / 10) * this.mapCols + Math.round(e / 10)];
        }
        randomPositionInBuilding(e) {
            if (!e) {
                const e = Math.random() > 0.5 ? -1 : 1,
                    t = Math.random() > 0.5 ? -1 : 1,
                    s = P.x / 4,
                    i = P.y / 4;
                return Math.random() > 0.5 ? { x: Math.random() * P.x, y: P.y / 2 + t * i + Math.random() * t * i } : { x: P.x / 2 + e * s + Math.random() * e * s, y: Math.random() * P.y };
            }
            return { x: e.x + 5 + Math.random() * (e.width - 10), y: e.y + 5 + Math.random() * (e.height - 10) };
        }
        isInsidePoi(e, t, s, i = 0) {
            return e > s.x - i && e < s.x + s.width + i && t > s.y - i && t < s.y + s.height + i;
        }
        checkWall(e, t, s, i) {
            t.y > e.collisionY &&
                t.y < e.collisionY + e.collisionHeight &&
                (t.x < e.collisionX - this.wallCollisionBuffer && s.x > e.collisionX - this.wallCollisionBuffer && ((i.x = !0), (i.validX = e.collisionX - this.wallCollisionBuffer - 1)),
                    t.x > e.collisionX + e.collisionWidth + this.wallCollisionBuffer &&
                    s.x < e.collisionX + e.collisionWidth + this.wallCollisionBuffer &&
                    ((i.x = !0), (i.validX = e.collisionX + e.collisionWidth + this.wallCollisionBuffer + 1))),
                t.x > e.collisionX &&
                t.x < e.collisionX + e.collisionWidth &&
                (t.y < e.collisionY - this.wallCollisionBuffer && s.y > e.collisionY - this.wallCollisionBuffer && ((i.y = !0), (i.validY = e.collisionY - this.wallCollisionBuffer - 1)),
                    t.y > e.collisionY + e.collisionHeight + this.wallCollisionBuffer &&
                    s.y < e.collisionY + e.collisionHeight + this.wallCollisionBuffer &&
                    ((i.y = !0), (i.validY = e.collisionY + e.collisionHeight + this.wallCollisionBuffer + 1)));
        }
        checkGraveyard(e, t) {
            const s = new te();
            return this.graveyardCollision && this.checkWall(this.graveyardCollision, e, t, s), s.x || s.y ? s : null;
        }
        checkCollisions(e, t) {
            const s = this.findBuilding(e);
            if (!s) return this.checkGraveyard(e, t);
            const i = new te();
            for (let a = 0; a < s.walls.length; a++) this.checkWall(s.walls[a], e, t, i);
            return i;
        }
        pathStepCalc(e, t) {
            const s = t.x - e.x,
                i = t.y - e.y,
                a = Math.abs(s),
                r = Math.abs(i);
            if (0 == Math.max(a, r)) return;
            let n = 1 / Math.max(a, r);
            return (n *= 1.29289 - (a + r) * n * 0.29289), { x: s * n * this.pathFindStepSize, y: i * n * this.pathFindStepSize };
        }
        findBuilding(e) {
            return this.getBuildingFromMap(e.x, e.y);
        }
        normalizeVector(e) {
            if (0 == e.x && 0 == e.y) return e;
            const t = Math.sqrt(e.x * e.x + e.y * e.y);
            return (e.x /= t), (e.y /= t), e;
        }
        modifyVectorForCollision(e, t, s) {
            if (!t && !this.graveyardCollision) return this.normalizeVector(e);
            const i = new te(),
                a = { x: s.x + (e.x > 0 ? 1 : -1), y: s.y + (e.y > 0 ? 1 : -1) };
            if (t) for (let e = 0; e < t.walls.length; e++) this.checkWall(t.walls[e], s, a, i);
            return this.graveyardCollision && this.checkWall(this.graveyardCollision, s, a, i), i.x && (e.x = 0), i.y && (e.y = 0), this.normalizeVector(e);
        }
        willVectorHitBuilding(e, t, s, i) {
            if (((this.dx = t.x - e.x), (this.dy = t.y - e.y), this.dx < 0 && e.x < s.x - 4)) return !1;
            if (this.dx > 0 && e.x > s.x + s.width + 4) return !1;
            if (this.dy < 0 && e.y < s.y - 4) return !1;
            if (this.dy > 0 && e.y > s.y + s.width + 4) return !1;
            for (this.step = this.pathStepCalc(e, t), this.stepsToTake = Math.min(i / this.pathFindStepSize - this.pathFindStepSize, 30), this.hasHit = !1, this.testPosition = { x: e.x, y: e.y }; !this.hasHit && this.stepsToTake > 0;)
                this.stepsToTake--, (this.testPosition.x += this.step.x), (this.testPosition.y += this.step.y), this.isInsidePoi(this.testPosition.x, this.testPosition.y, s, 4) && (this.hasHit = !0);
            return this.hasHit;
        }
        findNearestCorner(e, t) {
            let s = null,
                i = 1e4;
            for (let a = 0; a < t.length; a++) {
                const r = this.fastDistance(e.x, e.y, t[a].x, t[a].y);
                r < i && ((i = r), (s = t[a]));
            }
            return s;
        }
        findAdjacentCorners(e, t) {
            const s = [];
            for (let i = 0; i < t.corners.length; i++) (t.corners[i].x != e.x && t.corners[i].y != e.y) || s.push(t.corners[i]);
            return s;
        }
        navigateAroundBuilding(e, t, s, i) {
            return (
                (this.vector = { x: t.x - e.x, y: t.y - e.y, distance: i }),
                s
                    ? ((this.hitbuilding = this.willVectorHitBuilding(e, t, s, i)),
                        this.hitbuilding
                            ? ((this.corner = this.findNearestCorner(t, s.corners)),
                                (this.hitbuilding = this.willVectorHitBuilding(e, this.corner, s, i)),
                                this.hitbuilding
                                    ? ((this.corner = this.findNearestCorner(e, this.findAdjacentCorners(this.corner, s))),
                                        (this.vector.x = this.corner.x - e.x),
                                        (this.vector.y = this.corner.y - e.y),
                                        this.modifyVectorForCollision(this.vector, s, e))
                                    : ((this.vector.x = this.corner.x - e.x), (this.vector.y = this.corner.y - e.y), this.modifyVectorForCollision(this.vector, s, e)))
                            : this.modifyVectorForCollision(this.vector, s, e))
                    : this.normalizeVector(this.vector)
            );
        }
        howDoIGetToMyTarget(e, t) {
            if (
                ((this.distanceToTarget = this.fastDistance(e.x, e.y, t.x, t.y)),
                    (this.closeBuilding = this.findBuilding(e)),
                    (this.insideBuilding = !1),
                    this.closeBuilding && ((this.insideBuilding = this.isInsidePoi(e.x, e.y, this.closeBuilding, 0)), this.insideBuilding))
            )
                return this.isInsidePoi(t.x, t.y, this.closeBuilding, 0)
                    ? this.modifyVectorForCollision({ x: t.x - e.x, y: t.y - e.y }, this.closeBuilding, e)
                    : this.modifyVectorForCollision({ x: this.closeBuilding.entrance.outside.x - e.x, y: this.closeBuilding.entrance.outside.y - e.y }, this.closeBuilding, e);
            const s = this.findBuilding(t);
            return s && ((this.insideBuilding = this.isInsidePoi(t.x, t.y, s, 0)), this.insideBuilding)
                ? this.fastDistance(e.x, e.y, s.entrance.outside.x, s.entrance.outside.y) < 30
                    ? this.modifyVectorForCollision({ x: s.entrance.inside.x - e.x, y: s.entrance.inside.y - e.y }, this.closeBuilding, e)
                    : this.navigateAroundBuilding(e, s.entrance.outside, this.closeBuilding, this.distanceToTarget)
                : this.distanceToTarget < 20
                    ? this.modifyVectorForCollision({ x: t.x - e.x, y: t.y - e.y }, this.closeBuilding, e)
                    : this.navigateAroundBuilding(e, t, this.closeBuilding, this.distanceToTarget);
        }
        isValidTreePosition(e) {
            if (!this.isValidPosition(e)) return !1;
            for (let t = 0; t < this.treeSprites.length; t++) if (this.fastDistance(e.x, e.y, this.treeSprites[t].x, this.treeSprites[t].y) < 25) return !1;
            return !0;
        }
        populateTrees() {
            if (this.treeSprites.length > 0) for (let e = 0; e < this.treeSprites.length; e++) this.treeSprites[e].visible = !1;
            if (0 == this.treeTextures.length) {
                for (let e = 0; e < 6; e++) this.treeTextures.push(PIXI.Texture.from("tree" + e + ".png"));
                this.armyTextures.push(PIXI.Texture.from("hedgehog.png")), this.armyTextures.push(PIXI.Texture.from("sandbags.png"));
            }
            let e = Math.round(P.x / 50);
            this.gameModel.isBossStage(this.gameModel.level) && (e = Math.round(1.5 * e));
            let t = 0;
            for (; e > 0;) {
                let s,
                    i = !1,
                    r = 1e3;
                const n = 8,
                    o = 2;
                for (; !i && r > 0;) r--, (s = { x: n + Math.random() * (P.x - 2 * n), y: n + Math.random() * (P.y - 2 * n), width: o, height: o }), (i = this.isValidTreePosition(s));
                if (i) {
                    let e = 0.4 + 0.6 * Math.random();
                    this.gameModel.constructions.graveyard && (e = Math.min((this.fastDistance(s.x, s.y, this.graveYardLocation.x, this.graveYardLocation.y) - 90) / 400, 1));
                    let i,
                        r = this.treeTextures[this.treeTextures.length - 1 - Math.round((this.treeTextures.length - 1) * e)];
                    this.gameModel.isBossStage(this.gameModel.level) && Math.random() > 0.7 && (r = a(this.armyTextures, Math.random())),
                        this.treeSprites.length > t ? ((i = this.treeSprites[t]), (i.texture = r), (i.visible = !0)) : ((i = new PIXI.Sprite(r)), this.treeSprites.push(i), g.addChild(i)),
                        t++,
                        i.anchor.set(0.5, 1),
                        (i.x = s.x),
                        (i.y = s.y),
                        (i.zIndex = i.y),
                        (i.scale.x = i.scale.y = 2),
                        (i.scale.x = Math.random() > 0.5 ? i.scale.x : -1 * i.scale.x);
                }
                e--;
            }
        }
    }
    class te {
        constructor() {
            (this.x = !1), (this.y = !1), (this.validX = 0), (this.validY = 0);
        }
    }
    class se {
        constructor() {
            if (
                ((this.storm = !1),
                    (this.gameModel = ne.getInstance()),
                    (this.costs = { blood: "blood", parts: "parts" }),
                    (this.generatorsApplied = []),
                    (this.generators = [
                        new ie(1, "Simple Machine", this.costs.blood, 1e6, 1.08, 1, 2, "A simple device that produces 1 part every 2 seconds"),
                        new ie(2, "Part Duplicator", this.costs.parts, 100, 1.09, 4, 3, "A more advanced device that produces 4 parts every 3 seconds"),
                        new ie(3, "Stamp Press", this.costs.parts, 1e3, 1.1, 16, 5, "An industrial press that produces 16 parts every 5 seconds"),
                        new ie(4, "Conveyor", this.costs.parts, 1e4, 1.11, 64, 8, "A fantastic new invention that produces 64 parts every 8 seconds"),
                        new ie(5, "Splitter Combiner", this.costs.parts, 1e5, 1.12, 192, 10, "A wondrous machine that produces 192 parts every 10 seconds"),
                        new ie(6, "Batch Converter", this.costs.parts, 5e5, 1.13, 512, 12, "An astounding contraption that produces 512 parts every 12 seconds"),
                    ]),
                    se.instance)
            )
                return se.instance;
            se.instance = this;
        }
        factoryStats() {
            let e = 0,
                t = 0;
            for (let s = 0; s < this.generatorsApplied.length; s++) (e += this.generatorsApplied[s].rank), (t += this.generatorsApplied[s].total / this.generatorsApplied[s].time);
            return { machines: e, partsPerSec: (this.storm ? 2 : 1) * t * this.gameModel.partsPCMod };
        }
        update(e) {
            for (let t = 0; t < this.generatorsApplied.length; t++)
                (this.generatorsApplied[t].timeLeft -= e),
                    this.generatorsApplied[t].timeLeft <= 0 &&
                    ((this.generatorsApplied[t].timeLeft = this.generatorsApplied[t].time), (this.gameModel.persistentData.parts += this.generatorsApplied[t].total * this.gameModel.partsPCMod * (this.storm ? 2 : 1)));
        }
        updateLongTime(e) {
            let t = 0;
            for (let s = 0; s < this.generatorsApplied.length; s++) t += this.generatorsApplied[s].total * (e / this.generatorsApplied[s].time);
            return t * this.gameModel.partsPCMod;
        }
        currentRank(e) {
            for (let t = 0; t < this.gameModel.persistentData.generators.length; t++) {
                const s = this.gameModel.persistentData.generators[t];
                if (e.id == s.id) return s.rank;
            }
            return 0;
        }
        purchasePrice(e) {
            return Math.round(e.basePrice * Math.pow(e.multi, this.currentRank(e)));
        }
        upgradeMaxAffordable(e) {
            const t = this.currentRank(e);
            let s = 0;
            switch (e.costType) {
                case this.costs.blood:
                    s = h(e.basePrice, e.multi, t, this.gameModel.persistentData.blood);
                    break;
                case this.costs.parts:
                    s = h(e.basePrice, e.multi, t, this.gameModel.persistentData.parts);
            }
            return 0 != e.cap ? Math.min(s, e.cap - t) : s;
        }
        upgradeMaxPrice(e, t) {
            return l(e.basePrice, e.multi, this.currentRank(e), t);
        }
        canAffordGenerator(e) {
            switch (e.costType) {
                case this.costs.blood:
                    return this.gameModel.persistentData.blood >= this.purchasePrice(e);
                case this.costs.parts:
                    return this.gameModel.persistentData.parts >= this.purchasePrice(e);
            }
            return !1;
        }
        purchaseMaxGenerators(e) {
            const t = this.upgradeMaxAffordable(e);
            for (let s = 0; s < t; s++) this.purchaseGenerator(e, !1);
            this.gameModel.saveData();
        }
        purchaseGenerator(e, t = !0) {
            if (this.canAffordGenerator(e)) {
                switch (e.costType) {
                    case this.costs.blood:
                        this.gameModel.persistentData.blood -= this.purchasePrice(e);
                        break;
                    case this.costs.parts:
                        this.gameModel.persistentData.parts -= this.purchasePrice(e);
                }
                let s;
                for (let t = 0; t < this.gameModel.persistentData.generators.length; t++) e.id == this.gameModel.persistentData.generators[t].id && ((s = this.gameModel.persistentData.generators[t]), s.rank++);
                s || this.gameModel.persistentData.generators.push({ id: e.id, rank: 1 }), t && this.gameModel.saveData(), this.applyGenerators();
            }
        }
        applyGenerator(e, t) {
            let s = !1;
            for (let i = 0; i < this.generatorsApplied.length; i++)
                this.generatorsApplied[i].id == e.id && ((s = !0), (this.generatorsApplied[i].rank = t), (this.generatorsApplied[i].total = this.generatorsApplied[i].produces * this.generatorsApplied[i].rank));
            s || this.generatorsApplied.push({ id: e.id, produces: e.produces, total: e.produces * t, rank: t, time: e.time, timeLeft: e.time });
        }
        applyGenerators() {
            for (let e = 0; e < this.generators.length; e++) {
                const t = this.currentRank(this.generators[e]);
                t > 0 && this.applyGenerator(this.generators[e], t);
            }
        }
    }
    class ie {
        constructor(e, t, s, i, a, r, n, o) {
            (this.id = e), (this.name = t), (this.costType = s), (this.basePrice = i), (this.multi = a), (this.produces = r), (this.time = n), (this.description = o), (this.cap = 0);
        }
    }
    class CreatureFactory {
        constructor() {
            if (
                ((this.gameModel = ne.getInstance()),
                    (this.spawnedSavedCreatures = !1),
                    (this.types = { earthGolem: 1, airGolem: 2, fireGolem: 3, waterGolem: 4 }),
                    (this.creatures = [
                        new re(1, this.types.earthGolem, "Earth Golem", 3e3, 75, 30, 800, "A golem born from rocks and mud, able to take a lot of punishment and taunt enemies to attack it"),
                        new re(2, this.types.airGolem, "Air Golem", 1200, 110, 45, 900, "A fast moving golem able to cover large distances and chase targets down"),
                        new re(3, this.types.fireGolem, "Fire Golem", 1200, 130, 32, 1e3, "A fireball spewing golem that ignites everything it touches"),
                        new re(4, this.types.waterGolem, "Water Golem", 1500, 90, 30, 1100, "A calming golem that restores health to nearby units"),
                    ]),
                    (this.creatureScaling = 1.75),
                    (this.creatureCostScaling = 2),
                    (this.creatureCostReduction = 1),
                    CreatureFactory.instance)
            )
                return CreatureFactory.instance;
            CreatureFactory.instance = this;
        }
        update(e) {
            const t = new Ue().creatureCount;
            for (let s = 0; s < this.creatures.length; s++)
                this.creatures[s].building
                    ? ((this.creatures[s].timeLeft -= e), this.creatures[s].timeLeft < 0 && (this.spawnCreature(this.creatures[s]), (this.creatures[s].building = !1)))
                    : void 0 !== t[this.creatures[s].type] && t[this.creatures[s].type] < this.creatures[s].autobuild && this.startBuilding(this.creatures[s]),
                    this.gameModel.persistentData.creatureLevels[this.creatures[s].id] && (this.creatures[s].level = this.gameModel.persistentData.creatureLevels[this.creatures[s].id]);
        }
        refundParts(e, t) {
            this.gameModel.persistentData.parts += e.price * t;
        }
        purchasePrice(e) {
            return e.baseCost * Math.pow(this.creatureCostScaling, e.level - 1) * this.creatureCostReduction;
        }
        levelPrice(e) {
            return e.baseCost * Math.pow(this.creatureCostScaling, e.level) * 5 * this.creatureCostReduction;
        }
        levelCreature(e) {
            this.levelPrice(e) < this.gameModel.persistentData.parts && ((this.gameModel.persistentData.parts -= this.levelPrice(e)), e.level++, (this.gameModel.persistentData.creatureLevels[e.id] = e.level));
        }
        canAffordCreature(e) {
            return this.purchasePrice(e) < this.gameModel.persistentData.parts;
        }
        creaturesBuildingCount() {
            let e = 0;
            for (let t = 0; t < this.creatures.length; t++) this.creatures[t].building && e++;
            return e;
        }
        startBuilding(e) {
            e.building ||
                (this.canAffordCreature(e) &&
                    (this.creaturesBuildingCount() + this.gameModel.creatureCount >= this.gameModel.creatureLimit || ((e.building = !0), (e.timeLeft = e.time), (this.gameModel.persistentData.parts -= this.purchasePrice(e)))));
        }
        creatureAutoBuildNumber(e, t) {
            e.autobuild + t >= 0 && ((e.autobuild += t), (this.gameModel.persistentData.creatureAutobuild[e.id] = e.autobuild));
        }
        updateAutoBuild() {
            for (let e = 0; e < this.creatures.length; e++) this.creatures[e].autobuild = this.gameModel.persistentData.creatureAutobuild[this.creatures[e].id] || 0;
        }
        resetLevels() {
            for (let e = 0; e < this.creatures.length; e++) this.creatures[e].level = 1;
        }
        spawnCreature(e) {
            const t = new Ue(),
                s = e.baseHealth * Math.pow(this.creatureScaling, e.level - 1) * this.gameModel.golemHealthPCMod,
                i = e.baseDamage * Math.pow(this.creatureScaling, e.level - 1) * this.gameModel.golemDamagePCMod;
            t.spawnCreature(s, i, e.speed, e.type, e.level, this.purchasePrice(e));
        }
        spawnSavedCreatures() {
            if (!this.spawnedSavedCreatures) {
                let e = 0;
                for (let t = 0; t < this.gameModel.persistentData.savedCreatures.length; t++)
                    if ((e++, e <= this.gameModel.creatureLimit)) {
                        const e = this.gameModel.persistentData.savedCreatures[t],
                            s = this.creatures.filter((t) => t.type == e.t)[0];
                        (s.level = e.l), this.spawnCreature(s);
                    }
                this.spawnedSavedCreatures = !0;
            }
        }
        creatureStats(e) {
            return {
                thisLevel: {
                    level: e.level,
                    health: e.baseHealth * Math.pow(this.creatureScaling, e.level - 1) * this.gameModel.golemHealthPCMod,
                    damage: e.baseDamage * Math.pow(this.creatureScaling, e.level - 1) * this.gameModel.golemDamagePCMod,
                    cost: e.baseCost * Math.pow(this.creatureCostScaling, e.level - 1),
                },
                nextLevel: {
                    level: e.level + 1,
                    health: e.baseHealth * Math.pow(this.creatureScaling, e.level) * this.gameModel.golemHealthPCMod,
                    damage: e.baseDamage * Math.pow(this.creatureScaling, e.level) * this.gameModel.golemDamagePCMod,
                    cost: e.baseCost * Math.pow(this.creatureCostScaling, e.level),
                },
            };
        }
    }
    class re {
        constructor(e, t, s, i, a, r, n, o) {
            (this.id = e),
                (this.type = t),
                (this.name = s),
                (this.baseHealth = i),
                (this.baseDamage = a),
                (this.speed = r),
                (this.baseCost = n),
                (this.description = o),
                (this.time = 3),
                (this.building = !1),
                (this.timeLeft = 10),
                (this.autobuild = 0),
                (this.level = 1);
        }
    }
    class ne {
        constructor() {
            (this.storageName = "ZombieData"),
                (this.kongregate = null),
                (this.playFabId = null),
                (this.titleId = "772D8"),
                (this.hidden = !1),
                (this.autoShatter = !1),
                (this.energy = 0),
                (this.energyMax = 10),
                (this.energyRate = 1),
                (this.brainsRate = 0),
                (this.bonesRate = 0),
                (this.endLevelBones = 0),
                (this.energySpellMultiplier = 1),
                (this.prestigePointsEarned = 0),
                (this.zombieCost = 10),
                (this.bonesPCMod = 1),
                (this.partsPCMod = 1),
                (this.bloodMax = 1e3),
                (this.bloodPCMod = 1),
                (this.bloodStorePCMod = 1),
                (this.brainsMax = 50),
                (this.brainsPCMod = 1),
                (this.brainsStorePCMod = 1),
                (this.zombieHealth = 100),
                (this.zombieHealthPCMod = 1),
                (this.zombieDamage = 10),
                (this.zombieDamagePCMod = 1),
                (this.zombieSpeed = 10),
                (this.zombieCages = 0),
                (this.zombiesInCages = 0),
                (this.golemDamagePCMod = 1),
                (this.golemHealthPCMod = 1),
                (this.plagueDamageMod = 0),
                (this.plagueticks = 2),
                (this.graveyardHealthMod = 1),
                (this.burningSpeedMod = 1),
                (this.startingResources = 0),
                (this.blastHealing = 0),
                (this.plagueDmgReduction = 0),
                (this.brainRecoverChance = 0),
                (this.riseFromTheDeadChance = 0),
                (this.infectedBiteChance = 0),
                (this.infectedBlastChance = 0),
                (this.spitDistance = 0),
                (this.spikeDelay = 5),
                (this.startTimer = 0),
                (this.fenceRadius = 50),
                (this.constructions = {}),
                (this.construction = 0),
                (this.boneCollectorCapacity = 10),
                (this.frameRate = 0),
                (this.humanCount = 50),
                (this.zombieCount = 0),
                (this.creatureCount = 0),
                (this.creatureLimit = 1),
                (this.harpySpeed = 75),
                (this.tankBuster = !1),
                (this.harpyBombs = 1),
                (this.stats = null),
                (this.runicSyphon = { percentage: 0, blood: 0, bones: 0, brains: 0 }),
                (this.gigazombies = !1),
                (this.endLevelTimer = 3),
                (this.endLevelDelay = 3),
                (this.messageQueue = []),
                (this.offlineMessage = ""),
                (this.runeEffects = { attackSpeed: 1, critChance: 0, critDamage: 0, damageReduction: 1, healthRegen: 0, damageReflection: 0 }),
                (this.encodedContent = ""),
                (this.savefilename = ""),
                (this.autoUpgrades = !1),
                (this.autoconstruction = !1),
                (this.autoconstructionUnlocked = !1),
                (this.levelResourcesAdded = !1),
                (this.bulletproofChance = 0),
                (this.gameSpeed = 1),
                (this.level = 1),
                (this.currentState = "startGame"),
                (this.states = { playingLevel: "playingLevel", levelCompleted: "levelCompleted", startGame: "startGame", prestiged: "prestiged", failed: "failed" }),
                (this.baseStats = {
                    energyRate: 1,
                    brainsRate: 0,
                    bonesRate: 0,
                    energyMax: 10,
                    bloodMax: 1e3,
                    brainsMax: 50,
                    zombieCost: 10,
                    zombieHealth: 100,
                    zombieDamage: 10,
                    zombieSpeed: 10,
                    level: 1,
                    graveyard: 0,
                    construction: 0,
                    boneCollectorCapacity: 10,
                }),
                (this.zoom = A),
                (this.centerGameContainer = Z),
                (this.lastSave = 0),
                (this.lastPlayFabSave = Date.now() - 15e3),
                (this.persistentData = {
                    saveCreated: Date.now(),
                    dateOfSave: Date.now(),
                    autoStart: !1,
                    levelUnlocked: 1,
                    allTimeHighestLevel: 0,
                    blood: 0,
                    brains: 0,
                    bones: 0,
                    parts: 0,
                    bonesTotal: 0,
                    upgrades: [],
                    constructions: [],
                    prestigePointsEarned: 0,
                    prestigePointsToSpend: 0,
                    boneCollectors: 0,
                    graveyardZombies: 1,
                    harpies: 0,
                    resolution: 1,
                    zoomButtons: !1,
                    particles: !0,
                    generators: [],
                    currentConstruction: null,
                    creatureLevels: [],
                    creatures: [],
                    creatureAutobuild: [],
                    savedCreatures: [],
                    levelsCompleted: [],
                    showfps: !1,
                    runeshatter: 0,
                    runes: { life: { blood: 0, brains: 0, bones: 0 }, death: { blood: 0, brains: 0, bones: 0 } },
                    trophies: [],
                    vipEscaped: [],
                    autoRelease: !1,
                    skeleton: null,
                    skeletonTalents: [],
                });
        }
        static getInstance() {
            return (
                ne.instance ||
                ((ne.instance = new ne()),
                    (ne.instance.particles = new Qe()),
                    (ne.instance.trophies = new de()),
                    (ne.instance.bones = new tt()),
                    (ne.instance.creatureFactory = new CreatureFactory()),
                    (ne.instance.creatures = new Ue()),
                    (ne.instance.boneCollectors = new Ve()),
                    (ne.instance.graveyard = new Oe()),
                    (ne.instance.spells = new SpellManager()),
                    (ne.instance.partFactory = new se()),
                    (ne.instance.skeleton = new Xe()),
                    (ne.instance.upgrades = new oe()),
                    (ne.instance.zombies = new ZombieManager()),
                    (ne.instance.humans = new HumanManager()),
                    (ne.instance.police = new PoliceManager()),
                    (ne.instance.army = new Te())),
                ne.instance
            );
        }
        resetToBaseStats() {
            (this.energyRate = this.baseStats.energyRate),
                (this.brainsRate = this.baseStats.brainsRate),
                (this.bonesRate = this.baseStats.bonesRate),
                (this.energyMax = this.baseStats.energyMax),
                (this.bloodMax = this.baseStats.bloodMax),
                (this.brainsMax = this.baseStats.brainsMax),
                (this.zombieHealth = this.baseStats.zombieHealth),
                (this.zombieDamage = this.baseStats.zombieDamage),
                (this.zombieSpeed = this.baseStats.zombieSpeed),
                (this.zombieCost = this.baseStats.zombieCost),
                (this.zombieCages = 0),
                (this.brainRecoverChance = 0),
                (this.riseFromTheDeadChance = 0),
                (this.infectedBiteChance = 0),
                (this.infectedBlastChance = 0),
                (this.construction = this.baseStats.construction),
                (this.constructions = {}),
                (this.boneCollectorCapacity = this.baseStats.boneCollectorCapacity),
                (this.bonesPCMod = 1),
                (this.partsPCMod = 1),
                (this.bloodPCMod = 1),
                (this.bloodStorePCMod = 1),
                (this.brainsPCMod = 1),
                (this.brainsStorePCMod = 1),
                (this.zombieHealthPCMod = 1),
                (this.zombieDamagePCMod = 1),
                (this.golemHealthPCMod = 1),
                (this.golemDamagePCMod = 1),
                (this.plagueDamageMod = 0),
                (this.plagueticks = 2),
                (this.burningSpeedMod = 1),
                (this.startingResources = 0),
                (this.fenceRadius = 50),
                (this.spitDistance = 0),
                (this.spikeDelay = 5),
                (this.blastHealing = 0),
                (this.plagueDmgReduction = 1),
                (this.creatureLimit = 1),
                (this.runicSyphon.percentage = 0),
                (this.autoconstructionUnlocked = !1),
                (this.autoUpgrades = !1),
                (this.graveyardHealthMod = 1),
                (this.bulletproofChance = 0),
                (this.gigazombies = !1),
                (this.harpySpeed = 75),
                (this.tankBuster = !1),
                (this.harpyBombs = 1);
        }
        addEnergy(e) {
            (this.energy += e), this.energy > this.energyMax && (this.energy = this.energyMax);
        }
        addBlood(e) {
            isNaN(this.persistentData.blood) && (this.persistentData.blood = 0),
                isNaN(e) ||
                ((this.persistentData.blood += e * this.bloodPCMod),
                    this.persistentData.blood > this.bloodMax && ((this.persistentData.blood = this.bloodMax), this.constructions.runesmith && this.runicSyphon.percentage > 0 && (this.runicSyphon.blood += e * this.bloodPCMod)),
                    this.runicSyphon.percentage > 0 && (this.runicSyphon.blood += e * this.bloodPCMod * this.runicSyphon.percentage));
        }
        addBrains(e) {
            isNaN(this.persistentData.brains) && (this.persistentData.brains = 0),
                isNaN(e) ||
                ((this.persistentData.brains += e * this.brainsPCMod),
                    this.persistentData.brains > this.brainsMax && ((this.persistentData.brains = this.brainsMax), this.constructions.runesmith && this.runicSyphon.percentage > 0 && (this.runicSyphon.brains += e * this.brainsPCMod)),
                    this.runicSyphon.percentage > 0 && (this.runicSyphon.brains += e * this.brainsPCMod * this.runicSyphon.percentage));
        }
        addBones(e) {
            isNaN(this.persistentData.bones) && (this.persistentData.bones = 0),
                isNaN(e) ||
                ((this.persistentData.bones += e * this.bonesPCMod),
                    (this.persistentData.bonesTotal += e * this.bonesPCMod),
                    this.runicSyphon.percentage > 0 && (this.runicSyphon.bones += e * this.bonesPCMod * this.runicSyphon.percentage));
        }
        getHumanCount() {
            return this.humanCount;
        }
        getEnergyRate() {
            return this.energySpellMultiplier * this.energyRate - (this.persistentData.boneCollectors + this.persistentData.harpies);
        }
        update(e, t) {
            this.spells.updateSpells(e),
                (e *= this.gameSpeed),
                this.hidden && U(e, this.app),
                this.partFactory.update(e),
                this.autoRemoveCollectorsHarpies(),
                this.addEnergy(this.getEnergyRate() * e),
                this.currentState == this.states.playingLevel &&
                (this.addBones(this.bonesRate * e),
                    this.addBrains(this.brainsRate * e),
                    this.upgrades.updateRunicSyphon(this.runicSyphon),
                    this.lastSave + 3e4 < t && (this.saveData(), (this.lastSave = t)),
                    this.lastPlayFabSave + 12e5 < t && this.saveToPlayFab(),
                    this.getHumanCount() <= 0 &&
                    (this.endLevelTimer < 0
                        ? (this.isBossStage(this.level) && this.trophies.doesLevelHaveTrophy(this.level) && this.trophies.trophyAquired(this.level),
                            (this.prestigePointsEarned = this.prestigePointsForLevel(this.level)),
                            (this.currentState = this.states.levelCompleted),
                            (this.levelResourcesAdded = !1),
                            this.calculateEndLevelBones(),
                            this.calculateEndLevelZombieCages(),
                            this.persistentData.levelsCompleted.includes(this.level) || (this.addPrestigePoints(this.prestigePointsForLevel(this.level)), this.persistentData.levelsCompleted.push(this.level)),
                            (this.persistentData.levelUnlocked = this.level + 1),
                            (!this.persistentData.allTimeHighestLevel || this.level > this.persistentData.allTimeHighestLevel) &&
                            ((this.persistentData.allTimeHighestLevel = this.level), window.kongregate && window.kongregate.stats.submit("level", this.persistentData.allTimeHighestLevel)),
                            (this.startTimer = 2))
                        : (this.endLevelTimer -= e)),
                    this.upgrades.updateConstruction(e),
                    this.upgrades.updateAutoUpgrades(),
                    this.creatureFactory.update(e)),
                this.currentState == this.states.levelCompleted && ((this.startTimer -= e), this.startTimer < 0 && this.persistentData.autoStart && this.nextLevel()),
                this.currentState == this.states.failed && ((this.startTimer -= e), this.startTimer < 0 && this.persistentData.autoStart && this.startLevel(this.level - 1)),
                this.updateStats();
        }
        calculateEndLevelBones() {
            (this.endLevelBones = 0), this.persistentData.boneCollectors > 0 && this.bones.uncollected && ((this.endLevelBones = this.bones.uncollected.map((e) => e.value).reduce((e, t) => e + t, 0)), this.addBones(this.endLevelBones));
        }
        calculateEndLevelZombieCages() {
            this.zombieCages > 0 && ((this.zombiesInCages += this.zombieCount), this.zombiesInCages > this.zombieCages && (this.zombiesInCages = this.zombieCages));
        }
        autoRemoveCollectorsHarpies() {
            if (this.getEnergyRate() < 0) {
                const e = this.getEnergyRate();
                this.persistentData.harpies > 0 && ((this.persistentData.harpies -= Math.ceil(Math.abs(e))), this.persistentData.harpies < 0 && (this.persistentData.harpies = 0)),
                    this.getEnergyRate() < 0 && this.persistentData.boneCollectors > 0 && this.persistentData.boneCollectors--;
            }
        }
        releaseCagedZombies() {
            if (this.currentState == this.states.playingLevel) {
                for (let e = 0; e < this.zombiesInCages; e++) this.zombies.createZombie(this.graveyard.sprite.x, this.graveyard.sprite.y);
                this.zombiesInCages = 0;
            }
        }
        sacrificeCagedZombies() {
            this.addBlood(this.cagedZombieSacrificeValue().blood), this.addBrains(this.cagedZombieSacrificeValue().brains), this.addBones(this.cagedZombieSacrificeValue().bones), (this.zombiesInCages = 0);
        }
        cagedZombieSacrificeValue() {
            return { blood: this.zombiesInCages * this.zombieHealth * 0.5, brains: this.zombiesInCages, bones: 3 * this.zombiesInCages };
        }
        startLevel(e) {
            (this.level = e), this.startGame();
        }
        startGame() {
            (this.currentState = this.states.playingLevel), this.setupLevel(), this.updatePlayingLevel();
        }
        nextLevel() {
            this.level++, (this.currentState = this.states.playingLevel), this.setupLevel(), this.updatePlayingLevel(), this.persistentData.autoRelease && this.releaseCagedZombies();
        }
        setupLevel() {
            (this.endLevelTimer = this.endLevelDelay),
                N(),
                this.particles.initialize(),
                this.humans.populate(),
                this.zombies.populate(),
                this.graveyard.initialize(),
                setTimeout(Z, 10),
                this.upgrades.applyUpgrades(),
                this.upgrades.updateRuneEffects(),
                this.partFactory.applyGenerators(),
                this.creatures.populate(),
                this.skeleton.populate(),
                this.addStartLevelResources(),
                this.populateStats();
        }
        populateStats() {
            this.stats = {
                skeleton: { show: this.skeleton.persistent.skeletons > 0, health: 10 * this.zombieHealth, damage: 10 * this.zombieDamage, speed: this.skeleton.moveSpeed },
                zombie: { health: this.zombieHealth, damage: this.zombieDamage, speed: this.zombieSpeed },
                human: { health: this.humans.getMaxHealth(this.level), damage: this.humans.attackDamage, speed: this.humans.maxRunSpeed },
                police: { show: this.police.getMaxPolice() > 0, health: this.police.getMaxHealth(), damage: this.police.attackDamage, speed: this.police.maxRunSpeed },
                army: { show: this.army.getMaxArmy() > 0, health: this.army.getMaxHealth(), damage: this.army.attackDamage, speed: this.army.maxRunSpeed },
            };
        }
        updateStats() {
            this.stats &&
                ((this.stats.zombie.health = this.zombieHealth),
                    (this.stats.zombie.damage = this.zombieDamage),
                    (this.stats.zombie.speed = this.zombieSpeed),
                    (this.stats.zombie.count = this.zombieCount),
                    (this.stats.skeleton.health = 10 * this.zombieHealth),
                    (this.stats.skeleton.damage = 10 * this.zombieDamage),
                    (this.stats.skeleton.speed = this.skeleton.moveSpeed));
        }
        vipEscaped() {
            this.persistentData.vipEscaped || (this.persistentData.vipEscaped = []), this.persistentData.vipEscaped.push(this.level), this.saveData();
        }
        updatePlayingLevel() {
            this.saveData();
        }
        addStartLevelResources() {
            (this.energy = this.energyMax),
                this.levelResourcesAdded ||
                ((this.persistentData.blood += 500 * this.startingResources),
                    this.persistentData.blood > this.bloodMax && (this.persistentData.blood = this.bloodMax),
                    (this.persistentData.brains += 50 * this.startingResources),
                    this.persistentData.brains > this.brainsMax && (this.persistentData.brains = this.brainsMax),
                    (this.persistentData.bones += 200 * this.startingResources),
                    (this.persistentData.bonesTotal += 200 * this.startingResources),
                    (this.levelResourcesAdded = !0));
        }
        onReady() {
            this.upgrades.upgradeIdCheck();
        }
        addPrestigePoints(e) {
            void 0 === this.persistentData.prestigePointsEarned && ((this.persistentData.prestigePointsEarned = 0), (this.persistentData.prestigePointsToSpend = 0)), (this.persistentData.prestigePointsEarned += e);
        }
        prestige() {
            if (this.persistentData.prestigePointsEarned > 0) {
                (this.persistentData.levelUnlocked = 1),
                    (this.persistentData.blood = 0),
                    (this.persistentData.brains = 0),
                    (this.persistentData.bones = 0),
                    (this.persistentData.parts = 0),
                    (this.persistentData.generators = []),
                    (this.persistentData.bonesTotal = 0),
                    (this.persistentData.upgrades = this.persistentData.upgrades.filter((e) => e.costType == this.upgrades.costs.prestigePoints)),
                    (this.persistentData.constructions = []),
                    (this.persistentData.boneCollectors = 0),
                    (this.persistentData.currentConstruction = !1),
                    (this.persistentData.harpies = 0),
                    (this.persistentData.graveyardZombies = 1),
                    (this.persistentData.prestigePointsToSpend += this.persistentData.prestigePointsEarned),
                    (this.persistentData.prestigePointsEarned = 0),
                    (this.persistentData.runes = null),
                    (this.persistentData.vipEscaped = []),
                    (this.persistentData.creatureLevels = []),
                    (this.persistentData.creatureAutobuild = []),
                    (this.persistentData.levelsCompleted = []),
                    (this.persistentData.runeshatter = 0),
                    (this.zombiesInCages = 0),
                    (this.autoconstruction = !1),
                    (this.levelResourcesAdded = !1),
                    (this.gigazombies = !1),
                    (this.runeEffects = { attackSpeed: 1, critChance: 0, critDamage: 0, damageReduction: 1, healthRegen: 0, damageReflection: 0 }),
                    this.boneCollectors.update(0.1),
                    (this.partFactory.generatorsApplied = []),
                    this.creatureFactory.updateAutoBuild(),
                    this.creatureFactory.resetLevels(),
                    (this.level = 1),
                    (this.currentState = this.states.prestiged),
                    (this.skeleton.persistent.talentReset = !0),
                    this.setupLevel(),
                    this.saveData();
                for (let e = 0; e < this.upgrades.upgrades.length; e++) this.upgrades.upgrades[e].auto = !1;
            }
        }
        saveData() {
            this.persistentData.dateOfSave = Date.now();
            try {
                localStorage.setItem(this.storageName, JSON.stringify(this.persistentData)),
                    localStorage.setItem(this.skeleton.storageName, JSON.stringify(this.skeleton.persistent)),
                    localStorage.setItem(this.skeleton.talentsStorageName, JSON.stringify(this.skeleton.talents));
            } catch (e) {
                //console.log(e);
            }
        }
        loadData() {
            try {
                null !== localStorage.getItem(this.storageName) &&
                    ((this.persistentData = JSON.parse(localStorage.getItem(this.storageName))),
                        (this.level = this.persistentData.levelUnlocked),
                        null !== localStorage.getItem(this.skeleton.storageName)
                            ? (this.skeleton.persistent = JSON.parse(localStorage.getItem(this.skeleton.storageName)))
                            : (this.skeleton.persistent = { xpRate: 0, skeletons: 0, level: 1, xp: 0, items: [], currItemId: 0, talentReset: !1 }),
                        null !== localStorage.getItem(this.skeleton.talentsStorageName) ? (this.skeleton.talents = JSON.parse(localStorage.getItem(this.skeleton.talentsStorageName))) : (this.skeleton.talents = []),
                        this.updatePersistentData(),
                        this.calcOfflineProgress());
            } catch (e) {
                //console.log(e);
            }
        }
        calcOfflineProgress() {
            if ((this.upgrades.applyUpgrades(), this.upgrades.updateRuneEffects(), this.partFactory.applyGenerators(), this.constructions.partFactory)) {
                const e = (Date.now() - this.persistentData.dateOfSave) / 1e3,
                    t = this.partFactory.updateLongTime(e);
                t > 0 && ((this.offlineMessage = "Your factory has generated " + n(t) + " parts while you were away"), (this.persistentData.parts += t));
            }
        }
        resetData() {
            try {
                localStorage.removeItem(this.storageName), localStorage.removeItem(this.skeleton.storageName), localStorage.removeItem(this.skeleton.talentsStorageName), this.saveToPlayFab(!0);
            } catch (e) {
                //console.log(e);
            }
        }
        updatePersistentData() {
            this.persistentData.constructions || (this.persistentData.constructions = []),
                this.persistentData.generators || (this.persistentData.generators = []),
                this.persistentData.parts || (this.persistentData.parts = 0),
                this.persistentData.creatureLevels || (this.persistentData.creatureLevels = []),
                this.persistentData.creatureAutobuild || (this.persistentData.creatureAutobuild = []),
                this.persistentData.savedCreatures || (this.persistentData.savedCreatures = []),
                this.persistentData.levelsCompleted || (this.persistentData.levelsCompleted = []),
                this.persistentData.saveCreated || (this.persistentData.saveCreated = Date.now()),
                void 0 === this.persistentData.particles && (this.persistentData.particles = !0),
                this.persistentData.runeshatter || (this.persistentData.runeshatter = 0),
                this.creatureFactory.updateAutoBuild();
        }
        sendMessage(e) {
            this.messageQueue.includes(e) || this.messageQueue.push(e);
        }
        setResolution(e) {
            this.app &&
                ((this.app.renderer.resolution = e),
                    this.app.renderer.rootRenderTarget && (this.app.renderer.rootRenderTarget.resolution = e),
                    (this.app.renderer.plugins.interaction.resolution = e),
                    this.app.renderer.resize(document.body.clientWidth, document.body.clientHeight));
        }
        downloadSaveGame() {
            (this.persistentData.skeleton = this.skeleton.persistent),
                (this.persistentData.skeletonTalents = this.skeleton.talents),
                (this.blob = new Blob([LZString.compressToEncodedURIComponent(JSON.stringify(this.persistentData))], { type: "octet/stream" })),
                delete this.persistentData.skeleton,
                (this.encodedContent = window.URL.createObjectURL(this.blob));
            const e = new Date().toISOString().replace(/:|T|Z|\./g, "");
            this.savefilename = "incremancer-" + e + ".sav";
        }
        importFile() {
            const e = document.getElementById("import-file").files;
            if (e && 1 == e.length) {
                const t = e[0],
                    s = new FileReader(),
                    i = ne.getInstance();
                (s.onload = function (e) {
                    const t = JSON.parse(LZString.decompressFromEncodedURIComponent(e.target.result));
                    t.dateOfSave
                        ? (t.skeleton && ((i.skeleton.persistent = t.skeleton), delete t.skeleton),
                            t.skeletonTalents ? ((i.skeleton.talents = t.skeletonTalents), delete t.skeletonTalents) : (i.skeleton.talents = []),
                            (i.persistentData = t),
                            i.updatePersistentData(),
                            i.saveToPlayFab(),
                            (i.level = i.persistentData.levelUnlocked),
                            (i.creatureFactory.spawnedSavedCreatures = !1),
                            i.setupLevel())
                        : alert("Error loading save game");
                }),
                    s.readAsText(t);
            }
        }
        toggleFullscreen() {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
                document.exitFullscreen
                    ? document.exitFullscreen()
                    : document.webkitExitFullscreen
                        ? document.webkitExitFullscreen()
                        : document.mozCancelFullScreen
                            ? document.mozCancelFullScreen()
                            : document.msExitFullscreen && document.msExitFullscreen();
            else {
                const e = document.body;
                e.requestFullscreen ? e.requestFullscreen() : e.webkitRequestFullscreen ? e.webkitRequestFullscreen() : e.mozRequestFullScreen ? e.mozRequestFullScreen() : e.msRequestFullscreen && e.msRequestFullscreen();
            }
        }
        prestigePointsForLevel(e) {
            return this.persistentData.levelsCompleted.includes(e) ? 0 : e;
        }
        bossCompleted(e) {
            const t = 50 * Math.floor((e - 1) / 50);
            return t < 50 || this.persistentData.levelsCompleted.includes(t);
        }
        levelLocked(e) {
            return e > this.persistentData.allTimeHighestLevel + 1 || !this.bossCompleted(e);
        }
        isBossStage(e) {
            return e > 0 && e % 50 == 0;
        }
        levelInfo(e) {
            return { level: e, bossStage: this.isBossStage(e), completed: this.persistentData.levelsCompleted.includes(e), locked: this.levelLocked(e), trophy: this.trophies.doesLevelHaveTrophy(e) };
        }
        loginInUsingPlayFab() {
            if (window.kongregate)
                try {
                    PlayFab.settings.titleId = this.titleId;
                    const e = { TitleId: PlayFab.settings.titleId, AuthTicket: window.kongregate.services.getGameAuthToken(), KongregateId: window.kongregate.services.getUserId(), CreateAccount: !0 },
                        t = this;
                    PlayFabClientSDK.LoginWithKongregate(
                        e,
                        function (e) {
                            e && e.data && e.data.PlayFabId && ((t.playFabId = e.data.PlayFabId), t.loadFromPlayFab());
                        },
                        function (e) {
                            //console.log(e);
                        }
                    );
                } catch (e) {
                    console.error(e);
                }
        }
        saveToPlayFab(e = !1) {
            if (((this.lastPlayFabSave = Date.now()), this.playFabId)) {
                const t = this.persistentData.trophies;
                delete this.persistentData.trophies;
                const s = {
                    TitleId: this.titleId,
                    PlayFabId: this.playFabId,
                    Data: {
                        save: !e && LZString.compressToEncodedURIComponent(JSON.stringify(this.persistentData)),
                        trophies: !e && LZString.compressToEncodedURIComponent(JSON.stringify(t)),
                        skeleton: !e && LZString.compressToEncodedURIComponent(JSON.stringify(this.skeleton.persistent)),
                        talents: !e && LZString.compressToEncodedURIComponent(JSON.stringify(this.skeleton.talents)),
                    },
                };
                this.persistentData.trophies = t;
                try {
                    const t = this;
                    PlayFab.ClientApi.UpdateUserData(
                        s,
                        function (s) {
                            e ? (t.resetToBaseStats(), t.setupLevel(), window.location.reload()) : t.messageQueue.push("Game Saved to Cloud");
                        },
                        function (e) {
                            //console.log(e);
                        }
                    );
                } catch (e) {
                    //console.log(e);
                }
            } else e && (this.resetToBaseStats(), this.setupLevel(), window.location.reload());
        }
        loadFromPlayFab(e = !1) {
            if (this.playFabId) {
                const t = { TitleId: this.titleId, PlayFabId: this.playFabId, Keys: ["save", "trophies", "skeleton", "talents"] };
                try {
                    const s = this;
                    PlayFab.ClientApi.GetUserData(
                        t,
                        function (t) {
                            if (t.data.Data.save) {
                                const i = JSON.parse(LZString.decompressFromEncodedURIComponent(t.data.Data.save.Value));
                                (e || i.saveCreated < s.persistentData.saveCreated || (i.saveCreated == s.persistentData.saveCreated && i.dateOfSave > s.persistentData.dateOfSave)) &&
                                    ((s.persistentData = i),
                                        t.data.Data.trophies && (s.persistentData.trophies = JSON.parse(LZString.decompressFromEncodedURIComponent(t.data.Data.trophies.Value))),
                                        t.data.Data.skeleton && (s.skeleton.persistent = JSON.parse(LZString.decompressFromEncodedURIComponent(t.data.Data.skeleton.Value))),
                                        t.data.Data.talents ? (s.skeleton.talents = JSON.parse(LZString.decompressFromEncodedURIComponent(t.data.Data.talents.Value))) : (s.skeleton.talents = []),
                                        (s.level = s.persistentData.levelUnlocked),
                                        s.updatePersistentData(),
                                        s.calcOfflineProgress(),
                                        s.setupLevel(),
                                        s.messageQueue.push("Game Loaded from Cloud"));
                            }
                        },
                        function (e) {
                            //console.log(e);
                        }
                    );
                } catch (e) {
                    //console.log(e);
                }
            }
        }
        allowPlayFabAction() {
            return this.lastPlayFabSave + 15e3 < Date.now();
        }
    }
    class oe {
        constructor() {
            if (
                ((this.gameModel = ne.getInstance()),
                    (this.spells = new SpellManager()),
                    (this.skeleton = new Xe()),
                    (this.partFactory = new se()),
                    (this.types = {
                        energyRate: "energyRate",
                        energyCap: "energyCap",
                        damage: "damage",
                        health: "health",
                        speed: "speed",
                        brainsRate: "brainsRate",
                        bonesRate: "bonesRate",
                        bloodCap: "bloodCap",
                        brainsCap: "brainsCap",
                        brainRecoverChance: "brainRecoverChance",
                        riseFromTheDeadChance: "riseFromTheDeadChance",
                        boneCollectorCapacity: "boneCollectorCapacity",
                        construction: "construction",
                        infectedBite: "infectedBite",
                        infectedBlast: "infectedBlast",
                        plagueDamage: "plagueDamage",
                        plagueTicks: "plagueTicks",
                        burningSpeedPC: "burningSpeedPC",
                        unlockSpell: "unlockSpell",
                        spitDistance: "spitDistance",
                        blastHealing: "blastHealing",
                        plagueArmor: "plagueArmor",
                        monsterLimit: "monsterLimit",
                        runicSyphon: "runicSyphon",
                        gigazombies: "gigazombies",
                        bulletproof: "bulletproof",
                        harpySpeed: "harpySpeed",
                        tankBuster: "tankBuster",
                        harpyBombs: "harpyBombs",
                        spikeDelay: "spikeDelay",
                        bloodGainPC: "bloodGainPC",
                        bloodStoragePC: "bloodStoragePC",
                        brainsGainPC: "brainsGainPC",
                        brainsStoragePC: "brainsStoragePC",
                        bonesGainPC: "bonesGainPC",
                        partsGainPC: "partsGainPC",
                        zombieDmgPC: "zombieDmgPC",
                        zombieHealthPC: "zombieHealthPC",
                        golemHealthPC: "golemHealthPC",
                        golemDamagePC: "golemDamagePC",
                        startingPC: "startingPC",
                        energyCost: "energyCost",
                        autoconstruction: "autoconstruction",
                        autoshop: "autoshop",
                        graveyardHealth: "graveyardHealth",
                        talentPoint: "talentPoint",
                    }),
                    (this.costs = { energy: "energy", blood: "blood", brains: "brains", bones: "bones", prestigePoints: "prestigePoints", parts: "parts" }),
                    (this.constructionStates = { building: "building", paused: "paused", autoPaused: "autoPaused" }),
                    (this.constructionTickTimer = 1),
                    (this.angularModel = null),
                    (this.runeCalculations = [
                        { rune: "death", effect: "attackSpeed", cost: "blood", logBase: 1.1, adjustment: -70, subtract: !1, cap: 0 },
                        { rune: "death", effect: "critChance", cost: "brains", logBase: 1.3, adjustment: -20, cap: 0.8 },
                        { rune: "death", effect: "critDamage", cost: "bones", logBase: 1.05, adjustment: -100, cap: 0 },
                        { rune: "life", effect: "damageReduction", cost: "blood", logBase: 1.5, adjustment: -15, subtract: !0, cap: 0.8 },
                        { rune: "life", effect: "healthRegen", cost: "brains", logBase: 2.9, adjustment: -5.5, cap: 0.5 },
                        { rune: "life", effect: "damageReflection", cost: "bones", logBase: 1.24, adjustment: -30, cap: 1 },
                    ]),
                    (this.constructionTypes = {
                        graveyard: "graveyard",
                        crypt: "crypt",
                        fort: "fort",
                        fortress: "fortress",
                        citadel: "citadel",
                        fence: "fence",
                        fenceSize: "fenceSize",
                        plagueWorkshop: "plagueWorkshop",
                        plagueLaboratory: "plagueLaboratory",
                        plagueSpikes: "plagueSpikes",
                        spellTower: "spellTower",
                        runesmith: "runesmith",
                        aviary: "aviary",
                        zombieCage: "zombieCage",
                        partFactory: "partFactory",
                        monsterFactory: "monsterFactory",
                        pit: "pit",
                        harpy: "harpy",
                    }),
                    (this.constructionUpgrades = [
                        new he(
                            201,
                            "Cursed Graveyard",
                            this.constructionTypes.graveyard,
                            { blood: 1800 },
                            30,
                            1,
                            1,
                            1,
                            null,
                            "Construct a Cursed Graveyard in the town that will automatically spawn zombies when your energy is at its maximum!",
                            "Graveyard menu now available!"
                        ),
                        new he(
                            205,
                            "Crypt",
                            this.constructionTypes.crypt,
                            { blood: 21e3, bones: 2220 },
                            60,
                            1,
                            1,
                            1,
                            201,
                            "Construct a Crypt in your graveyard. This will give you a nice dark and quiet place to think. The additional space will also allow you to store 50% more blood and brains!",
                            null
                        ),
                        new he(
                            206,
                            "Bone Fort",
                            this.constructionTypes.fort,
                            { blood: 6e4, bones: 6e3, energy: 60 },
                            60,
                            1,
                            1,
                            1,
                            205,
                            "Turn your crypt into a fort. The additional space will also allow you to store 60% more blood and brains.",
                            "New upgrades are available in the shop!"
                        ),
                        new he(
                            207,
                            "Bone Fortress",
                            this.constructionTypes.fortress,
                            { blood: 1e5, bones: 9e3, energy: 90 },
                            60,
                            1,
                            1,
                            1,
                            206,
                            "Turn your fort into a fortress. The additional space will also allow you to store 70% more blood and brains.",
                            null
                        ),
                        new he(
                            211,
                            "Bone Citadel",
                            this.constructionTypes.citadel,
                            { blood: 2e5, bones: 12e3, energy: 120 },
                            60,
                            1,
                            1,
                            1,
                            207,
                            "Turn your fortress into a towering citadel that looms over the town. The additional space will also allow you to store 80% more blood and brains.",
                            "New upgrades are available in the shop!"
                        ),
                        new he(202, "Perimeter Fence", this.constructionTypes.fence, { bones: 880, energy: 22 }, 44, 1, 1, 1, 201, "Build a protective fence around the graveyard that will reduce damage taken by zombies inside by 50%.", null),
                        new he(203, "Bigger Fence", this.constructionTypes.fenceSize, { bones: 880, energy: 22 }, 44, 1, 10, 4, 202, "Enlarge the fence so a greater area is protected.", null),
                        new he(
                            204,
                            "Plague Workshop",
                            this.constructionTypes.plagueWorkshop,
                            { blood: 10200, brains: 600 },
                            60,
                            1,
                            1,
                            1,
                            205,
                            "Build a laboratory to study the effects of plague. This will unlock new upgrades in the shop.",
                            "Plague upgrades now available!"
                        ),
                        new he(
                            208,
                            "Plague Spikes",
                            this.constructionTypes.plagueSpikes,
                            { brains: 3e3, bones: 1e3 },
                            30,
                            1,
                            1,
                            1,
                            204,
                            "Booby trap the area around your graveyard with cruel spikes that infect trespassing humans with the plague.",
                            null
                        ),
                        new he(
                            209,
                            "Spell Tower",
                            this.constructionTypes.spellTower,
                            { brains: 3e3, blood: 3e4 },
                            30,
                            1,
                            1,
                            1,
                            206,
                            "Dedicate one tower of your fort to the study of spellcraft. Perhaps you can learn some new spells?",
                            "Spells now available in the shop!"
                        ),
                        new he(210, "Runesmith", this.constructionTypes.runesmith, { bones: 3e3, blood: 12e4, brains: 1e3 }, 30, 1, 1, 1, 207, "Build a runesmith's workshop in order to fortify your zombies with powerful runes.", null),
                        new he(
                            212,
                            "Accursed Aviary",
                            this.constructionTypes.aviary,
                            { bones: 6e3, blood: 22e4, brains: 2e3 },
                            60,
                            1,
                            1,
                            1,
                            211,
                            "Construct an aviary on top of your citadel so you can release wicked harpies to bomb the townspeople.",
                            "Harpies available for hire in the graveyard menu"
                        ),
                        new he(213, "Zombie Cage", this.constructionTypes.zombieCage, { bones: 600, blood: 900 }, 30, 1, 5, 1, 201, "Build a cage to contain surplus zombies once a town is defeated.", null),
                        new he(214, "Second Zombie Cage", this.constructionTypes.zombieCage, { bones: 1200, blood: 1800 }, 30, 1, 10, 1, 205, "Build an additional cage to contain surplus zombies once a town is defeated.", null),
                        new he(215, "Third Zombie Cage", this.constructionTypes.zombieCage, { bones: 1800, blood: 2700 }, 30, 1, 10, 1, 206, "Build an additional cage to contain surplus zombies once a town is defeated.", null),
                        new he(216, "Fourth Zombie Cage", this.constructionTypes.zombieCage, { bones: 2400, blood: 3600 }, 30, 1, 10, 1, 207, "Build an additional cage to contain surplus zombies once a town is defeated.", null),
                        new he(217, "Fifth Zombie Cage", this.constructionTypes.zombieCage, { bones: 3e3, blood: 4500 }, 30, 1, 15, 1, 211, "Build an additional cage to contain surplus zombies once a town is defeated.", null),
                        new he(
                            218,
                            "Plague Laboratory",
                            this.constructionTypes.plagueLaboratory,
                            { brains: 25e3, blood: 1e6 },
                            50,
                            1,
                            1,
                            1,
                            211,
                            "Expand the plague workshop into a well equipped laboratory in order to unlock additional plague upgrades.",
                            null
                        ),
                        new he(
                            219,
                            "Part Factory",
                            this.constructionTypes.partFactory,
                            { brains: 35e3, blood: 15e6 },
                            50,
                            1,
                            1,
                            1,
                            218,
                            "Build a factory to create parts that can be used to construct more powerful beings for your army.",
                            "Factory menu now available!"
                        ),
                        new he(
                            220,
                            "Creature Factory",
                            this.constructionTypes.monsterFactory,
                            { brains: 45e3, blood: 4e7 },
                            50,
                            1,
                            1,
                            1,
                            219,
                            "Build a factory to turn creature parts into living entities of destruction",
                            "Creatures now available in factory menu!"
                        ),
                        new he(
                            221,
                            "Bottomless Pit",
                            this.constructionTypes.pit,
                            { bones: 75e3, parts: 5e6 },
                            50,
                            1,
                            1,
                            10,
                            219,
                            "A bottomless pit with walls made from creature parts. Drastically increases your capacity to store blood and brains.",
                            null
                        ),
                        new he(
                            222,
                            "Harpy Outfitter",
                            this.constructionTypes.harpy,
                            { bones: 75e3, brains: 75e3, blood: 8e7 },
                            50,
                            1,
                            1,
                            1,
                            220,
                            "Build an outfitter to upgrade the abilities of your harpies.",
                            "Harpy upgrades now available in the shop!"
                        ),
                    ]),
                    (this.upgrades = [
                        new le(1, "Bloodthirst", this.types.damage, this.costs.blood, 50, 1.2, 1, 40, "Your zombies thirst for blood and do +1 damage for each rank of Bloodthirst.", null, null),
                        new le(9, "Sharpened Teeth", this.types.damage, this.costs.blood, 3e3, 1.23, 3, 50, "Your zombies bites do +3 damage with each rank of Sharpened Teeth.", null, 206),
                        new le(11, "Razor Claws", this.types.damage, this.costs.blood, 28e3, 1.25, 5, 0, "Your zombies attacks do +5 damage with each rank of Razor Claws.", null, 211),
                        new le(16, "Killer Instinct", this.types.damage, this.costs.blood, 1e6, 1.27, 8, 0, "Your zombies attacks do +8 damage with each rank of Killer Instinct.", null, 220),
                        new le(2, "Like Leather", this.types.health, this.costs.blood, 100, 1.2, 10, 40, "Your zombies gain tougher skin and +10 health with each rank.", null, null),
                        new le(10, "Thick Skull", this.types.health, this.costs.blood, 5e3, 1.23, 25, 50, "Your zombies gain +25 health with each rank.", null, 206),
                        new le(12, "Battle Hardened", this.types.health, this.costs.blood, 32e3, 1.25, 40, 0, "Your zombies gain +40 health with each rank of Battle Hardened.", null, 211),
                        new le(17, "Tough as Nails", this.types.health, this.costs.blood, 1e6, 1.27, 100, 0, "Your zombies gain +100 health with each rank of Tough as Nails.", null, 220),
                        new le(
                            3,
                            "Cold Storage",
                            this.types.brainsCap,
                            this.costs.blood,
                            150,
                            1.2,
                            50,
                            20,
                            "Turns out you can use all of your spare blood to store brains and keep them fresh. Each rank increases your maximum brain capacity by 50.",
                            null,
                            null
                        ),
                        new le(
                            4,
                            "Recycling is Cool",
                            this.types.brainRecoverChance,
                            this.costs.blood,
                            1e3,
                            1.2,
                            0.1,
                            10,
                            "Why are we wasting so many good brains on this project? Each rank increases your chance to get a brain back from a dead zombie by 10%",
                            null,
                            null
                        ),
                        new le(
                            5,
                            "Your Soul is Mine!",
                            this.types.riseFromTheDeadChance,
                            this.costs.blood,
                            1500,
                            1.4,
                            0.1,
                            10,
                            "Using your most powerful blood magic you command the bodies of the dead to rise as your servants! Each rank grants 10% chance that dead humans will turn into zombies.",
                            null,
                            null
                        ),
                        new le(
                            6,
                            "Infected Bite",
                            this.types.infectedBite,
                            this.costs.blood,
                            3500,
                            1.4,
                            0.1,
                            10,
                            "Your zombies are now infected with plague and could infect their victims too. Each rank adds 10% chance to inflict damage over time when a zombie attacks a target.",
                            null,
                            204
                        ),
                        new le(
                            7,
                            "Detonate",
                            this.types.unlockSpell,
                            this.costs.blood,
                            25e3,
                            1,
                            3,
                            1,
                            "Learn the Detonate spell which can explode all of your zombies into a cloud of plague. Not exactly sure how useful that will be.",
                            "New spell learned, Detonate!",
                            209
                        ),
                        new le(
                            8,
                            "Gigazombies?",
                            this.types.unlockSpell,
                            this.costs.blood,
                            5e4,
                            1,
                            5,
                            1,
                            "Learn the Gigazombies spell which will turn some of your zombies into hulking monstrosities with increased health and damage.",
                            "New spell learned, Gigazombies!",
                            209
                        ),
                        new le(
                            13,
                            "Blazing Speed",
                            this.types.burningSpeedPC,
                            this.costs.blood,
                            3e4,
                            1.25,
                            0.05,
                            10,
                            "The humans are using torches to set your zombies on fire. Perhaps we can turn the tables on them? Each rank increases the movement and attack speed of burning zombies by 5%",
                            null,
                            207
                        ),
                        new le(
                            14,
                            "Spit it Out",
                            this.types.spitDistance,
                            this.costs.blood,
                            5e5,
                            1.6,
                            5,
                            10,
                            "The first rank gives your zombies the ability to spit plague at enemies beyond normal attack range. Spit attacks do 50% zombie damage and infect the victim with plague. Subsequent ranks will increase the range of spit attacks.",
                            null,
                            218
                        ),
                        new le(
                            15,
                            "Runic Syphon",
                            this.types.runicSyphon,
                            this.costs.blood,
                            34e3,
                            1.9,
                            0.01,
                            10,
                            "Infuse your runes for free! Each rank gives your Runesmith the ability to infuse 1% of your resource income, without consuming it. Additionally when blood and brains reach their storage limit, any additional resources will be infused automatically.",
                            null,
                            210
                        ),
                        new le(19, "Faster Harpies", this.types.harpySpeed, this.costs.blood, 1e8, 1.07, 2, 20, "These harpies are way too slow! We have to make them faster. Each rank increases harpy speed by 2", null, 222),
                        new le(
                            20,
                            "Energy Rush",
                            this.types.energyRate,
                            this.costs.brains,
                            20,
                            1.8,
                            0.5,
                            20,
                            "Melting brains down in your cauldron to make smoothies can be beneficial for your health. It also increases your energy rate by 0.5 per second for each rank.",
                            null,
                            null
                        ),
                        new le(21, "Master Summoner", this.types.energyCap, this.costs.brains, 10, 1.5, 5, 20, "All the brains you harvested have proved fruitful in your experiments. Each rank raises your maximum energy by 5.", null, null),
                        new le(22, "Primal Reflexes", this.types.speed, this.costs.brains, 5, 1.6, 1, 20, "The zombies retain more of their human agility increasing run speed by 1 for each rank.", null, null),
                        new le(
                            23,
                            "Blood Harvest",
                            this.types.bloodStoragePC,
                            this.costs.brains,
                            50,
                            1.12,
                            0.1,
                            0,
                            "All this brain power has enabled you to devise some superior blood storage methods. Each rank increases your maximum blood by 10%.",
                            null,
                            null
                        ),
                        new le(
                            24,
                            "Unholy Construction",
                            this.types.construction,
                            this.costs.brains,
                            25,
                            1,
                            1,
                            1,
                            "Learn the art of Unholy Construction in order to build structures that will solidify your foothold on the town.",
                            "Construction menu now available!",
                            null
                        ),
                        new le(
                            25,
                            "Infected Corpse",
                            this.types.infectedBlast,
                            this.costs.brains,
                            500,
                            1.4,
                            0.1,
                            10,
                            "Fill your zombies with so much plague they are ready to explode! Each rank adds 10% chance for a zombie to explode into a cloud of plague upon death.",
                            null,
                            204
                        ),
                        new le(
                            26,
                            "Energy Charge",
                            this.types.unlockSpell,
                            this.costs.brains,
                            2e3,
                            1,
                            2,
                            1,
                            "Learn the Energy Charge spell which can drastically increase your energy rate for a short time.",
                            "New spell learned, Energy Charge!",
                            209
                        ),
                        new le(
                            27,
                            "What Doesn't Kill You",
                            this.types.blastHealing,
                            this.costs.brains,
                            1e4,
                            1.3,
                            0.1,
                            20,
                            "Plague explosions from zombies and harpies will also heal nearby zombies for 10% of the explosion damage with each rank.",
                            null,
                            218
                        ),
                        new le(
                            28,
                            "One is Never Enough",
                            this.types.monsterLimit,
                            this.costs.brains,
                            2e4,
                            1.2,
                            1,
                            15,
                            "We're definitely going to need more than one golem to finish the job. Each rank increases your creature limit by 1",
                            null,
                            220
                        ),
                        new le(
                            29,
                            "Tank Buster",
                            this.types.tankBuster,
                            this.costs.brains,
                            4e5,
                            1.2,
                            1,
                            1,
                            "Teach your harpies some new tricks. Once bought this upgrade will make your harpies drop fire bombs on tanks during boss stages.",
                            null,
                            222
                        ),
                        new le(30, "Improved Spikes", this.types.spikeDelay, this.costs.brains, 800, 1.2, 1, 4, "Each rank reduces the delay between plague spike activation by 20%", null, 208),
                        new le(40, "Bone Throne", this.types.energyCap, this.costs.bones, 50, 1.55, 10, 15, "Sitting atop your throne of bones you can finally think clearly. Each rank increases maximum energy by 10.", null, null),
                        new le(41, "Crown of Bones", this.types.energyRate, this.costs.bones, 200, 1.5, 0.2, 25, "Not just dapper, these spikes help channel your energy. Each rank increases energy rate by 0.2 per second.", null, null),
                        new le(
                            42,
                            "Bonebarrows",
                            this.types.boneCollectorCapacity,
                            this.costs.bones,
                            300,
                            1.2,
                            5,
                            20,
                            "Your bone collectors are struggling to carry all these bones. Maybe it's time we gave them an upgrade? Each rank increases their carrying capacity by 5.",
                            null,
                            null
                        ),
                        new le(
                            43,
                            "Bone Reinforced Tanks",
                            this.types.bloodCap,
                            this.costs.bones,
                            500,
                            1.07,
                            2e3,
                            0,
                            "Finally! Now that we have a solid construction material we can get to work building better storage for our other resources. Each rank increases blood storage by 2000.",
                            null,
                            null
                        ),
                        new le(
                            44,
                            "Brain Cage",
                            this.types.brainsCap,
                            this.costs.bones,
                            650,
                            1.07,
                            500,
                            0,
                            "There's nothing I love more than a mind enslaved. Now we can put these brains where they belong. In cages! Each rank increases brain storage by 500.",
                            null,
                            null
                        ),
                        new le(45, "Earth Freeze", this.types.unlockSpell, this.costs.bones, 5e3, 1, 4, 1, "Learn the Earth Freeze spell which can freeze all humans in place for a short time.", "New spell learned, Earth Freeze!", 209),
                        new le(
                            46,
                            "Plague Armor",
                            this.types.plagueArmor,
                            this.costs.bones,
                            15e3,
                            1.6,
                            0.02,
                            10,
                            "The best defense is a good offense? True in the case of Plague Armor which reduces the damage done by infected humans by 2% per rank.",
                            null,
                            218
                        ),
                        new le(
                            47,
                            "Bulletproof",
                            this.types.bulletproof,
                            this.costs.bones,
                            6e4,
                            1.6,
                            0.05,
                            5,
                            "Craft your earth golems from much harder stone. Each rank gives them 5% chance to reflect bullets back to their source.",
                            null,
                            220
                        ),
                        new le(48, "Bombs Away", this.types.harpyBombs, this.costs.bones, 5e5, 1.6, 1, 3, "Upgrade your harpies so they can carry more than just one bomb at a time.", null, 222),
                        new le(60, "Extra Limbs", this.types.golemDamagePC, this.costs.parts, 900, 1.3, 0.02, 0, "Your golems gain +2% damage with each rank of Extra Limbs.", null, 220),
                        new le(61, "Big Boned", this.types.golemHealthPC, this.costs.parts, 1e3, 1.31, 0.02, 0, "Your golems gain +2% health with each rank of Big Boned.", null, 220),
                    ]),
                    (this.prestigeUpgrades = [
                        new le(108, "A Small Investment", this.types.startingPC, this.costs.prestigePoints, 10, 1.25, 1, 0, "Each rank gives you an additional 500 blood, 50 brains, and 200 bones when starting a new level.", null, null),
                        new le(109, "Time Warp", this.types.unlockSpell, this.costs.prestigePoints, 50, 1, 1, 1, "Unlock the Time Warp spell in order to speed up the flow of time.", null, null),
                        new le(110, "Master of Death", this.types.energyCost, this.costs.prestigePoints, 1e3, 1, 1, 5, "Each rank reduces the energy cost of summoning a zombie by 1", null, null),
                        new le(101, "Blood Storage", this.types.bloodStoragePC, this.costs.prestigePoints, 10, 1.25, 0.2, 0, "Additional 20% blood storage for each rank.", null, null),
                        new le(102, "Blood Rate", this.types.bloodGainPC, this.costs.prestigePoints, 10, 1.25, 0.2, 0, "Additional 20% blood income rate for each rank.", null, null),
                        new le(103, "Brain Storage", this.types.brainsStoragePC, this.costs.prestigePoints, 10, 1.25, 0.2, 0, "Additional 20% brain storage for each rank.", null, null),
                        new le(104, "Brain Rate", this.types.brainsGainPC, this.costs.prestigePoints, 10, 1.25, 0.2, 0, "Additional 20% brain income rate for each rank.", null, null),
                        new le(105, "Bone Rate", this.types.bonesGainPC, this.costs.prestigePoints, 10, 1.25, 0.2, 0, "Additional 20% bones income rate for each rank.", null, null),
                        new le(111, "Parts Rate", this.types.partsGainPC, this.costs.prestigePoints, 10, 1.25, 0.2, 0, "Additional 20% creature parts income rate for each rank.", null, null),
                        new le(112, "Auto Construction", this.types.autoconstruction, this.costs.prestigePoints, 250, 1, 1, 1, "Unlock the ability to automatically start construction of the cheapest available building option.", null, null),
                        new le(114, "Auto Shop", this.types.autoshop, this.costs.prestigePoints, 250, 1, 1, 1, "Unlock the ability to automatically purchase items from the shop.", null, null),
                        new le(113, "Graveyard Health", this.types.graveyardHealth, this.costs.prestigePoints, 10, 1.25, 0.1, 0, "Additional 10% graveyard health during boss levels with each rank.", null, null),
                        new le(115, "Talent Point", this.types.talentPoint, this.costs.prestigePoints, 100, 1.2, 1, 0, "Additional skeleton talent point", null, null),
                    ]),
                    oe.instance)
            )
                return oe.instance;
            oe.instance = this;
        }
        hasRequirement(e) {
            return !e.requires || 0 != this.gameModel.persistentData.constructions.filter((t) => t.id == e.requires).length;
        }
        getUpgrades(e) {
            switch (e) {
                case this.costs.blood:
                case this.costs.brains:
                case this.costs.bones:
                case this.costs.parts:
                    return this.upgrades.filter((t) => t.costType == e && (0 == t.cap || this.currentRank(t) < t.cap) && this.hasRequirement(t));
                case "completed":
                    return this.upgrades.filter((e) => e.cap > 0 && this.currentRank(e) >= e.cap);
            }
        }
        applyUpgrades() {
            this.gameModel.resetToBaseStats(), this.spells.lockAllSpells();
            for (let e = 0; e < this.gameModel.persistentData.upgrades.length; e++) {
                let t = this.upgrades.filter((t) => t.id == this.gameModel.persistentData.upgrades[e].id)[0];
                t || (t = this.prestigeUpgrades.filter((t) => t.id == this.gameModel.persistentData.upgrades[e].id)[0]), t && this.applyUpgrade(t, this.gameModel.persistentData.upgrades[e].rank);
            }
            for (let e = 0; e < this.gameModel.persistentData.constructions.length; e++) this.applyConstructionUpgrade(this.gameModel.persistentData.constructions[e]);
            const e = new de().getAquiredTrophyList();
            for (let t = 0; t < e.length; t++) this.applyUpgrade(e[t], e[t].rank);
            this.skeleton.applyUpgrades(),
                (this.gameModel.bloodMax *= this.gameModel.bloodStorePCMod),
                (this.gameModel.brainsMax *= this.gameModel.brainsStorePCMod),
                (this.gameModel.zombieDamage *= this.gameModel.zombieDamagePCMod),
                (this.gameModel.zombieHealth *= this.gameModel.zombieHealthPCMod),
                this.gameModel.persistentData.runeshatter &&
                ((this.gameModel.zombieDamage *= this.shatterEffect()), (this.gameModel.zombieHealth *= this.shatterEffect()), (this.gameModel.zombieCost += this.gameModel.persistentData.runeshatter));
        }
        applyUpgrade(e, t) {
            switch (e.type) {
                case this.types.energyRate:
                    return void (this.gameModel.energyRate += e.effect * t);
                case this.types.brainsRate:
                    return void (this.gameModel.brainsRate += e.effect * t);
                case this.types.bonesRate:
                    return void (this.gameModel.bonesRate += e.effect * t);
                case this.types.energyCap:
                    return void (this.gameModel.energyMax += e.effect * t);
                case this.types.bloodCap:
                    return void (this.gameModel.bloodMax += e.effect * t);
                case this.types.brainsCap:
                    return void (this.gameModel.brainsMax += e.effect * t);
                case this.types.damage:
                    return void (this.gameModel.zombieDamage += e.effect * t);
                case this.types.speed:
                    return void (this.gameModel.zombieSpeed += e.effect * t);
                case this.types.health:
                    return void (this.gameModel.zombieHealth += e.effect * t);
                case this.types.brainRecoverChance:
                    return void (this.gameModel.brainRecoverChance += e.effect * t);
                case this.types.riseFromTheDeadChance:
                    return void (this.gameModel.riseFromTheDeadChance += e.effect * t);
                case this.types.infectedBite:
                    return void (this.gameModel.infectedBiteChance += e.effect * t);
                case this.types.infectedBlast:
                    return void (this.gameModel.infectedBlastChance += e.effect * t);
                case this.types.plagueDamage:
                    return void (this.gameModel.plagueDamageMod += e.effect);
                case this.types.plagueTicks:
                    return void (this.gameModel.plagueticks += e.effect);
                case this.types.burningSpeedPC:
                    return void (this.gameModel.burningSpeedMod += e.effect * t);
                case this.types.construction:
                    return void (this.gameModel.construction = 1);
                case this.types.boneCollectorCapacity:
                    return void (this.gameModel.boneCollectorCapacity += e.effect * t);
                case this.types.unlockSpell:
                    return void this.spells.unlockSpell(e.effect);
                case this.types.spitDistance:
                    return void (this.gameModel.spitDistance = 30 + e.effect * t);
                case this.types.blastHealing:
                    return void (this.gameModel.blastHealing += e.effect * t);
                case this.types.plagueArmor:
                    return void (this.gameModel.plagueDmgReduction -= e.effect * t);
                case this.types.monsterLimit:
                    return void (this.gameModel.creatureLimit += e.effect * t);
                case this.types.runicSyphon:
                    return void (this.gameModel.runicSyphon.percentage += e.effect * t);
                case this.types.bulletproof:
                    return void (this.gameModel.bulletproofChance += e.effect * t);
                case this.types.harpySpeed:
                    return void (this.gameModel.harpySpeed += e.effect * t);
                case this.types.tankBuster:
                    return void (this.gameModel.tankBuster = !0);
                case this.types.harpyBombs:
                    return void (this.gameModel.harpyBombs += e.effect * t);
                case this.types.spikeDelay:
                    return void (this.gameModel.spikeDelay -= e.effect * t);
                case this.types.bonesGainPC:
                    return void (this.gameModel.bonesPCMod *= Math.pow(1 + e.effect, t));
                case this.types.partsGainPC:
                    return void (this.gameModel.partsPCMod *= Math.pow(1 + e.effect, t));
                case this.types.bloodGainPC:
                    return void (this.gameModel.bloodPCMod *= Math.pow(1 + e.effect, t));
                case this.types.bloodStoragePC:
                    return void (this.gameModel.bloodStorePCMod *= Math.pow(1 + e.effect, t));
                case this.types.brainsGainPC:
                    return void (this.gameModel.brainsPCMod *= Math.pow(1 + e.effect, t));
                case this.types.brainsStoragePC:
                    return void (this.gameModel.brainsStorePCMod *= Math.pow(1 + e.effect, t));
                case this.types.zombieDmgPC:
                    return void (this.gameModel.zombieDamagePCMod *= Math.pow(1 + e.effect, t));
                case this.types.zombieHealthPC:
                    return void (this.gameModel.zombieHealthPCMod *= Math.pow(1 + e.effect, t));
                case this.types.golemDamagePC:
                    return void (this.gameModel.golemDamagePCMod *= Math.pow(1 + e.effect, t));
                case this.types.golemHealthPC:
                    return void (this.gameModel.golemHealthPCMod *= Math.pow(1 + e.effect, t));
                case this.types.startingPC:
                    return void (this.gameModel.startingResources += e.effect * t);
                case this.types.energyCost:
                    return void (this.gameModel.zombieCost -= e.effect * t);
                case this.types.autoconstruction:
                    return void (this.gameModel.autoconstructionUnlocked = !0);
                case this.types.autoshop:
                    return void (this.gameModel.autoUpgrades = !0);
                case this.types.graveyardHealth:
                    return void (this.gameModel.graveyardHealthMod *= Math.pow(1 + e.effect, t));
                case this.types.talentPoint:
                    return void (this.skeleton.talentPoints = t);
            }
        }
        applyConstructionUpgrade(e) {
            switch (e.type) {
                case this.constructionTypes.graveyard:
                    return void (this.gameModel.constructions.graveyard = 1);
                case this.constructionTypes.crypt:
                    return (this.gameModel.constructions.crypt = 1), (this.gameModel.brainsStorePCMod *= 1.5), void (this.gameModel.bloodStorePCMod *= 1.5);
                case this.constructionTypes.fort:
                    return (this.gameModel.constructions.fort = 1), (this.gameModel.brainsStorePCMod *= 1.6), void (this.gameModel.bloodStorePCMod *= 1.6);
                case this.constructionTypes.fortress:
                    return (this.gameModel.constructions.fortress = 1), (this.gameModel.brainsStorePCMod *= 1.7), void (this.gameModel.bloodStorePCMod *= 1.7);
                case this.constructionTypes.citadel:
                    return (this.gameModel.constructions.citadel = 1), (this.gameModel.brainsStorePCMod *= 1.8), void (this.gameModel.bloodStorePCMod *= 1.8);
                case this.constructionTypes.plagueSpikes:
                    return void (this.gameModel.constructions.plagueSpikes = 1);
                case this.constructionTypes.fence:
                    return void (this.gameModel.constructions.fence = 1);
                case this.constructionTypes.fenceSize:
                    return void (this.gameModel.fenceRadius += e.effect * e.rank);
                case this.constructionTypes.pit:
                    return (this.gameModel.bloodMax += 1e6 * e.rank), void (this.gameModel.brainsMax += 1e5 * e.rank);
                case this.constructionTypes.runesmith:
                    return (
                        (this.gameModel.constructions.runesmith = 1),
                        void (this.gameModel.persistentData.runes || (this.gameModel.persistentData.runes = { life: { blood: 0, brains: 0, bones: 0 }, death: { blood: 0, brains: 0, bones: 0 } }))
                    );
                case this.constructionTypes.aviary:
                    return void (this.gameModel.constructions.aviary = 1);
                case this.constructionTypes.zombieCage:
                    return void (this.gameModel.zombieCages += e.effect * e.rank);
                case this.constructionTypes.partFactory:
                    return (this.gameModel.constructions.partFactory = !0), void (this.gameModel.constructions.factory = !0);
                case this.constructionTypes.monsterFactory:
                    return (this.gameModel.constructions.monsterFactory = !0), void (this.gameModel.constructions.factory = !0);
            }
        }
        displayStatValue(e) {
            switch (e.type) {
                case this.types.energyRate:
                    return "Energy rate: " + r(this.gameModel.energyRate) + " per second";
                case this.types.energyCap:
                    return "Maximum energy: " + n(this.gameModel.energyMax);
                case this.types.bloodCap:
                    return "Maximum blood: " + n(this.gameModel.bloodMax);
                case this.types.brainsCap:
                    return "Maximum brains: " + n(this.gameModel.brainsMax);
                case this.types.damage:
                    return "Zombie damage: " + n(this.gameModel.zombieDamage);
                case this.types.speed:
                    return "Zombie speed: " + n(this.gameModel.zombieSpeed);
                case this.types.health:
                    return "Zombie maximum health: " + n(this.gameModel.zombieHealth);
                case this.types.brainRecoverChance:
                    return Math.round(100 * this.gameModel.brainRecoverChance) + "% chance to recover brain";
                case this.types.riseFromTheDeadChance:
                    return Math.round(100 * this.gameModel.riseFromTheDeadChance) + "% chance for human corpses to turn into zombies";
                case this.types.infectedBite:
                    return Math.round(100 * this.gameModel.infectedBiteChance) + "% chance for zombies to infect their targets";
                case this.types.infectedBlast:
                    return Math.round(100 * this.gameModel.infectedBlastChance) + "% chance for zombies to explode on death";
                case this.types.bulletproof:
                    return Math.round(100 * this.gameModel.bulletproofChance) + "% chance for earth golems to reflect bullets";
                case this.types.construction:
                    return this.gameModel.construction > 0 ? "You have unlocked Unholy Construction" : "You have yet to unlock Unholy Construction";
                case this.types.boneCollectorCapacity:
                    return "Bone collector capacity: " + n(this.gameModel.boneCollectorCapacity);
                case this.types.bonesGainPC:
                    return "Bones: " + n(Math.round(100 * this.gameModel.bonesPCMod)) + "%";
                case this.types.partsGainPC:
                    return "Parts: " + n(Math.round(100 * this.gameModel.partsPCMod)) + "%";
                case this.types.bloodGainPC:
                    return "Blood: " + n(Math.round(100 * this.gameModel.bloodPCMod)) + "%";
                case this.types.bloodStoragePC:
                    return "Blood Storage: " + n(100 * this.gameModel.bloodStorePCMod) + "%";
                case this.types.brainsGainPC:
                    return "Brains: " + n(Math.round(100 * this.gameModel.brainsPCMod)) + "%";
                case this.types.brainsStoragePC:
                    return "Brains Storage: " + n(100 * this.gameModel.brainsStorePCMod) + "%";
                case this.types.zombieDmgPC:
                    return "Zombie Damage: " + Math.round(100 * this.gameModel.zombieDamagePCMod) + "%";
                case this.types.zombieHealthPC:
                    return "Zombie Health: " + Math.round(100 * this.gameModel.zombieHealthPCMod) + "%";
                case this.types.golemDamagePC:
                    return "Golem Damage: " + Math.round(100 * this.gameModel.golemDamagePCMod) + "%";
                case this.types.golemHealthPC:
                    return "Golem Health: " + Math.round(100 * this.gameModel.golemHealthPCMod) + "%";
                case this.types.startingPC:
                    return Math.round(500 * this.gameModel.startingResources) + " blood, " + Math.round(50 * this.gameModel.startingResources) + " brains, " + Math.round(200 * this.gameModel.startingResources) + " bones";
                case this.types.unlockSpell:
                    return this.currentRank(e) > 0 ? "You have learned this spell" : "You have yet to learn this spell";
                case this.types.energyCost:
                    return "Zombie Cost: " + this.gameModel.zombieCost + " energy";
                case this.types.burningSpeedPC:
                    return "Burning zombie speed: " + Math.round(100 * this.gameModel.burningSpeedMod) + "%";
                case this.types.blastHealing:
                    return "Plague heal: " + Math.round(100 * this.gameModel.blastHealing) + "%";
                case this.types.spitDistance:
                    return "Zombie spit distance: " + this.gameModel.spitDistance;
                case this.types.plagueArmor:
                    return "Infected damage reduction: " + Math.round(100 - 100 * this.gameModel.plagueDmgReduction) + "%";
                case this.types.monsterLimit:
                    return "Creature limit: " + this.gameModel.creatureLimit;
                case this.types.runicSyphon:
                    return "Syphon amount: " + Math.round(100 * this.gameModel.runicSyphon.percentage) + "%";
                case this.types.autoconstruction:
                    return this.currentRank(e) > 0 ? "You have unlocked automatic construction" : "You have yet to unlock automatic construction";
                case this.types.autoshop:
                    return this.currentRank(e) > 0 ? "You have unlocked automatic shop purchases" : "You have yet to unlock automatic shop purchases";
                case this.types.graveyardHealth:
                    return "Graveyard health: " + Math.round(100 * this.gameModel.graveyardHealthMod) + "%";
                case this.types.harpySpeed:
                    return "Harpy speed: " + n(this.gameModel.harpySpeed);
                case this.types.harpyBombs:
                    return "Harpy bombs: " + n(this.gameModel.harpyBombs);
                case this.types.tankBuster:
                    return this.currentRank(e) > 0 ? "You have unlocked tank buster" : "You have yet to unlock tank buster";
                case this.types.spikeDelay:
                    return "Current spike delay: " + (5 - this.currentRank(e)) + " seconds";
            }
        }
        currentRank(e) {
            for (let t = 0; t < this.gameModel.persistentData.upgrades.length; t++) {
                const s = this.gameModel.persistentData.upgrades[t];
                if (e.id == s.id) return s.rank;
            }
            return 0;
        }
        currentRankConstruction(e) {
            if (this.gameModel.persistentData.constructions)
                for (let t = 0; t < this.gameModel.persistentData.constructions.length; t++) {
                    const s = this.gameModel.persistentData.constructions[t];
                    if (e.id == s.id) return s.rank;
                }
            return 0;
        }
        upgradePrice(e) {
            return Math.round(e.basePrice * Math.pow(e.multiplier, this.currentRank(e)));
        }
        upgradeMaxAffordable(e) {
            const t = this.currentRank(e);
            let s = 0;
            switch (e.costType) {
                case this.costs.blood:
                    s = h(e.basePrice, e.multiplier, t, this.gameModel.persistentData.blood);
                    break;
                case this.costs.brains:
                    s = h(e.basePrice, e.multiplier, t, this.gameModel.persistentData.brains);
                    break;
                case this.costs.bones:
                    s = h(e.basePrice, e.multiplier, t, this.gameModel.persistentData.bones);
                    break;
                case this.costs.parts:
                    s = h(e.basePrice, e.multiplier, t, this.gameModel.persistentData.parts);
                    break;
                case this.costs.prestigePoints:
                    s = h(e.basePrice, e.multiplier, t, this.gameModel.persistentData.prestigePointsToSpend);
            }
            return 0 != e.cap ? Math.min(s, e.cap - t) : s;
        }
        upgradeMaxPrice(e, t) {
            return l(e.basePrice, e.multiplier, this.currentRank(e), t);
        }
        canAffordUpgrade(e) {
            if (e.cap > 0 && this.currentRank(e) >= e.cap) return (e.auto = !1), !1;
            switch (e.costType) {
                case this.costs.energy:
                    return this.gameModel.energy >= this.upgradePrice(e);
                case this.costs.blood:
                    return this.gameModel.persistentData.blood >= this.upgradePrice(e);
                case this.costs.brains:
                    return this.gameModel.persistentData.brains >= this.upgradePrice(e);
                case this.costs.bones:
                    return this.gameModel.persistentData.bones >= this.upgradePrice(e);
                case this.costs.parts:
                    return this.gameModel.persistentData.parts >= this.upgradePrice(e);
                case this.costs.prestigePoints:
                    return this.gameModel.persistentData.prestigePointsToSpend >= this.upgradePrice(e);
            }
            return !1;
        }
        constructionLeadsTo(e) {
            let t = this.constructionUpgrades
                .filter((t) => t.requires == e.id)
                .map((e) => e.name)
                .join(", ");
            return (
                (t += this.upgrades
                    .filter((t) => t.requires == e.id)
                    .map((e) => e.name)
                    .join(", ")),
                t
            );
        }
        purchaseMaxUpgrades(e) {
            const t = this.upgradeMaxAffordable(e);
            for (let s = 0; s < t; s++) this.purchaseUpgrade(e, !1);
            this.gameModel.saveData();
        }
        purchaseUpgrade(e, t = !0) {
            if (this.canAffordUpgrade(e)) {
                let s,
                    i = !1;
                switch (e.costType) {
                    case this.costs.energy:
                        this.gameModel.energy -= this.upgradePrice(e);
                        break;
                    case this.costs.blood:
                        this.gameModel.persistentData.blood -= this.upgradePrice(e);
                        break;
                    case this.costs.brains:
                        this.gameModel.persistentData.brains -= this.upgradePrice(e);
                        break;
                    case this.costs.bones:
                        this.gameModel.persistentData.bones -= this.upgradePrice(e);
                        break;
                    case this.costs.prestigePoints:
                        (i = !0), (this.gameModel.persistentData.prestigePointsToSpend -= this.upgradePrice(e));
                        break;
                    case this.costs.parts:
                        this.gameModel.persistentData.parts -= this.upgradePrice(e);
                }
                for (let t = 0; t < this.gameModel.persistentData.upgrades.length; t++)
                    if (e.id == this.gameModel.persistentData.upgrades[t].id) {
                        (s = !0), (this.gameModel.persistentData.upgrades[t] = { id: e.id, rank: this.gameModel.persistentData.upgrades[t].rank + 1 }), i && (this.gameModel.persistentData.upgrades[t].costType = this.costs.prestigePoints);
                        break;
                    }
                if (!s) {
                    const t = { id: e.id, rank: 1, costType: null };
                    i && (t.costType = this.costs.prestigePoints), this.gameModel.persistentData.upgrades.push(t);
                }
                t && this.gameModel.saveData(), this.applyUpgrades(), e.purchaseMessage && this.gameModel.sendMessage(e.purchaseMessage);
            }
        }
        removeUpgrade(e) {
            for (let t = 0; t < this.gameModel.persistentData.upgrades.length; t++)
                if (e.id == this.gameModel.persistentData.upgrades[t].id) {
                    this.gameModel.persistentData.upgrades[t] = { id: e.id, rank: 0 };
                    break;
                }
            this.applyUpgrades();
        }
        consumeResources(e) {
            let t = !0;
            return (
                (this.gameModel.persistentData.currentConstruction.shortfall = {}),
                e.energy && e.energy > this.gameModel.energy && ((t = !1), (this.gameModel.persistentData.currentConstruction.shortfall.energy = !0)),
                e.blood && e.blood > this.gameModel.persistentData.blood && ((t = !1), (this.gameModel.persistentData.currentConstruction.shortfall.blood = !0)),
                e.brains && e.brains > this.gameModel.persistentData.brains && ((t = !1), (this.gameModel.persistentData.currentConstruction.shortfall.brains = !0)),
                e.bones && e.bones > this.gameModel.persistentData.bones && ((t = !1), (this.gameModel.persistentData.currentConstruction.shortfall.bones = !0)),
                e.parts && e.parts > this.gameModel.persistentData.parts && ((t = !1), (this.gameModel.persistentData.currentConstruction.shortfall.parts = !0)),
                !!t &&
                ((this.gameModel.persistentData.currentConstruction.shortfall = !1),
                    e.energy && (this.gameModel.energy -= e.energy),
                    e.blood && (this.gameModel.persistentData.blood -= e.blood),
                    e.brains && (this.gameModel.persistentData.brains -= e.brains),
                    e.bones && (this.gameModel.persistentData.bones -= e.bones),
                    e.parts && (this.gameModel.persistentData.parts -= e.parts),
                    !0)
            );
        }
        completeConstruction() {
            const e = this.constructionUpgrades.filter((e) => e.id == this.gameModel.persistentData.currentConstruction.id)[0];
            let t;
            for (let s = 0; s < this.gameModel.persistentData.constructions.length; s++) e.id == this.gameModel.persistentData.constructions[s].id && ((t = this.gameModel.persistentData.constructions[s]), (t.effect = e.effect), t.rank++);
            t || this.gameModel.persistentData.constructions.push({ id: e.id, name: e.name, rank: 1, type: e.type, effect: e.effect }),
                (this.gameModel.persistentData.currentConstruction = !1),
                this.gameModel.saveData(),
                this.applyUpgrades(),
                this.angularModel.updateConstructionUpgrades(),
                this.gameModel.sendMessage("Construction of " + e.name + " complete!"),
                e.completeMessage && this.gameModel.sendMessage(e.completeMessage);
        }
        updateAutoUpgrades() {
            if (this.gameModel.autoUpgrades) {
                for (let e = 0; e < this.upgrades.length; e++) this.upgrades[e].auto && this.purchaseUpgrade(this.upgrades[e], !1);
                if (this.gameModel.constructions.factory) for (let e = 0; e < this.partFactory.generators.length; e++) this.partFactory.generators[e].auto && this.partFactory.purchaseGenerator(this.partFactory.generators[e], !1);
            }
            this.gameModel.autoShatter && this.doShatter();
        }
        updateConstruction(e) {
            if ((this.gameModel.persistentData.currentConstruction || this.gameModel.autoconstruction) && this.gameModel.persistentData.currentConstruction.state != this.constructionStates.paused)
                if (this.gameModel.persistentData.currentConstruction)
                    (this.constructionTickTimer -= e),
                        this.constructionTickTimer < 0 &&
                        ((this.constructionTickTimer = 1),
                            this.consumeResources(this.gameModel.persistentData.currentConstruction.costPerTick)
                                ? ((this.gameModel.persistentData.currentConstruction.state = this.constructionStates.building),
                                    (this.gameModel.persistentData.currentConstruction.timeRemaining -= 1),
                                    this.gameModel.persistentData.currentConstruction.timeRemaining <= 0 && this.completeConstruction())
                                : (this.gameModel.persistentData.currentConstruction.state = this.constructionStates.autoPaused));
                else if (this.gameModel.autoconstruction) {
                    const e = this.getAvailableConstructions();
                    if (!e || 0 == e.length) return void (this.gameModel.autoconstruction = !1);
                    let t = null,
                        s = 0;
                    for (let i = 0; i < e.length; i++) {
                        const a = (e[i].costs.energy || 0) + (e[i].costs.blood || 0) + (e[i].costs.brains || 0) + (e[i].costs.bones || 0) + 100 * (e[i].costs.parts || 0);
                        (a < s || !t) && ((s = a), (t = e[i]));
                    }
                    t && setTimeout(() => this.startConstruction(t));
                }
        }
        startConstruction(e) {
            if (this.gameModel.persistentData.currentConstruction) return;
            const t =
                this.gameModel.persistentData.blood >= (e.costs.blood || 0) &&
                this.gameModel.persistentData.brains >= (e.costs.brains || 0) &&
                this.gameModel.persistentData.bones >= (e.costs.bones || 0) &&
                this.gameModel.persistentData.parts >= (e.costs.parts || 0) &&
                this.gameModel.energy >= (e.costs.energy || 0),
                s = { energy: 0, blood: 0, brains: 0, bones: 0, parts: 0 };
            e.costs.energy && (s.energy = e.costs.energy / (t ? 5 : e.time)),
                e.costs.blood && (s.blood = e.costs.blood / (t ? 5 : e.time)),
                e.costs.brains && (s.brains = e.costs.brains / (t ? 5 : e.time)),
                e.costs.bones && (s.bones = e.costs.bones / (t ? 5 : e.time)),
                e.costs.parts && (s.parts = e.costs.parts / (t ? 5 : e.time)),
                (this.gameModel.persistentData.currentConstruction = { state: this.constructionStates.building, name: e.name, id: e.id, timeRemaining: t ? 5 : e.time, time: t ? 5 : e.time, costPerTick: s });
        }
        playPauseConstruction() {
            this.gameModel.persistentData.currentConstruction &&
                (this.gameModel.persistentData.currentConstruction.state == this.constructionStates.paused
                    ? (this.gameModel.persistentData.currentConstruction.state = this.constructionStates.building)
                    : (this.gameModel.persistentData.currentConstruction.state = this.constructionStates.paused));
        }
        cancelConstruction() {
            this.gameModel.persistentData.currentConstruction = !1;
        }
        constructionAvailable(e) {
            return !(
                (this.gameModel.persistentData.currentConstruction && this.gameModel.persistentData.currentConstruction.id == e.id) ||
                this.currentRankConstruction(e) >= e.cap ||
                (e.requires && 0 == this.gameModel.persistentData.constructions.filter((t) => t.id == e.requires).length)
            );
        }
        constructionComplete(e) {
            return this.currentRankConstruction(e) >= e.cap;
        }
        getAvailableConstructions() {
            return this.constructionUpgrades.filter((e) => this.constructionAvailable(e));
        }
        getCompletedConstructions() {
            return this.constructionUpgrades.filter((e) => this.constructionComplete(e));
        }
        upgradeIdCheck() {
            const e = [];
            this.upgrades.forEach(function (t) {
                e[t.id] && console.error("ID " + t.id + " already used"), (e[t.id] = !0);
            }),
                this.prestigeUpgrades.forEach(function (t) {
                    e[t.id] && console.error("ID " + t.id + " already used"), (e[t.id] = !0);
                }),
                this.constructionUpgrades.forEach(function (t) {
                    e[t.id] && console.error("ID " + t.id + " already used"), (e[t.id] = !0);
                });
        }
        updateRunicSyphon(e) {
            e.percentage > 0 &&
                ((this.gameModel.persistentData.runes.life.blood += e.blood / 2),
                    (this.gameModel.persistentData.runes.death.blood += e.blood / 2),
                    (this.gameModel.persistentData.runes.life.brains += e.brains / 2),
                    (this.gameModel.persistentData.runes.death.brains += e.brains / 2),
                    (this.gameModel.persistentData.runes.life.bones += e.bones / 2),
                    (this.gameModel.persistentData.runes.death.bones += e.bones / 2),
                    (e.blood = 0),
                    (e.brains = 0),
                    (e.bones = 0),
                    this.updateRuneEffects());
        }
        shatterPercent(e) {
            const t = 1e8 * Math.pow(1.5, this.gameModel.persistentData.runeshatter);
            return Math.floor(100 * Math.min(1, e.blood / t));
        }
        shatterBloodCost(e) {
            return Math.max(0, 1e8 * Math.pow(1.5, this.gameModel.persistentData.runeshatter) - e.blood);
        }
        shatterEffect() {
            return Math.pow(1.1, this.gameModel.persistentData.runeshatter);
        }
        canShatter() {
            return !!this.gameModel.persistentData.runes && this.shatterPercent(this.gameModel.persistentData.runes.life) + this.shatterPercent(this.gameModel.persistentData.runes.death) == 200;
        }
        doShatter() {
            this.canShatter() &&
                (this.gameModel.persistentData.runeshatter++,
                    (this.gameModel.persistentData.runes.life.blood = 0),
                    (this.gameModel.persistentData.runes.death.blood = 0),
                    (this.gameModel.persistentData.runes.life.brains = 0),
                    (this.gameModel.persistentData.runes.death.brains = 0),
                    (this.gameModel.persistentData.runes.life.bones = 0),
                    (this.gameModel.persistentData.runes.death.bones = 0),
                    this.updateRuneEffects(),
                    this.applyUpgrades());
        }
        infuseRune(e, t, s) {
            const i = "life" == e ? this.gameModel.persistentData.runes.life : this.gameModel.persistentData.runes.death;
            switch (t) {
                case "blood":
                    this.gameModel.persistentData.blood >= s && ((i.blood += s), (this.gameModel.persistentData.blood -= s));
                    break;
                case "brains":
                    this.gameModel.persistentData.brains >= s && ((i.brains += s), (this.gameModel.persistentData.brains -= s));
                    break;
                case "bones":
                    this.gameModel.persistentData.bones >= s && ((i.bones += s), (this.gameModel.persistentData.bones -= s));
            }
            this.updateRuneEffects();
        }
        updateRuneEffects() {
            if (!this.gameModel.persistentData.runes) return;
            const e = { attackSpeed: 1, critChance: 0, critDamage: 1, damageReduction: 1, healthRegen: 0, damageReflection: 0 };
            for (let t = 0; t < this.runeCalculations.length; t++) {
                const s = this.runeCalculations[t],
                    i = this.gameModel.persistentData.runes[s.rune][s.cost];
                if (i > 0) {
                    let t = (Math.log(i) / Math.log(s.logBase) + s.adjustment) / 100;
                    t > 0 && (s.cap && t > s.cap && (t = s.cap), s.subtract ? (e[s.effect] -= t) : (e[s.effect] += t));
                }
            }
            this.gameModel.runeEffects = e;
        }
    }
    class he {
        constructor(e, t, s, i, a, r, n, o, h, l, d) {
            (this.id = e), (this.name = t), (this.type = s), (this.costs = i), (this.time = a), (this.multiplier = r), (this.effect = n), (this.cap = o), (this.requires = h), (this.description = l), (this.completeMessage = d);
        }
    }
    class le {
        constructor(e, t, s, i, a, r, n, o, h, l, d) {
            (this.id = e),
                (this.name = t),
                (this.type = s),
                (this.costType = i),
                (this.basePrice = a),
                (this.multiplier = r),
                (this.effect = n),
                (this.cap = o),
                (this.description = h),
                (this.rank = 1),
                (this.purchaseMessage = l),
                (this.requires = d);
        }
    }
    class de {
        constructor() {
            if (
                ((this.gameModel = ne.getInstance()),
                    (this.upgrades = new oe()),
                    (this.trophyStats = [
                        { type: this.upgrades.types.health, value: 50, percentage: !1 },
                        { type: this.upgrades.types.damage, value: 7, percentage: !1 },
                        { type: this.upgrades.types.energyCap, value: 10, percentage: !1 },
                        { type: this.upgrades.types.energyRate, value: 0.5, percentage: !1 },
                        { type: this.upgrades.types.plagueTicks, value: 1, percentage: !1, static: !0 },
                        { type: this.upgrades.types.plagueDamage, value: 50, percentage: !1 },
                        { type: this.upgrades.types.bloodCap, value: 5e3, percentage: !1 },
                        { type: this.upgrades.types.brainsRate, value: 2, percentage: !1 },
                        { type: this.upgrades.types.zombieHealthPC, value: 0.02, percentage: !0 },
                        { type: this.upgrades.types.bonesRate, value: 2, percentage: !1 },
                        { type: this.upgrades.types.zombieDmgPC, value: 0.02, percentage: !0 },
                    ]),
                    de.instance)
            )
                return de.instance;
            de.instance = this;
        }
        isPercentage(e) {
            for (let t = 0; t < this.trophyStats.length; t++) if (this.trophyStats[t].type == e) return 1 == this.trophyStats[t].percentage;
        }
        doesLevelHaveTrophy(e) {
            return !((this.gameModel.persistentData.vipEscaped && this.gameModel.persistentData.vipEscaped.includes(e)) || (this.gameModel.persistentData.trophies && this.gameModel.persistentData.trophies.includes(e)) || e % 5 != 0);
        }
        createTrophy(e, t, s) {
            const i = Math.round(e / 5) - 1,
                a = Math.floor(i / this.trophyStats.length),
                r = this.trophyStats[i - a * this.trophyStats.length];
            return { level: e, type: r.type, effect: r.static ? r.value : r.value * (a + 1), rank: 1, owned: t, escaped: s };
        }
        trophyAquired(e) {
            this.gameModel.persistentData.trophies || (this.gameModel.persistentData.trophies = []),
                this.gameModel.persistentData.trophies.includes(e)
                    ? this.gameModel.sendMessage("The VIP has been killed!")
                    : (this.gameModel.persistentData.trophies.push(e),
                        this.gameModel.persistentData.trophies.sort(),
                        this.gameModel.saveData(),
                        this.upgrades.applyUpgrades(),
                        window.kongregate && window.kongregate.stats.submit("trophies", this.gameModel.persistentData.trophies.length),
                        this.gameModel.sendMessage("The VIP has been killed! - New Trophy Aquired"));
        }
        getTrophyList() {
            this.gameModel.persistentData.trophies || (this.gameModel.persistentData.trophies = []), this.gameModel.persistentData.vipEscaped || (this.gameModel.persistentData.vipEscaped = []);
            const e = [];
            let t = this.gameModel.persistentData.allTimeHighestLevel + 5;
            for (let e = 0; e < this.gameModel.persistentData.trophies.length; e++) this.gameModel.persistentData.trophies[e] > t && (t = this.gameModel.persistentData.trophies[e]);
            for (let s = 5; s <= t; s += 5) e.push(this.createTrophy(s, this.gameModel.persistentData.trophies.includes(s), this.gameModel.persistentData.vipEscaped.includes(s)));
            return e;
        }
        getTrophyTotals() {
            const e = this.getTrophyList().filter((e) => e.owned),
                t = [];
            for (let s = 0; s < e.length; s++)
                0 == t.filter((t) => t.type == e[s].type).length
                    ? t.push(e[s])
                    : this.isPercentage(e[s].type)
                        ? (t.filter((t) => t.type == e[s].type)[0].effect = (t.filter((t) => t.type == e[s].type)[0].effect + 1) * (1 + e[s].effect) - 1)
                        : (t.filter((t) => t.type == e[s].type)[0].effect += e[s].effect);
            return t;
        }
        getAquiredTrophyList() {
            this.gameModel.persistentData.trophies || (this.gameModel.persistentData.trophies = []);
            const e = [];
            for (let t = 0; t < this.gameModel.persistentData.trophies.length; t++) e.push(this.createTrophy(this.gameModel.persistentData.trophies[t], !0, !1));
            return e;
        }
    }
    var ce, ue, pe, ge, me, be;
    !(function (e) {
        (e[(e.standing = 0)] = "standing"), (e[(e.walking = 1)] = "walking"), (e[(e.attacking = 2)] = "attacking"), (e[(e.fleeing = 3)] = "fleeing"), (e[(e.escaping = 4)] = "escaping");
    })(ce || (ce = {}));
    class fe extends PIXI.Text {
        constructor() {
            super(...arguments), (this.human = null), (this.yOffset = 0);
        }
    }
    class ye extends $ {
        constructor() {
            super(...arguments), (this.flee = 0), (this.standing = 0), (this.target = 0), (this.plagueTick = 0), (this.healTick = 0);
        }
    }
    class xe extends K {
        constructor() {
            super(...arguments), (this.dog = !1), (this.doctor = !1), (this.tank = !1), (this.vip = !1), (this.torchBearer = !1);
        }
    }
    class ve extends Q {
        constructor() {
            super(...arguments),
                (this.maxSpeed = 0),
                (this.flags = new xe()),
                (this.target = null),
                (this.speedMod = 0),
                (this.human = !0),
                (this.plagueTicks = 0),
                (this.plagueDamage = 0),
                (this.visionDistance = 0),
                (this.timer = new ye());
        }
    }
    class HumanManager {
        constructor() {
            if (
                ((this.maxWalkSpeed = 15),
                    (this.maxRunSpeed = 35),
                    (this.minSecondsTostand = 1),
                    (this.maxSecondsToStand = 60),
                    (this.chanceToStayInCurrentBuilding = 0.95),
                    (this.textures = []),
                    (this.doctorTextures = []),
                    (this.humans = []),
                    (this.discardedHumans = []),
                    (this.aliveHumans = []),
                    (this.graveyardAttackers = []),
                    (this.humansPerLevel = 50),
                    (this.maxHumans = 1e3),
                    (this.scaling = 2),
                    (this.visionDistance = 60),
                    (this.vipEscaping = !1),
                    (this.fleeChancePerZombie = 0.1),
                    (this.fleeTime = 10),
                    (this.scanTime = 3),
                    (this.attackDistance = 20),
                    (this.moveTargetDistance = 3),
                    (this.attackSpeed = 2),
                    (this.attackDamage = 5),
                    (this.fadeSpeed = 0.1),
                    (this.plagueTickTimer = 5),
                    (this.healTickTimer = 5),
                    (this.burnTickTimer = 5),
                    (this.smokeTimer = 0.3),
                    (this.fastDistance = i),
                    (this.frozen = !1),
                    (this.pandemic = !1),
                    (this.graveYardPosition = null),
                    (this.drawTargets = !1),
                    HumanManager.instance)
            )
                return HumanManager.instance;
            HumanManager.instance = this;
        }
        randomSecondsToStand() {
            return this.minSecondsTostand + Math.random() * (this.maxSecondsToStand - this.minSecondsTostand);
        }
        damageHuman(e, t) {
            this.gameModel.addBlood(Math.round(t / 3)),
                (e.health -= t),
                (e.timer.scan = 0),
                e.flags.tank ? this.fragments.newPart(e.x, e.y - 18, 8086798) : (this.blood.newSplatter(e.x, e.y), (e.speedMod = Math.max(Math.min(1, e.health / e.maxHealth), 0.25))),
                e.health <= 0 &&
                !e.flags.dead &&
                (this.bones.newBones(e.x, e.y),
                    (e.flags.dead = !0),
                    this.gameModel.addBrains(1),
                    this.skeleton.addXp(this.gameModel.level),
                    this.skeleton.testForLoot(),
                    e.flags.tank ? (this.blasts.newDroneBlast(e.x, e.y - 5), this.fragments.newFragmentExplosion(e.x, e.y - 5, 8086798), (e.visible = !1)) : (e.textures = e.deadTexture),
                    e.flags.vip &&
                    ((this.vipText.visible = !1),
                        this.trophies.trophyAquired(this.gameModel.level),
                        setTimeout(() => {
                            this.vipEscaping = !1;
                        }, 2e3))),
                this.army.assaultStarted || (Math.random() > 0.9 && this.gameModel.isBossStage(this.gameModel.level) && ((this.army.assaultStarted = !0), this.gameModel.sendMessage("The assault has begun!")));
        }
        updateBurns(e, t) {
            (e.timer.burnTick -= t),
                (e.timer.smoke -= t),
                e.timer.smoke < 0 && (this.smoke.newFireSmoke(e.x, e.y - 14), (e.timer.smoke = this.smokeTimer)),
                e.timer.burnTick < 0 && (this.damageHuman(e, e.burnDamage), (e.timer.burnTick = this.burnTickTimer), this.exclamations.newFire(e));
        }
        assignRandomTarget(e) {
            (Math.random() > this.chanceToStayInCurrentBuilding || e.timer.flee > 0) && (e.currentPoi = this.map.getRandomBuilding()),
                (e.target = this.map.randomPositionInBuilding(e.currentPoi)),
                (e.maxSpeed = e.timer.flee > 0 ? this.maxRunSpeed : this.maxWalkSpeed),
                (e.xSpeed = 0),
                (e.ySpeed = 0);
        }
        getMaxNpcs() {
            return Math.min(this.humansPerLevel * this.gameModel.level, this.maxHumans);
        }
        getMaxHumans() {
            return this.gameModel.isBossStage(this.gameModel.level) ? 0 : this.getMaxNpcs() - (this.police.police.length + this.army.armymen.length);
        }
        getMaxDoctors() {
            return this.gameModel.level < 18 ? 0 : Math.min(Math.round(0.7 * this.gameModel.level), 75);
        }
        getTorchChance() {
            return this.gameModel.level < 10 ? 0 : 0.02 * Math.min(this.gameModel.level - 10, 40);
        }
        getMaxHealth(e) {
            return e < 7
                ? 10 * (e + 4)
                : e < 12
                    ? 20 * (e - 1)
                    : e < 16
                        ? 25 * (e - 3)
                        : e < 29
                            ? 50 * (e - 9)
                            : e < 49
                                ? 100 * (e - 19)
                                : e < 64
                                    ? 300 * (e - 39)
                                    : e < 85
                                        ? 500 * (e - 49)
                                        : e > 499
                                            ? 85e5 * Math.pow(1.03, e - 499)
                                            : 17800 * Math.pow(1.015, e - 84);
        }
        getAttackDamage() {
            1 != this.gameModel.level
                ? 2 != this.gameModel.level
                    ? 3 != this.gameModel.level
                        ? (this.attackDamage = Math.round(this.getMaxHealth(this.gameModel.level) / 10))
                        : (this.attackDamage = 5)
                    : (this.attackDamage = 4)
                : (this.attackDamage = 2);
        }
        setupVipText(e) {
            this.vipText ||
                ((this.vipText = new fe("VIP", { fontFamily: "sans-serif", fontSize: 64, fill: "#FC0", stroke: "#000", strokeThickness: 5, align: "center" })),
                    this.vipText.anchor.set(0.5, 1),
                    (this.vipText.scale.x = 0.25),
                    (this.vipText.scale.y = 0.25),
                    b.addChild(this.vipText)),
                (this.vipText.visible = !0),
                (this.vipText.human = e),
                (this.vipText.yOffset = -20),
                (this.vipText.x = e.x),
                (this.vipText.y = e.y + this.vipText.yOffset);
        }
        populate() {
            if (
                ((this.map = new MapManager()),
                    (this.zombies = new ZombieManager()),
                    (this.gameModel = ne.getInstance()),
                    (this.blood = new _e()),
                    (this.smoke = new ot()),
                    (this.bones = new tt()),
                    (this.skeleton = new Xe()),
                    (this.blasts = new nt()),
                    (this.fragments = new lt()),
                    (this.trophies = new de()),
                    (this.exclamations = new it()),
                    (this.bullets = new rt()),
                    (this.police = new PoliceManager()),
                    (this.army = new Te()),
                    (this.tanks = new De()),
                    this.map.populatePois(),
                    0 == this.textures.length)
            )
                for (let e = 0; e < 6; e++) {
                    const t = [];
                    for (let s = 0; s < 3; s++) t.push(PIXI.Texture.from("human" + (e + 1) + "_" + (s + 1) + ".png"));
                    this.textures.push({ animated: t, dead: [PIXI.Texture.from("human" + (e + 1) + "_dead.png")] });
                }
            if (0 == this.doctorTextures.length) {
                for (let e = 0; e < 3; e++) this.doctorTextures.push(PIXI.Texture.from("doctor" + (e + 1) + ".png"));
                this.doctorDeadTexture = [PIXI.Texture.from("doctor4.png")];
            }
            if (this.humans.length > 0) {
                for (let e = 0; e < this.humans.length; e++) g.removeChild(this.humans[e]), this.humans[e].stop();
                (this.discardedHumans = this.humans.slice()), (this.humans.length = 0), (this.aliveHumans.length = 0);
            }
            this.police.populate(), this.army.populate(), this.tanks.populate(), this.getAttackDamage();
            const e = this.getMaxHumans();
            let t = this.getMaxDoctors();
            const s = this.getMaxHealth(this.gameModel.level);
            let i = this.trophies.doesLevelHaveTrophy(this.gameModel.level);
            (this.vip = void 0), i ? (this.escapeTarget = { x: P.x / 2, y: P.y + 50 }) : this.vipText && (this.vipText.visible = !1);
            for (let a = 0; a < e; a++) {
                let e;
                if (t > 0)
                    this.discardedHumans.length > 0 ? ((e = this.discardedHumans.pop()), (e.textures = this.doctorTextures)) : (e = new ve(this.doctorTextures)),
                        (e.deadTexture = this.doctorDeadTexture),
                        (e.flags.doctor = !0),
                        (e.flags.torchBearer = !1),
                        (e.timer.healTick = Math.random() * this.healTickTimer),
                        t--;
                else {
                    const t = Math.random() < this.getTorchChance(),
                        s = Math.floor(3 * Math.random()) + (t ? 3 : 0);
                    this.discardedHumans.length > 0 ? ((e = this.discardedHumans.pop()), (e.textures = this.textures[s].animated)) : (e = new ve(this.textures[s].animated)),
                        (e.flags.torchBearer = t),
                        (e.deadTexture = this.textures[s].dead),
                        (e.flags.doctor = !1);
                }
                e.reset(),
                    (e.flags.vip = !1),
                    (e.flags.dead = !1),
                    (e.flags.burning = !1),
                    (e.flags.infected = !1),
                    (e.burnDamage = 0),
                    (e.plagueDamage = 0),
                    (e.plagueTicks = 0),
                    (e.animationSpeed = 0.15),
                    e.anchor.set(35 / 80, 1),
                    (e.currentPoi = this.map.getRandomBuilding()),
                    e.position.copyFrom(this.map.randomPositionInBuilding(e.currentPoi)),
                    (e.zIndex = e.position.y),
                    (e.xSpeed = 0),
                    (e.ySpeed = 0),
                    (e.timer.plagueTick = Math.random() * this.plagueTickTimer),
                    (e.target = !1),
                    (e.speedMod = 1),
                    (e.zombieTarget = null),
                    (e.lastKnownBuilding = null),
                    (e.visionDistance = this.visionDistance),
                    (e.visible = !0),
                    (e.alpha = 1),
                    (e.maxHealth = e.health = s),
                    i && !e.flags.doctor && ((e.flags.vip = !0), (this.vip = e), (i = !1), (e.maxHealth = e.health = 2 * s), this.setupVipText(e)),
                    (e.timer.scan = Math.random() * this.scanTime),
                    (e.timer.flee = 0),
                    this.changeState(e, ce.standing),
                    (e.timer.standing = Math.random() * this.randomSecondsToStand()),
                    (e.timer.attack = this.attackSpeed),
                    e.scale.set(Math.random() > 0.5 ? this.scaling : -1 * this.scaling, this.scaling),
                    this.humans.push(e),
                    g.addChild(e);
            }
        }
        updateHumanSpeed(e, t) {
            if (this.frozen) return void e.gotoAndStop(0);
            if ((e.playing || e.play(), e.timer.dogStun && e.timer.dogStun > 0)) return void (e.timer.dogStun -= t);
            (0 == e.timer.target && e.targetVector) || (e.timer.target = 0), (e.timer.target -= t), e.timer.target <= 0 && ((e.targetVector = this.map.howDoIGetToMyTarget(e, e.target)), (e.timer.target = 0.2));
            const s = e.speedMod * e.maxSpeed;
            (e.xSpeed = e.targetVector.x * s),
                (e.ySpeed = e.targetVector.y * s),
                (isNaN(e.xSpeed) || isNaN(e.ySpeed)) && ((e.xSpeed = 0), (e.ySpeed = 0)),
                (e.position.x += e.xSpeed * t),
                (e.position.y += e.ySpeed * t),
                (e.zIndex = e.position.y),
                Math.abs(e.xSpeed) > 1 && !e.flags.tank && (e.scale.x = e.xSpeed > 0 ? this.scaling : -this.scaling);
        }
        update(e) {
            if (this.gameModel.currentState != this.gameModel.states.playingLevel) return;
            const t = [],
                s = this.zombies.aliveZombies;
            this.graveyardAttackers.length = 0;
            for (let i = 0; i < this.humans.length; i++) this.updateHuman(this.humans[i], e, s), this.humans[i].flags.dead || t.push(this.humans[i]);
            (this.aliveHumans = t),
                (this.gameModel.stats.human.count = this.aliveHumans.length),
                this.police.update(e, s),
                this.army.update(e, s),
                this.tanks.update(e, s),
                this.vipText && this.vipText.visible && ((this.vipText.x = this.vipText.human.x), (this.vipText.y = this.vipText.human.y + this.vipText.yOffset)),
                (this.gameModel.humanCount = this.aliveHumans.length);
        }
        updateDeadHumanFading(e, t) {
            if (e.visible) {
                if (e.alpha > 0.5 && e.alpha - this.fadeSpeed * t <= 0.5 && !e.flags.tank && Math.random() < this.gameModel.riseFromTheDeadChance)
                    return this.zombies.createZombie(e.x, e.y, e.flags.dog), (e.visible = !1), void g.removeChild(e);
                (e.alpha -= this.fadeSpeed * t), e.alpha < 0 && ((e.visible = !1), g.removeChild(e));
            }
        }
        changeState(e, t) {
            switch (t) {
                case ce.standing:
                    e.gotoAndStop(0), (e.maxSpeed = this.maxWalkSpeed), (e.timer.standing = this.randomSecondsToStand());
                    break;
                case ce.walking:
                    e.play(), (e.maxSpeed = this.maxWalkSpeed);
                    break;
                case ce.fleeing:
                    e.play(), (e.timer.flee = this.fleeTime), (e.maxSpeed = this.maxRunSpeed), this.assignRandomTarget(e), this.exclamations.newExclamation(e);
                    break;
                case ce.escaping:
                    e.play(), (e.maxSpeed = this.maxRunSpeed), (e.target = this.escapeTarget), this.exclamations.newExclamation(e), this.gameModel.sendMessage("The VIP is escaping!"), (this.vipEscaping = !0);
                    break;
                case ce.attacking:
                    e.play(), (e.maxSpeed = this.maxRunSpeed);
            }
            e.state = t;
        }
        inflictBurn(e, t) {
            e.flags.torchBearer && (t.flags.burning ? (t.burnDamage += this.attackDamage) : (this.exclamations.newFire(t), (t.burnDamage = this.attackDamage)), (t.flags.burning = !0));
        }
        burnHuman(e, t) {
            e && (e.flags.burning ? (e.burnDamage += t) : ((e.timer.burnTick = this.burnTickTimer), (e.timer.smoke = this.smokeTimer), this.exclamations.newFire(e), (e.burnDamage = t)), (e.flags.burning = !0));
        }
        updatePlague(e, t) {
            (e.timer.plagueTick -= t),
                e.timer.plagueTick < 0 &&
                (this.damageHuman(e, e.plagueDamage),
                    (e.timer.plagueTick = this.plagueTickTimer * (1 / this.gameModel.runeEffects.attackSpeed)),
                    this.exclamations.newPoison(e),
                    e.plagueTicks--,
                    this.pandemic && this.pandemicBullet(e),
                    e.plagueTicks <= 0 && ((e.flags.infected = !1), (e.plagueDamage = 0)));
        }
        pandemicBullet(e) {
            for (let t = 0; t < this.aliveHumans.length; t++)
                Math.abs(this.aliveHumans[t].x - e.x) < 30 && Math.abs(this.aliveHumans[t].y - e.y) < 30 && Math.random() < 0.3 && this.bullets.newBullet(e, this.aliveHumans[t], this.gameModel.zombieDamage / 2, !0);
        }
        healHuman(e) {
            e.health < e.maxHealth &&
                (e.flags.infected && e.plagueTicks > 0 && e.plagueTicks--,
                    (e.health += 2 * this.attackDamage),
                    e.health > e.maxHealth && ((e.health = e.maxHealth), (e.speedMod = Math.max(Math.min(1, e.health / e.maxHealth), 0.25))),
                    this.exclamations.newHealing(e));
        }
        doHeal(e, t) {
            if (((e.timer.healTick -= t), e.timer.healTick < 0)) {
                const t = 100;
                e.timer.healTick = this.healTickTimer;
                for (let s = 0; s < this.aliveHumans.length; s++)
                    Math.abs(this.aliveHumans[s].x - e.x) < t && Math.abs(this.aliveHumans[s].y - e.y) < t && this.fastDistance(e.x, e.y, this.aliveHumans[s].x, this.aliveHumans[s].y) < t && this.healHuman(this.aliveHumans[s]);
            }
        }
        updateHuman(e, t, s) {
            if (e.flags.dead) return this.updateDeadHumanFading(e, t);
            if (
                ((e.timer.attack -= t),
                    (e.timer.scan -= t),
                    (e.timer.flee -= t),
                    e.flags.infected && this.updatePlague(e, t),
                    e.flags.doctor && this.doHeal(e, t),
                    e.flags.burning && this.updateBurns(e, t),
                    (!e.zombieTarget || e.zombieTarget.flags.dead) && e.timer.scan < 0)
            ) {
                const t = this.scanForZombies(e, s);
                t > 0 &&
                    (e.flags.vip
                        ? e.state !== ce.escaping && this.changeState(e, ce.escaping)
                        : Math.random() < t * this.fleeChancePerZombie
                            ? this.changeState(e, ce.fleeing)
                            : ((e.target = e.zombieTarget), this.changeState(e, ce.attacking)));
            }
            switch (e.state) {
                case ce.standing:
                    (e.timer.standing -= t), e.timer.standing < 0 && (this.assignRandomTarget(e), this.changeState(e, ce.walking));
                    break;
                case ce.walking:
                case ce.fleeing:
                    this.fastDistance(e.position.x, e.position.y, e.target.x, e.target.y) < this.moveTargetDistance ? ((e.target = void 0), (e.zombieTarget = void 0), this.changeState(e, ce.standing)) : this.updateHumanSpeed(e, t);
                    break;
                case ce.escaping:
                    this.fastDistance(e.position.x, e.position.y, e.target.x, e.target.y) < this.moveTargetDistance
                        ? (this.smoke.newDroneCloud(e.x, e.y),
                            (e.flags.dead = !0),
                            (e.zombieTarget = void 0),
                            (e.visible = !1),
                            (this.vipText.visible = !1),
                            this.gameModel.sendMessage("The VIP has escaped!"),
                            this.gameModel.vipEscaped(),
                            setTimeout(() => {
                                this.vipEscaping = !1;
                            }, 2e3))
                        : this.updateHumanSpeed(e, t);
                    break;
                case ce.attacking:
                    (e.scale.x = e.target.x > e.x ? this.scaling : -this.scaling),
                        e.zombieTarget && !e.zombieTarget.flags.dead
                            ? this.fastDistance(e.position.x, e.position.y, e.target.x, e.target.y) < this.attackDistance
                                ? e.timer.attack < 0 && (this.zombies.damageZombie(e.zombieTarget, this.attackDamage, e), this.inflictBurn(e, e.zombieTarget), (e.timer.attack = this.attackSpeed))
                                : this.updateHumanSpeed(e, t)
                            : this.changeState(e, ce.standing);
            }
        }
        scanForZombies(e, t) {
            e.timer.scan = this.scanTime;
            let s = 0;
            for (let i = 0; i < t.length; i++) if (!t[i].flags.dead && Math.abs(t[i].x - e.x) < e.visionDistance && Math.abs(t[i].y - e.y) < e.visionDistance && ((e.zombieTarget = t[i]), s++, s > 9)) return s;
            return s;
        }
    }
    class Me extends ve {
        constructor() {
            super(...arguments), (this.radioTime = 0), (this.followTimer = 0);
        }
    }
    !(function (e) {
        (e[(e.shooting = 0)] = "shooting"),
            (e[(e.attacking = 1)] = "attacking"),
            (e[(e.walking = 2)] = "walking"),
            (e[(e.running = 3)] = "running"),
            (e[(e.standing = 4)] = "standing"),
            (e[(e.following = 5)] = "following"),
            (e[(e.hunting = 6)] = "hunting");
    })(ue || (ue = {}));
    class PoliceManager {
        constructor() {
            if (
                ((this.maxWalkSpeed = 15),
                    (this.maxRunSpeed = 40),
                    (this.police = []),
                    (this.discardedPolice = []),
                    (this.walkTexture = []),
                    (this.deadTexture = []),
                    (this.dogTexture = []),
                    (this.deadDogTexture = []),
                    (this.policeDogLevel = 20),
                    (this.policePerLevel = 1),
                    (this.attackSpeed = 2),
                    (this.attackDamage = 16),
                    (this.attackDistance = 20),
                    (this.moveTargetDistance = 5),
                    (this.shootDistance = 110),
                    (this.visionDistance = 150),
                    (this.scaling = 2),
                    (this.dogScaling = 1.3),
                    (this.radioTime = 30),
                    PoliceManager.instance)
            )
                return PoliceManager.instance;
            PoliceManager.instance = this;
        }
        isExtraPolice() {
            return (this.gameModel.level + 10) % 20 == 0;
        }
        getMaxPolice() {
            const e = Math.min(Math.round(this.policePerLevel * this.gameModel.level), 100);
            return this.gameModel.level < 3 ? 0 : this.isExtraPolice() ? Math.max(2 * e, 150) : e;
        }
        getMaxHealth() {
            return Math.round(1.1 * this.humans.getMaxHealth(this.gameModel.level));
        }
        getAttackDamage() {
            this.attackDamage = Math.round(this.getMaxHealth() / 10);
        }
        populate() {
            if (((this.map = new MapManager()), (this.gameModel = ne.getInstance()), (this.humans = new HumanManager()), (this.exclamations = new it()), (this.zombies = new ZombieManager()), (this.bullets = new rt()), 0 == this.walkTexture.length)) {
                for (let e = 0; e < 3; e++) this.walkTexture.push(PIXI.Texture.from("cop" + (e + 1) + ".png"));
                this.deadTexture = [PIXI.Texture.from("cop4.png")];
                for (let e = 0; e < 2; e++) this.dogTexture.push(PIXI.Texture.from("dog" + (e + 1) + ".png"));
                this.deadDogTexture = [PIXI.Texture.from("dogdead.png")];
            }
            if (this.police.length > 0) {
                for (let e = 0; e < this.police.length; e++) g.removeChild(this.police[e]);
                (this.discardedPolice = this.police.slice()), (this.police = []);
            }
            const e = this.getMaxPolice(),
                t = this.getMaxHealth(),
                s = 0.6 * t;
            this.getAttackDamage();
            for (let i = 0; i < e; i++) {
                let e;
                this.discardedPolice.length > 0 ? ((e = this.discardedPolice.pop()), (e.alpha = 1), (e.textures = this.walkTexture)) : (e = new Me(this.walkTexture)),
                    e.reset(),
                    (e.flags.dog = !1),
                    (e.flags.dead = !1),
                    (e.flags.infected = !1),
                    (e.flags.burning = !1),
                    (e.burnDamage = 0),
                    (e.plagueDamage = 0),
                    (e.plagueTicks = 0),
                    (e.deadTexture = this.deadTexture),
                    (e.animationSpeed = 0.2),
                    e.anchor.set(35 / 80, 1),
                    (e.currentPoi = this.map.getRandomBuilding()),
                    e.position.copyFrom(this.map.randomPositionInBuilding(e.currentPoi)),
                    (e.zIndex = e.position.y),
                    (e.xSpeed = 0),
                    (e.ySpeed = 0),
                    (e.radioTime = 5),
                    (e.speedMod = 1),
                    (e.lastKnownBuilding = void 0),
                    (e.timer.plagueTick = Math.random() * this.humans.plagueTickTimer),
                    (e.maxSpeed = this.maxWalkSpeed),
                    (e.visionDistance = this.visionDistance),
                    (e.visible = !0),
                    (e.maxHealth = e.health = t),
                    (e.timer.scan = Math.random() * this.humans.scanTime),
                    (e.timer.standing = Math.random() * this.humans.randomSecondsToStand()),
                    (e.target = !1),
                    (e.zombieTarget = void 0),
                    (e.policeState = ue.standing),
                    (e.timer.attack = this.attackSpeed),
                    e.scale.set(Math.random() > 0.5 ? this.scaling : -1 * this.scaling, this.scaling),
                    this.police.push(e),
                    g.addChild(e),
                    this.gameModel.level >= this.policeDogLevel && Math.random() > 0.5 && this.createPoliceDog(e, s);
            }
            this.isExtraPolice() && this.gameModel.sendMessage("Warning: High Police Activity!");
        }
        createPoliceDog(e, t) {
            let s;
            this.discardedPolice.length > 0 ? ((s = this.discardedPolice.pop()), (s.alpha = 1), (s.textures = this.dogTexture)) : (s = new Me(this.dogTexture)),
                s.reset(),
                (s.owner = e),
                (s.flags.dog = !0),
                (s.flags.dead = !1),
                (s.flags.infected = !1),
                (s.flags.burning = !1),
                (s.burnDamage = 0),
                (s.plagueDamage = 0),
                (s.plagueTicks = 0),
                (s.deadTexture = this.deadDogTexture),
                (s.animationSpeed = 0.15),
                s.anchor.set(0.5, 1),
                s.position.set(e.position.x + 3, e.position.y),
                (s.zIndex = s.position.y),
                (s.xSpeed = 0),
                (s.ySpeed = 0),
                (s.speedMod = 1),
                (s.lastKnownBuilding = null),
                (s.timer.plagueTick = Math.random() * this.humans.plagueTickTimer),
                (s.maxSpeed = this.maxRunSpeed),
                (s.visionDistance = this.visionDistance),
                (s.visible = !0),
                (s.maxHealth = s.health = t),
                (s.timer.scan = Math.random() * this.humans.scanTime),
                (s.target = e),
                (s.zombieTarget = null),
                (s.policeState = ue.following),
                (s.followTimer = 0),
                (s.timer.attack = this.attackSpeed),
                s.scale.set(Math.random() > 0.5 ? this.dogScaling : -1 * this.dogScaling, this.dogScaling),
                this.police.push(s),
                g.addChild(s);
        }
        update(e, t) {
            let s = 0;
            for (let i = 0; i < this.police.length; i++)
                this.police[i].flags.dog ? this.updatePoliceDog(this.police[i], e, t) : this.updatePolice(this.police[i], e, t), this.police[i].flags.dead || (this.humans.aliveHumans.push(this.police[i]), s++);
            this.gameModel.stats.police.count = s;
        }
        decideStateOnZombieDistance(e) {
            if (e.zombieTarget && !e.zombieTarget.flags.dead) {
                e.target = e.zombieTarget;
                const t = i(e.position.x, e.position.y, e.zombieTarget.x, e.zombieTarget.y);
                if (t > this.shootDistance) return void this.changeState(e, ue.running);
                if (t < this.attackDistance) return void this.changeState(e, ue.attacking);
                this.changeState(e, ue.shooting);
            }
        }
        changeState(e, t) {
            switch (t) {
                case ue.standing:
                    e.gotoAndStop(0);
                    break;
                case ue.walking:
                    e.play(), (e.maxSpeed = this.maxWalkSpeed);
                    break;
                case ue.running:
                    e.play(), (e.maxSpeed = this.maxRunSpeed);
                    break;
                case ue.shooting:
                    e.gotoAndStop(0);
                    break;
                case ue.attacking:
                    e.play();
            }
            e.policeState = t;
        }
        radioForBackup(e) {
            let t = null,
                s = 2e3;
            for (let a = 0; a < this.police.length; a++)
                if (!this.police[a].flags.dead && !this.police[a].flags.dog && (!this.police[a].zombieTarget || this.police[a].zombieTarget.flags.dead)) {
                    const r = i(e.x, e.y, this.police[a].x, this.police[a].y);
                    r < s && ((t = this.police[a]), (s = r));
                }
            t && ((t.zombieTarget = e.zombieTarget), this.exclamations.newRadio(e), this.exclamations.newRadio(t), (e.radioTime = this.radioTime), (t.radioTime = this.radioTime));
        }
        updatePolice(e, t, s) {
            if (e.flags.dead) return this.humans.updateDeadHumanFading(e, t);
            switch (
            ((e.timer.attack -= t),
                (e.timer.scan -= t),
                (e.radioTime -= t),
                e.flags.infected && this.humans.updatePlague(e, t),
                e.flags.burning && this.humans.updateBurns(e, t),
                (!e.zombieTarget || e.zombieTarget.flags.dead) && e.timer.scan < 0 && (this.humans.scanForZombies(e, s), e.zombieTarget && !e.zombieTarget.flags.dead && e.radioTime < 0 && this.radioForBackup(e)),
                this.decideStateOnZombieDistance(e),
                e.policeState)
            ) {
                case ue.standing:
                    (e.timer.standing -= t), e.timer.standing < 0 && (this.humans.assignRandomTarget(e), this.changeState(e, ue.walking));
                    break;
                case ue.walking:
                    i(e.position.x, e.position.y, e.target.x, e.target.y) < this.moveTargetDistance
                        ? ((e.target = !1), (e.zombieTarget = null), (e.timer.standing = this.humans.randomSecondsToStand()), this.changeState(e, ue.standing))
                        : this.humans.updateHumanSpeed(e, t);
                    break;
                case ue.running:
                    e.zombieTarget && !e.zombieTarget.flags.dead ? e.target && this.humans.updateHumanSpeed(e, t) : this.changeState(e, ue.standing);
                    break;
                case ue.attacking:
                    e.zombieTarget && !e.zombieTarget.flags.dead
                        ? ((e.scale.x = e.zombieTarget.x > e.x ? this.scaling : -this.scaling), e.timer.attack < 0 && (this.zombies.damageZombie(e.zombieTarget, this.attackDamage, e), (e.timer.attack = this.attackSpeed)))
                        : this.changeState(e, ue.standing);
                    break;
                case ue.shooting:
                    e.zombieTarget && !e.zombieTarget.flags.dead
                        ? ((e.scale.x = e.zombieTarget.x > e.x ? this.scaling : -this.scaling), e.timer.attack < 0 && (this.bullets.newBullet(e, e.zombieTarget, this.attackDamage), (e.timer.attack = this.attackSpeed)))
                        : this.changeState(e, ue.standing);
            }
        }
        updateDogSpeed(e, t) {
            this.humans.updateHumanSpeed(e, t), Math.abs(e.xSpeed) > 1 && (e.scale.x = e.xSpeed > 0 ? this.dogScaling : -this.dogScaling);
        }
        updatePoliceDog(e, t, s) {
            if (e.flags.dead) return this.humans.updateDeadHumanFading(e, t);
            switch (((e.timer.attack -= t), (e.timer.scan -= t), e.flags.infected && this.humans.updatePlague(e, t), e.flags.burning && this.humans.updateBurns(e, t), e.policeState)) {
                case ue.following:
                    if (e.owner.flags.dead) {
                        (e.policeState = ue.hunting), e.play();
                        break;
                    }
                    if (e.owner.zombieTarget && !e.owner.zombieTarget.flags.dead) {
                        (e.policeState = ue.attacking), e.play(), (e.target = e.owner.zombieTarget);
                        break;
                    }
                    (e.target = e.owner),
                        i(e.position.x, e.position.y, e.target.x, e.target.y) < this.moveTargetDistance
                            ? ((e.followTimer = 3 * Math.random()), e.gotoAndStop(0))
                            : ((e.followTimer -= t), e.followTimer < 0 && (e.play(), this.updateDogSpeed(e, t)));
                    break;
                case ue.attacking:
                    e.zombieTarget && !e.zombieTarget.flags.dead
                        ? i(e.position.x, e.position.y, e.zombieTarget.x, e.zombieTarget.y) < this.moveTargetDistance
                            ? ((e.scale.x = e.target.x > e.x ? this.dogScaling : -this.dogScaling),
                                e.timer.attack < 0 && (this.zombies.damageZombie(e.zombieTarget, this.attackDamage, e), (e.target.dogStun = 1), (e.timer.attack = this.attackSpeed)))
                            : ((e.target = e.zombieTarget), this.updateDogSpeed(e, t))
                        : (e.policeState = ue.following);
                    break;
                case ue.hunting:
                    (!e.zombieTarget || e.zombieTarget.flags.dead) && e.timer.scan < 0 && (this.humans.scanForZombies(e, s), e.zombieTarget && (e.policeState = ue.attacking)),
                        i(e.position.x, e.position.y, e.target.x, e.target.y) < this.moveTargetDistance ? ((e.target = { x: Math.random() * P.x, y: Math.random() * P.y }), (e.maxSpeed = this.maxRunSpeed)) : this.updateDogSpeed(e, t);
            }
        }
    }
    class we extends ve {
        constructor() {
            super(...arguments), (this.minigun = !1), (this.rocketlauncher = !1), (this.attackingGraveyard = !1), (this.shotsLeft = 0), (this.shotTimer = 0);
        }
    }
    !(function (e) {
        (e[(e.shooting = 0)] = "shooting"), (e[(e.attacking = 1)] = "attacking"), (e[(e.walking = 2)] = "walking"), (e[(e.running = 3)] = "running"), (e[(e.standing = 4)] = "standing");
    })(pe || (pe = {}));
    class Te {
        constructor() {
            if (
                ((this.maxWalkSpeed = 20),
                    (this.maxRunSpeed = 50),
                    (this.armymen = []),
                    (this.discardedArmymen = []),
                    (this.textures = []),
                    (this.aliveZombies = []),
                    (this.armyPerLevel = 0.9),
                    (this.attackSpeed = 2),
                    (this.attackDamage = 20),
                    (this.attackDistance = 25),
                    (this.moveTargetDistance = 5),
                    (this.shootDistance = 130),
                    (this.visionDistance = 200),
                    (this.scaling = 2),
                    (this.shotsPerBurst = 3),
                    (this.droneStrikeTimer = 0),
                    (this.droneStrikeTime = 35),
                    (this.assaultStarted = !1),
                    (this.droneStrike = null),
                    (this.droneActive = !1),
                    (this.droneBlastRadius = 35),
                    Te.instance)
            )
                return Te.instance;
            Te.instance = this;
        }
        isExtraArmy() {
            return this.gameModel.level % 20 == 0;
        }
        getMaxArmy() {
            const e = Math.min(Math.round(this.armyPerLevel * this.gameModel.level), 100);
            return this.gameModel.level < 11 ? 0 : this.isExtraArmy() ? Math.max(2 * e, 150) : this.gameModel.isBossStage(this.gameModel.level) ? Math.max(e, 75) : e;
        }
        getMaxHealth() {
            return Math.round(1.2 * this.humans.getMaxHealth(this.gameModel.level));
        }
        getAttackDamage() {
            this.attackDamage = Math.round(this.getMaxHealth() / 10);
        }
        populate() {
            if (
                ((this.map = new MapManager()),
                    (this.zombies = new ZombieManager()),
                    (this.humans = new HumanManager()),
                    (this.gameModel = ne.getInstance()),
                    (this.graveyard = new Oe()),
                    (this.bullets = new rt()),
                    (this.assaultStarted = !1),
                    (this.blasts = new nt()),
                    (this.exclamations = new it()),
                    0 == this.textures.length)
            )
                for (let e = 0; e < 3; e++) {
                    const t = [];
                    for (let s = 0; s < 3; s++) t.push(PIXI.Texture.from("army" + (e + 1) + "_" + (s + 1) + ".png"));
                    this.textures.push({ animated: t, dead: [PIXI.Texture.from("army" + (e + 1) + "_dead.png")] });
                }
            if ((this.droneStrike && this.droneStrike.laser && (b.removeChild(this.droneStrike.text), b.removeChild(this.droneStrike.laser)), this.armymen.length > 0)) {
                for (let e = 0; e < this.armymen.length; e++) g.removeChild(this.armymen[e]);
                (this.discardedArmymen = this.armymen.slice()), (this.armymen = []);
            }
            const e = this.getMaxArmy(),
                t = this.getMaxHealth();
            this.getAttackDamage(), (this.droneStrike = !1), (this.droneStrikeTimer = Math.random() * this.droneStrikeTime), (this.droneActive = this.gameModel.level >= 25);
            for (let s = 0; s < e; s++) {
                let e,
                    s = 0;
                this.gameModel.level > 35 && Math.random() < 0.3 && (s = 1),
                    ((this.gameModel.level > 45 && Math.random() < 0.3) || (this.gameModel.isBossStage(this.gameModel.level) && Math.random() < 0.5)) && (s = 2),
                    this.discardedArmymen.length > 0 ? ((e = this.discardedArmymen.pop()), (e.alpha = 1), (e.textures = this.textures[s].animated)) : (e = new we(this.textures[s].animated)),
                    e.reset(),
                    (e.flags.dead = !1),
                    (e.flags.infected = !1),
                    (e.flags.burning = !1),
                    (e.burnDamage = 0),
                    (e.plagueDamage = 0),
                    (e.minigun = 1 == s),
                    (e.rocketlauncher = 2 == s),
                    (e.deadTexture = this.textures[s].dead),
                    (e.animationSpeed = 0.2),
                    e.anchor.set(35 / 80, 1),
                    (e.currentPoi = this.map.getRandomBuilding()),
                    e.position.copyFrom(this.map.randomPositionInBuilding(e.currentPoi)),
                    (e.zIndex = e.position.y),
                    (e.xSpeed = 0),
                    (e.ySpeed = 0),
                    (e.speedMod = 1),
                    (e.lastKnownBuilding = null),
                    (e.maxSpeed = this.maxWalkSpeed),
                    (e.visionDistance = this.visionDistance),
                    (e.visible = !0),
                    (e.maxHealth = e.health = t),
                    (e.timer.attack = this.attackSpeed),
                    (e.timer.plagueTick = Math.random() * this.humans.plagueTickTimer),
                    (e.timer.scan = Math.random() * this.humans.scanTime),
                    (e.timer.standing = Math.random() * this.humans.randomSecondsToStand()),
                    (e.target = !1),
                    (e.zombieTarget = null),
                    (e.graveYardTarget = null),
                    (e.armyState = pe.standing),
                    (e.attackingGraveyard = !1),
                    e.scale.set(Math.random() > 0.5 ? this.scaling : -1 * this.scaling, this.scaling),
                    this.armymen.push(e),
                    g.addChild(e);
            }
            this.isExtraArmy() && this.gameModel.sendMessage("Warning: High Military Activity!");
        }
        update(e, t) {
            let s = 0;
            (this.aliveZombies = t), this.droneActive && (this.droneStrikeTimer -= e);
            for (let i = 0; i < this.armymen.length; i++)
                this.updateArmy(this.armymen[i], e, t), this.armymen[i].flags.dead || (this.humans.aliveHumans.push(this.armymen[i]), this.armymen[i].attackingGraveyard && this.humans.graveyardAttackers.push(this.armymen[i]), s++);
            (this.gameModel.stats.army.count = s), this.updateDroneStrike(e, t);
        }
        decideStateOnZombieDistance(e) {
            var t;
            if (e.graveYardTarget || (e.zombieTarget && !e.zombieTarget.flags.dead)) {
                e.target = null !== (t = e.graveYardTarget) && void 0 !== t ? t : e.zombieTarget;
                const s = i(e.position.x, e.position.y, e.target.x, e.target.y);
                if (s > this.shootDistance && !e.rocketlauncher) return void this.changeState(e, pe.running);
                if (s > 1.2 * this.shootDistance && e.rocketlauncher) return void this.changeState(e, pe.running);
                if (s < this.attackDistance && !e.graveYardTarget) return void this.changeState(e, pe.attacking);
                this.changeState(e, pe.shooting);
            }
        }
        changeState(e, t) {
            switch (t) {
                case pe.standing:
                    e.gotoAndStop(0);
                    break;
                case pe.walking:
                    e.play(), (e.maxSpeed = this.maxWalkSpeed);
                    break;
                case pe.running:
                    e.play(), (e.maxSpeed = this.maxRunSpeed);
                    break;
                case pe.shooting:
                    e.gotoAndStop(0);
                    break;
                case pe.attacking:
                    e.play();
            }
            e.armyState = t;
        }
        updateArmy(e, t, s) {
            var a, r;
            if (e.flags.dead) return this.humans.updateDeadHumanFading(e, t);
            switch (
            ((e.timer.attack -= t),
                (e.timer.scan -= t),
                e.flags.infected && this.humans.updatePlague(e, t),
                e.flags.burning && this.humans.updateBurns(e, t),
                !e.graveYardTarget &&
                (!e.zombieTarget || e.zombieTarget.flags.dead) &&
                e.timer.scan < 0 &&
                (this.humans.scanForZombies(e, s) > 3 && this.droneActive && this.droneStrikeTimer < 0 && this.callDroneStrike(e, s),
                    this.assaultStarted && e.rocketlauncher && Math.random() > 0.98 && ((e.graveYardTarget = this.graveyard.target), (e.attackingGraveyard = !0))),
                this.decideStateOnZombieDistance(e),
                e.armyState)
            ) {
                case pe.standing:
                    (e.timer.standing -= t), e.timer.standing < 0 && (this.humans.assignRandomTarget(e), this.changeState(e, pe.walking));
                    break;
                case pe.walking:
                    i(e.position.x, e.position.y, e.target.x, e.target.y) < this.moveTargetDistance
                        ? ((e.target = null), (e.zombieTarget = null), (e.timer.standing = this.humans.randomSecondsToStand()), this.changeState(e, pe.standing))
                        : this.humans.updateHumanSpeed(e, t);
                    break;
                case pe.running:
                    e.graveYardTarget || (e.zombieTarget && !e.zombieTarget.flags.dead)
                        ? ((e.target = null !== (a = e.graveYardTarget) && void 0 !== a ? a : e.zombieTarget), this.humans.updateHumanSpeed(e, t))
                        : this.changeState(e, pe.standing);
                    break;
                case pe.attacking:
                    e.zombieTarget && !e.zombieTarget.flags.dead
                        ? ((e.scale.x = e.zombieTarget.x > e.x ? this.scaling : -this.scaling), e.timer.attack < 0 && (this.zombies.damageZombie(e.zombieTarget, this.attackDamage, e), (e.timer.attack = this.attackSpeed)))
                        : this.changeState(e, pe.standing);
                    break;
                case pe.shooting:
                    e.graveYardTarget || (e.zombieTarget && !e.zombieTarget.flags.dead)
                        ? ((e.target = null !== (r = e.graveYardTarget) && void 0 !== r ? r : e.zombieTarget),
                            (e.scale.x = e.target.x > e.x ? this.scaling : -this.scaling),
                            e.timer.attack < 0 &&
                            ((e.shotsLeft = this.shotsPerBurst),
                                e.minigun && (e.shotsLeft = 3 * this.shotsPerBurst),
                                e.rocketlauncher && (e.shotsLeft = 1),
                                (e.timer.attack = e.rocketlauncher ? 1.5 * this.attackSpeed : this.attackSpeed),
                                (e.shotTimer = 0)),
                            e.shotsLeft > 0 &&
                            ((e.shotTimer -= t),
                                e.shotTimer < 0 &&
                                ((e.shotTimer = 0.15),
                                    e.minigun && (e.shotTimer = 0.08),
                                    this.bullets.newBullet(e, e.target, e.rocketlauncher ? 1.2 * this.attackDamage : e.minigun ? this.attackDamage / 2 : this.attackDamage, !1, e.rocketlauncher),
                                    e.shotsLeft--)))
                        : this.changeState(e, pe.standing);
            }
        }
        callDroneStrike(e, t) {
            let s = 0;
            for (let i = 0; i < t.length; i++)
                t[i].x > e.zombieTarget.x - this.droneBlastRadius && t[i].x < e.zombieTarget.x + this.droneBlastRadius && t[i].y > e.zombieTarget.y - this.droneBlastRadius && t[i].y < e.zombieTarget.y + this.droneBlastRadius && s++;
            let i = 0;
            const a = this.humans.aliveHumans;
            for (let t = 0; t < a.length; t++)
                a[t].x > e.zombieTarget.x - this.droneBlastRadius && a[t].x < e.zombieTarget.x + this.droneBlastRadius && a[t].y > e.zombieTarget.y - this.droneBlastRadius && a[t].y < e.zombieTarget.y + this.droneBlastRadius && i++;
            s > 1 && 0 == i && (this.exclamations.newRadio(e), (this.droneStrikeTimer = this.droneStrikeTime), (this.droneStrike = { caller: e, target: e.zombieTarget, timer: 3, bombsLeft: 3 }));
        }
        droneBomb(e) {
            this.droneExplosion(this.droneStrike.target.x + 32 * (Math.random() - 1), this.droneStrike.target.y + 32 * (Math.random() - 1), e, 3 * this.attackDamage), (this.droneStrike.timer = 0.3), this.droneStrike.bombsLeft--;
        }
        droneExplosion(e, t, s, i) {
            s || (s = this.aliveZombies), this.blasts.newDroneBlast(e, t);
            for (let a = 0; a < s.length; a++) s[a].x > e - this.droneBlastRadius && s[a].x < e + this.droneBlastRadius && s[a].y > t - this.droneBlastRadius && s[a].y < t + this.droneBlastRadius && this.zombies.damageZombie(s[a], i, null);
        }
        updateDroneStrike(e, t) {
            if (this.droneStrike) {
                if (
                    ((this.droneStrike.timer -= e),
                        this.droneStrike.startedBombing ||
                        (this.droneStrike.text ||
                            ((this.droneStrike.text = new PIXI.Text("3", { fontFamily: "sans-serif", fontSize: 40, fill: "#F00", stroke: "#000", strokeThickness: 0, align: "center" })),
                                (this.droneStrike.text.anchor = { x: 0.5, y: 1 }),
                                (this.droneStrike.text.scale.x = 0.5),
                                (this.droneStrike.text.scale.y = 0.5),
                                b.addChild(this.droneStrike.text),
                                (this.droneStrike.laser = new PIXI.Graphics()),
                                b.addChild(this.droneStrike.laser)),
                            (this.droneStrike.text.text = Math.ceil(this.droneStrike.timer)),
                            (this.droneStrike.text.x = this.droneStrike.target.x),
                            (this.droneStrike.text.y = this.droneStrike.target.y - 30),
                            this.droneStrike.laser.clear(),
                            this.droneStrike.laser.lineStyle(1, 16711680),
                            this.droneStrike.laser.moveTo(this.droneStrike.caller.x, this.droneStrike.caller.y - 10),
                            this.droneStrike.laser.lineTo(this.droneStrike.target.x, this.droneStrike.target.y - 10)),
                        (this.droneStrike.caller.dead || this.droneStrike.target.dead) && !this.droneStrike.startedBombing)
                )
                    return b.removeChild(this.droneStrike.text), b.removeChild(this.droneStrike.laser), (this.droneStrike = !1), void (this.droneStrikeTimer = 0);
                this.droneStrike.timer < 0 &&
                    (this.droneStrike.startedBombing || (b.removeChild(this.droneStrike.text), b.removeChild(this.droneStrike.laser), (this.droneStrike.startedBombing = !0)),
                        this.droneBomb(t),
                        this.droneStrike.bombsLeft <= 0 && (this.droneStrike = !1));
            }
        }
    }
    class Ce extends ve {
        constructor() {
            super(...arguments), (this.attackingGraveyard = !1);
        }
    }
    !(function (e) {
        (e[(e.shooting = 0)] = "shooting"), (e[(e.attacking = 1)] = "attacking"), (e[(e.patrolling = 2)] = "patrolling");
    })(ge || (ge = {})),
        (function (e) {
            (e[(e.horizontal = 0)] = "horizontal"), (e[(e.vertical = 1)] = "vertical");
        })(me || (me = {}));
    class De {
        constructor() {
            if (
                ((this.speed = 20),
                    (this.tanks = []),
                    (this.aliveTanks = []),
                    (this.attackDamage = 0),
                    (this.attackSpeed = 3),
                    (this.scaling = 3),
                    (this.moveTargetDistance = 20),
                    (this.shootDistance = 300),
                    (this.aliveZombies = null),
                    De.instance)
            )
                return De.instance;
            De.instance = this;
        }
        getMaxTanks() {
            return this.gameModel.isBossStage(this.gameModel.level) ? Math.min(Math.round(this.gameModel.level / 30), 20) : 0;
        }
        getMaxHealth() {
            return Math.round(10 * this.humans.getMaxHealth(this.gameModel.level));
        }
        getAttackDamage() {
            this.attackDamage = Math.round(this.getMaxHealth() / 10);
        }
        populate() {
            if (((this.map = new MapManager()), (this.gameModel = ne.getInstance()), (this.zombies = new ZombieManager()), (this.humans = new HumanManager()), (this.army = new Te()), (this.graveyard = new Oe()), (this.bullets = new rt()), !this.textures)) {
                this.textures = { vertical: [], horizontal: [], turret: null };
                for (let e = 0; e < 2; e++) this.textures.horizontal.push(PIXI.Texture.from("tank" + e + ".png"));
                for (let e = 2; e < 4; e++) this.textures.vertical.push(PIXI.Texture.from("tank" + e + ".png"));
                this.textures.turret = PIXI.Texture.from("tank4.png");
            }
            if (this.tanks.length > 0) {
                for (let e = 0; e < this.tanks.length; e++) g.removeChild(this.tanks[e]);
                (this.tanks = []), (this.aliveTanks = []);
            }
            const e = this.getMaxTanks(),
                t = this.getMaxHealth();
            this.getAttackDamage();
            for (let s = 0; s < e; s++) {
                const e = new Ce(this.textures.horizontal);
                (e.flags.tank = !0),
                    (e.turretSprite = new PIXI.Sprite(this.textures.turret)),
                    e.addChild(e.turretSprite),
                    (e.animationSpeed = 0.2),
                    e.anchor.set(0.5, 1),
                    e.turretSprite.anchor.set(7.5 / 16, 7.5 / 16),
                    (e.x = 0),
                    (e.y = 0),
                    e.play(),
                    (e.turretSprite.x = 0),
                    (e.turretSprite.y = -7),
                    (e.currentDirection = me.horizontal),
                    (e.currentPoi = this.map.getRandomBuilding()),
                    e.position.copyFrom(this.map.randomPositionInBuilding(e.currentPoi)),
                    (e.zIndex = e.position.y),
                    (e.xSpeed = 0),
                    (e.ySpeed = 0),
                    (e.speedMod = 1),
                    (e.flags.dead = !1),
                    (e.flags.infected = !1),
                    (e.flags.burning = !1),
                    (e.burnDamage = 0),
                    (e.lastKnownBuilding = null),
                    (e.plagueDamage = 0),
                    (e.timer.plagueTick = Math.random() * this.humans.plagueTickTimer),
                    (e.maxSpeed = this.speed),
                    (e.visionDistance = 250),
                    (e.visible = !0),
                    (e.maxHealth = e.health = t),
                    (e.timer.scan = Math.random() * this.humans.scanTime),
                    (e.target = !1),
                    (e.zombieTarget = null),
                    (e.graveYardTarget = null),
                    (e.attackingGraveyard = !1),
                    (e.tankState = ge.patrolling),
                    (e.timer.attack = this.attackSpeed),
                    e.scale.set(this.scaling, this.scaling),
                    this.tanks.push(e),
                    g.addChild(e);
            }
        }
        update(e, t) {
            (this.aliveZombies = t), (this.aliveTanks = []);
            for (let s = 0; s < this.tanks.length; s++)
                this.updateTank(this.tanks[s], e, t),
                    this.tanks[s].flags.dead || (this.humans.aliveHumans.push(this.tanks[s]), this.aliveTanks.push(this.tanks[s]), this.tanks[s].attackingGraveyard && this.humans.graveyardAttackers.push(this.tanks[s]));
        }
        updateTank(e, t, s) {
            if (e.flags.dead) return this.humans.updateDeadHumanFading(e, t);
            switch (
            ((e.timer.attack -= t),
                (e.timer.scan -= t),
                e.flags.burning && this.humans.updateBurns(e, t),
                !e.attackingGraveyard &&
                (!e.zombieTarget || e.zombieTarget.flags.dead) &&
                e.timer.scan < 0 &&
                (this.humans.scanForZombies(e, s), this.army.assaultStarted && Math.random() > 0.9 && ((e.graveYardTarget = this.graveyard.target), (e.attackingGraveyard = !0))),
                this.decideStateOnZombieDistance(e),
                e.tankState)
            ) {
                case ge.patrolling:
                    e.target || (e.target = this.map.randomPositionInBuilding(null)),
                        i(e.position.x, e.position.y, e.target.x, e.target.y) < this.moveTargetDistance ? ((e.target = !1), (e.zombieTarget = null)) : this.humans.updateHumanSpeed(e, t);
                    break;
                case ge.attacking:
                    e.attackingGraveyard ? ((e.target = e.graveYardTarget), this.humans.updateHumanSpeed(e, t)) : e.zombieTarget && !e.zombieTarget.flags.dead ? this.humans.updateHumanSpeed(e, t) : this.changeState(e, ge.patrolling);
                    break;
                case ge.shooting:
                    e.graveYardTarget || (e.zombieTarget && !e.zombieTarget.flags.dead)
                        ? e.timer.attack < 0 && ((e.timer.attack = this.attackSpeed), this.bullets.newBullet(e, e.graveYardTarget || e.zombieTarget, this.attackDamage, !1, !0))
                        : this.changeState(e, ge.patrolling);
            }
            this.updateTankSprites(e, t);
        }
        updateTankSprites(e, t) {
            var s;
            if (
                (Math.abs(e.xSpeed) > Math.abs(e.ySpeed)
                    ? e.currentDirection != me.horizontal && ((e.currentDirection = me.horizontal), (e.textures = this.textures.horizontal), e.play(), (e.turretSprite.y = -7))
                    : e.currentDirection != me.vertical && ((e.currentDirection = me.vertical), (e.textures = this.textures.vertical), e.play(), (e.turretSprite.y = -8)),
                    e.graveYardTarget || e.zombieTarget)
            ) {
                e.target = null !== (s = e.graveYardTarget) && void 0 !== s ? s : e.zombieTarget;
                const i = Math.atan2(e.target.x - e.x, e.y - e.target.y) + Math.PI / 2;
                e.turretSprite.rotation > i ? (e.turretSprite.rotation -= 3 * t) : (e.turretSprite.rotation += 3 * t);
            }
        }
        decideStateOnZombieDistance(e) {
            var t;
            if (e.graveYardTarget || (e.zombieTarget && !e.zombieTarget.flags.dead)) {
                if (((e.target = null !== (t = e.graveYardTarget) && void 0 !== t ? t : e.zombieTarget), i(e.position.x, e.position.y, e.target.x, e.target.y) > this.shootDistance)) return void this.changeState(e, ge.attacking);
                this.changeState(e, ge.shooting);
            }
        }
        changeState(e, t) {
            switch (t) {
                case ge.patrolling:
                case ge.attacking:
                    e.play();
                    break;
                case ge.shooting:
                    e.gotoAndStop(0);
            }
            e.tankState = t;
        }
    }
    class Pe extends Q {
        constructor() {
            super(...arguments),
                (this.currentDirection = 0),
                (this.bulletReflect = 0),
                (this.zombieId = 0),
                (this.lastKnownBuilding = null),
                (this.maxSpeed = 0),
                (this.graveyard = !1),
                (this.regenTimer = 0),
                (this.bloodbornTimer = 0),
                (this.level = 0),
                (this.creatureType = 0),
                (this.scaling = 0),
                (this.attackDamage = 0),
                (this.speedMultiplier = 1),
                (this.price = 0),
                (this.immuneToBurns = !1),
                (this.zombie = !0),
                (this.textureSet = { set: !1, down: [], up: [], left: [], right: [], dead: [] });
        }
    }
    !(function (e) {
        (e[(e.lookingForTarget = 0)] = "lookingForTarget"), (e[(e.movingToTarget = 1)] = "movingToTarget"), (e[(e.attackingTarget = 2)] = "attackingTarget");
    })(be || (be = {}));
    class ze extends PIXI.Text {
        constructor() {
            super(...arguments), (this.speed = 30), (this.fadeTime = 0.5);
        }
        updateCritText(e) {
            this.visible && ((this.y -= this.speed * e), (this.fadeTime -= e), this.fadeTime < 0 && ((this.alpha -= 2 * e), this.alpha < 0 && ((this.visible = !1), Re.push(this))));
        }
        reset() {
            (this.fadeTime = 0.5), (this.alpha = 1), (this.visible = !0);
        }
    }
    const Ie = new PIXI.TextStyle({ fill: "#ef0", fontSize: 64 }),
        Be = [],
        Re = [];
    function He(e, t, s) {
        if (ne.getInstance().persistentData.particles)
            if (Re.length > 0) {
                const i = Re.pop();
                i.reset(), (i.text = r(s)), i.position.set(e, t);
            } else {
                const i = new ze(r(s), Ie);
                b.addChild(i), i.position.set(e, t), i.anchor.set(0.5, 1), i.scale.set(0.2, 0.2), Be.push(i);
            }
    }
    class Fe extends K {
        constructor() {
            super(...arguments), (this.dog = !1), (this.super = !1);
        }
    }
    class Ee extends Pe {
        constructor() {
            super(...arguments), (this.flags = new Fe()), (this.mod = 1), (this.scaleMod = 1), (this.textureId = 0), (this.turnTimer = 0);
        }
    }
    class ZombieManager {
        constructor() {
            if (
                ((this.zombies = []),
                    (this.discardedZombies = []),
                    (this.aliveZombies = []),
                    (this.aliveHumans = []),
                    (this.zombiePartition = []),
                    (this.scaling = 2),
                    (this.moveTargetDistance = 15),
                    (this.attackDistance = 15),
                    (this.attackSpeed = 3),
                    (this.targetDistance = 100),
                    (this.fadeSpeed = 0.1),
                    (this.refundChance = 0),
                    (this.currId = 1),
                    (this.scanTime = 3),
                    (this.textures = []),
                    (this.dogTexture = []),
                    (this.deadDogTexture = []),
                    (this.maxSpeed = 10),
                    (this.zombieCursor = null),
                    (this.zombieCursorText = null),
                    (this.zombieCursorScale = 3),
                    (this.mouseOutOfBounds = !1),
                    (this.burnTickTimer = 5),
                    (this.bloodpact = 1),
                    (this.bloodborn = 0),
                    (this.gigamutagen = 0),
                    (this.gigamutationTimer = 10),
                    (this.smokeTimer = 0.3),
                    (this.fastDistance = i),
                    (this.magnitude = t),
                    (this.detonate = !1),
                    (this.super = !1),
                    (this.reactionTime = 0),
                    (this.graveyardAttackers = []),
                    (this.spaceNeeded = 3),
                    ZombieManager.instance)
            )
                return ZombieManager.instance;
            ZombieManager.instance = this;
        }
        populate() {
            if (
                ((this.map = new MapManager()),
                    (this.model = ne.getInstance()),
                    (this.humans = new HumanManager()),
                    (this.graveyard = new Oe()),
                    (this.creatureFactory = new CreatureFactory()),
                    (this.smoke = new ot()),
                    (this.blood = new _e()),
                    (this.bones = new tt()),
                    (this.exclamations = new it()),
                    (this.blasts = new nt()),
                    (this.bullets = new rt()),
                    (this.model.zombieCount = 0),
                    0 == this.textures.length)
            ) {
                for (let e = 0; e < 3; e++) {
                    const t = [];
                    for (let s = 0; s < 3; s++) t.push(PIXI.Texture.from("zombie" + (e + 1) + "_" + (s + 1) + ".png"));
                    this.textures.push({ animated: t, dead: [PIXI.Texture.from("zombie" + (e + 1) + "_dead.png")] });
                }
                for (let e = 0; e < 2; e++) this.dogTexture.push(PIXI.Texture.from("zombiedog" + (e + 1) + ".png"));
                this.deadDogTexture = [PIXI.Texture.from("zombiedogdead.png")];
            }
            if (this.zombies.length > 0) {
                for (let e = 0; e < this.zombies.length; e++) g.removeChild(this.zombies[e]), this.zombies[e].stop();
                (this.discardedZombies = this.zombies.slice()), (this.zombies.length = 0), (this.aliveZombies.length = 0);
            }
            if (!this.zombieCursor) {
                this.zombieCursor = new PIXI.Container();
                const e = new PIXI.Sprite(PIXI.Texture.from("zombie1_1.png"));
                (e.alpha = 0.6),
                    (e.scale.x = e.scale.y = 1),
                    e.anchor.set(35 / 80, 1),
                    (this.zombieCursorText = new PIXI.Text("1", { fontFamily: "sans-serif", fontSize: 40, fill: "#FFF", stroke: "#000", strokeThickness: 0, align: "center" })),
                    (this.zombieCursorText.anchor = { x: 0.5, y: 1 }),
                    (this.zombieCursorText.scale.x = this.zombieCursorText.scale.y = 0.1),
                    (this.zombieCursorText.y = -9),
                    (this.zombieCursorText.visible = !1),
                    (this.zombieCursorText.alpha = 0.7),
                    this.zombieCursor.addChild(e),
                    this.zombieCursor.addChild(this.zombieCursorText),
                    m.addChild(this.zombieCursor);
            }
        }
        createZombie(e, t, s = !1) {
            const i = Math.floor(Math.random() * this.textures.length);
            let a;
            this.discardedZombies.length > 0 ? ((a = this.discardedZombies.pop()), (a.textures = s ? this.dogTexture : this.textures[i].animated)) : (a = new Ee(s ? this.dogTexture : this.textures[i].animated)),
                (a.zombie = !0),
                (a.mod = 1),
                (a.scaleMod = 1),
                this.super && ((a.mod = 10), (a.scaleMod = 1.5)),
                (a.flags = new Fe()),
                (a.flags.dog = s),
                (a.flags.super = this.super),
                (a.deadTexture = a.flags.dog ? this.deadDogTexture : this.textures[i].dead),
                (a.textureId = i),
                (a.burnDamage = 0),
                (a.lastKnownBuilding = !1),
                (a.alpha = 1),
                (a.animationSpeed = 0.15),
                a.anchor.set(35 / 80, 1),
                (a.bloodbornTimer = this.bloodborn),
                a.position.set(e, t),
                (a.target = null),
                (a.zIndex = a.position.y),
                (a.visible = !0),
                (a.maxHealth = a.health = this.model.zombieHealth * a.mod),
                (a.regenTimer = 5),
                (a.state = be.lookingForTarget);
            const r = s ? 0.7 : 1;
            (a.scaling = a.scaleMod * this.scaling * r),
                a.scale.set(Math.random() > 0.5 ? a.scaling : -1 * a.scaling, a.scaling),
                (a.timer.attack = 0),
                (a.xSpeed = 0),
                (a.ySpeed = 0),
                (a.speedMultiplier = 1),
                (a.timer.scan = 0),
                (a.timer.burnTick = this.burnTickTimer),
                (a.timer.smoke = this.smokeTimer),
                a.play(),
                (a.zombieId = this.currId++),
                this.zombies.push(a),
                g.addChild(a),
                this.smoke.newZombieSpawnCloud(e, t - 2);
        }
        spawnZombie(e, t) {
            this.model.energy < this.model.zombieCost || ((this.model.energy -= this.model.zombieCost), this.createZombie(e, t, !1));
        }
        spawnAllZombies(e, t) {
            const s = Math.min(Math.floor(this.model.energy / this.model.zombieCost), 100);
            for (let i = 0; i < s; i++) this.spawnZombie(e + 4 * (Math.random() - 1), t + 4 * (Math.random() - 1));
        }
        damageZombie(e, t, s) {
            if (e.graveyard) this.graveyard.damageGraveyard(t);
            else {
                if (e.boneshield) return e.boneshield--, void this.bones.newPart(e.x, e.y, 1);
                this.graveyard.isWithinFence(e) && ((t *= 0.5), this.exclamations.newShield(e)),
                    e.bloodbornTimer > 0 && ((t *= 0.5), this.exclamations.newShield(e)),
                    s && s.flags.infected && (t *= this.model.plagueDmgReduction),
                    (e.health -= t * this.model.runeEffects.damageReduction),
                    this.setSpeedMultiplier(e),
                    this.blood.newSplatter(e.x, e.y),
                    e.health <= 0 &&
                    !e.flags.dead &&
                    (this.bones.newBones(e.x, e.y),
                        (e.flags.dead = !0),
                        e.flags.golem && this.refundChance > 0 && (this.model.sendMessage("Golem Refunded!"), this.creatureFactory.refundParts(e, this.refundChance)),
                        Math.random() < this.model.infectedBlastChance && this.causePlagueExplosion(e, 0.2 * e.maxHealth, !0, !1),
                        (e.textures = e.deadTexture),
                        e.gotoAndStop(0),
                        Math.random() < this.model.brainRecoverChance && this.model.addBrains(1)),
                    s && this.model.runeEffects.damageReflection > 0 && this.humans.damageHuman(s, t * this.model.runeEffects.damageReflection);
            }
        }
        causePlagueExplosion(e, t, s = !0, i = !1) {
            const a = i ? 75 : 50;
            this.blood.newPlagueSplatter(e.x, e.y), i ? this.blasts.newDetonateBlast(e.x, e.y - 4) : this.blasts.newZombieBlast(e.x, e.y - 4), s && ((e.visible = !1), g.removeChild(e));
            for (let s = 0; s < this.aliveHumans.length; s++)
                Math.abs(this.aliveHumans[s].x - e.x) < a &&
                    Math.abs(this.aliveHumans[s].y - e.y) < a &&
                    this.fastDistance(e.x, e.y, this.aliveHumans[s].x, this.aliveHumans[s].y) < a &&
                    (this.inflictPlague(this.aliveHumans[s]), this.humans.damageHuman(this.aliveHumans[s], t));
            if (this.model.blastHealing > 0) {
                const s = t * this.model.blastHealing;
                for (let t = 0; t < this.aliveZombies.length; t++)
                    Math.abs(this.aliveZombies[t].x - e.x) < a && Math.abs(this.aliveZombies[t].y - e.y) < a && this.fastDistance(e.x, e.y, this.aliveZombies[t].x, this.aliveZombies[t].y) < a && this.healZombie(this.aliveZombies[t], s);
            }
        }
        partitionInsert(e, t) {
            const s = Math.round(t.x / 10),
                i = Math.round(t.y / 10);
            e[s] || (e[s] = []), e[s][i] || (e[s][i] = []), e[s][i].push(t);
        }
        partitionGetNeighbours(e) {
            const t = [],
                s = Math.round(e.x / 10),
                i = Math.round(e.y / 10);
            for (let e = s - 1; e <= s + 1; e++) if (this.zombiePartition[e]) for (let s = i - 1; s <= i + 1; s++) this.zombiePartition[e][s] && t.push(...this.zombiePartition[e][s]);
            return t;
        }
        update(e) {
            (this.maxSpeed = this.model.zombieSpeed), this.detonate && (this.maxSpeed *= 1.5), (this.reactionTime = Math.max(0.2, this.aliveZombies.length / 2e3));
            const t = [],
                s = [];
            (this.aliveHumans = this.humans.aliveHumans), (this.graveyardAttackers = this.humans.graveyardAttackers), this.gigamutagen > 0 && (this.gigamutationTimer -= e);
            for (let i = 0; i < this.zombies.length; i++) this.zombies[i].visible && (this.updateZombie(this.zombies[i], e), this.zombies[i].flags.dead || (t.push(this.zombies[i]), this.partitionInsert(s, this.zombies[i])));
            if (((this.model.zombieCount = t.length), (this.aliveZombies = t), (this.zombiePartition = s), this.model.energy >= this.model.zombieCost && this.model.currentState == this.model.states.playingLevel))
                if (((this.zombieCursor.visible = !this.mouseOutOfBounds), Y.shift && !this.mouseOutOfBounds)) {
                    this.zombieCursorText.visible = !0;
                    const e = Math.min(Math.floor(this.model.energy / this.model.zombieCost), 100);
                    this.zombieCursorText.text != e && (this.zombieCursorText.text = e);
                } else this.zombieCursorText.visible = !1;
            else this.zombieCursor.visible = !1;
        }
        detonateZombie(e) {
            (e.state == be.attackingTarget || (0 == this.aliveHumans.length && Math.random() < 0.05)) &&
                (this.bones.newBones(e.x, e.y), (e.flags.dead = !0), this.causePlagueExplosion(e, e.maxHealth, !0, !0), Math.random() < this.model.brainRecoverChance && this.model.addBrains(1));
        }
        updateZombie(e, t) {
            var s;
            if (e.flags.dead) {
                if (!e.visible) return;
                return (e.alpha -= this.fadeSpeed * t), void (e.alpha < 0 && ((e.visible = !1), g.removeChild(e)));
            }
            switch (
            (1 == e.mod &&
                this.gigamutationTimer < 0 &&
                ((e.mod = 10), (e.scaling *= 1.5), e.scale.set(e.scaling, e.scaling), (e.maxHealth *= 10), (e.health *= 10), (this.gigamutationTimer = this.gigamutagen), this.smoke.newZombieSpawnCloud(e.x, e.y - 2)),
                (e.bloodbornTimer -= t),
                (e.timer.attack -= t),
                (e.timer.scan -= t),
                this.model.runeEffects.healthRegen > 0 && this.updateZombieRegen(e, t),
                this.detonate && this.detonateZombie(e),
                e.flags.burning && this.updateBurns(e, t),
                (!e.target || e.target.flags.dead) && e.timer.scan < 0 && (e.state = be.lookingForTarget),
                e.state)
            ) {
                case be.lookingForTarget:
                    this.searchClosestTarget(null !== (s = e.target) && void 0 !== s ? s : e), (e.target && !e.target.flags.dead) || this.assignRandomTarget(e), e.target && (e.state = be.movingToTarget);
                    break;
                case be.movingToTarget: {
                    const s = this.fastDistance(e.position.x, e.position.y, e.target.x, e.target.y);
                    if (s < this.attackDistance) {
                        e.state = be.attackingTarget;
                        break;
                    }
                    e.timer.attack < 0 && s < this.model.spitDistance && (this.bullets.newBullet(e, e.target, this.model.zombieDamage / 2, !0), (e.timer.attack = this.attackSpeed * (1 / this.model.runeEffects.attackSpeed))),
                        s > 3 * this.attackDistance && e.timer.scan < 0 && this.searchClosestTarget(e),
                        this.updateZombieSpeed(e, t);
                    break;
                }
                case be.attackingTarget: {
                    const s = this.fastDistance(e.position.x, e.position.y, e.target.x, e.target.y);
                    s < this.attackDistance
                        ? ((e.scale.x = e.target.x > e.x ? e.scaling : -e.scaling),
                            e.timer.attack < 0 &&
                            (this.humans.damageHuman(e.target, this.calculateDamage(e)),
                                e.flags.dog && (e.target.timer.dogStun = 1),
                                Math.random() < this.model.infectedBiteChance && this.inflictPlague(e.target),
                                (e.timer.attack = this.attackSpeed * (1 / this.model.runeEffects.attackSpeed)),
                                e.flags.burning && (e.timer.attack *= 1 / this.model.burningSpeedMod)),
                            s > this.attackDistance / 2 && this.updateZombieSpeed(e, t))
                        : (e.state = be.movingToTarget);
                    break;
                }
            }
        }
        setSpeedMultiplier(e) {
            e.flags.burning ? (e.speedMultiplier = this.model.burningSpeedMod) : (e.speedMultiplier = Math.max(Math.min(1, e.health / e.maxHealth), 0.4));
        }
        updateZombieRegen(e, t) {
            (e.regenTimer -= t),
                e.regenTimer < 0 && ((e.regenTimer = 5), e.health < e.maxHealth && ((e.health += e.maxHealth * this.model.runeEffects.healthRegen), e.health > e.maxHealth && (e.health = e.maxHealth), this.setSpeedMultiplier(e)));
        }
        healZombie(e, t) {
            e.health < e.maxHealth && ((e.health += t), this.exclamations.newHealing(e), e.health > e.maxHealth && (e.health = e.maxHealth), this.setSpeedMultiplier(e));
        }
        calculateDamage(e) {
            let t = this.model.zombieDamage * e.mod;
            return (
                this.model.runeEffects.critChance > 0 && Math.random() < this.model.runeEffects.critChance && ((t *= this.model.runeEffects.critDamage), He(e.x, e.y - 20, t)), this.bloodpact > 0 && this.model.addBlood(t * this.bloodpact), t
            );
        }
        inflictPlague(e) {
            e.flags.infected
                ? ((e.plagueDamage += this.model.zombieDamage / 2 + this.model.plagueDamageMod), (e.plagueTicks = this.model.plagueticks))
                : (this.exclamations.newPoison(e), (e.plagueDamage = this.model.zombieDamage / 2 + this.model.plagueDamageMod), (e.plagueTicks = this.model.plagueticks)),
                (e.flags.infected = !0);
        }
        updateBurns(e, t) {
            (e.timer.burnTick -= t),
                (e.timer.smoke -= t),
                e.timer.smoke < 0 && (this.smoke.newFireSmoke(e.x, e.y - 14), (e.timer.smoke = this.smokeTimer)),
                e.timer.burnTick < 0 && (this.damageZombie(e, e.burnDamage, null), (e.timer.burnTick = this.burnTickTimer), this.exclamations.newFire(e));
        }
        searchClosestTarget(e) {
            if (e.timer.scan > 0) return;
            e.timer.scan = this.scanTime * Math.random();
            let t = 300;
            if (this.model.isBossStage(this.model.level) && Math.random() > 0.3)
                for (let s = 0; s < this.graveyardAttackers.length; s++)
                    if (Math.abs(this.graveyardAttackers[s].x - e.x) < t && Math.abs(this.graveyardAttackers[s].y - e.y) < t) {
                        const i = this.fastDistance(e.x, e.y, this.graveyardAttackers[s].x, this.graveyardAttackers[s].y);
                        i < t && ((e.target = this.graveyardAttackers[s]), (t = i));
                    }
            if (300 == t) {
                t = 1e4;
                for (let s = 0; s < this.aliveHumans.length; s++)
                    if (Math.abs(this.aliveHumans[s].x - e.x) < t && Math.abs(this.aliveHumans[s].y - e.y) < t) {
                        const i = this.fastDistance(e.x, e.y, this.aliveHumans[s].x, this.aliveHumans[s].y);
                        i < t && ((e.target = this.aliveHumans[s]), (t = i));
                    }
            }
        }
        assignRandomTarget(e) {
            if (0 == this.aliveHumans.length) return;
            const t = this.map.findBuilding(e);
            if (t && this.map.isInsidePoi(e.x, e.y, t, 0)) for (let s = 0; s < this.aliveHumans.length; s++) if (this.map.isInsidePoi(this.aliveHumans[s].x, this.aliveHumans[s].y, t, 0)) return void (e.target = this.aliveHumans[s]);
            e.target = a(this.aliveHumans, Math.random());
        }
        dotProduct(e, t) {
            return e * e + t * t;
        }
        updateZombieSpeed(e, t) {
            if (e.timer.dogStun && e.timer.dogStun > 0) return void (e.timer.dogStun -= t);
            if (
                ((e.timer.target && e.targetVector) || (e.timer.target = 0),
                    (e.timer.target -= t),
                    e.timer.target <= 0 && ((e.targetVector = this.map.howDoIGetToMyTarget(e, e.target)), (e.timer.target = this.reactionTime)),
                    this.model.gameSpeed > 1 || e.flags.dog)
            ) {
                const t = e.flags.dog ? 1.5 : 1,
                    s = Math.max(this.maxSpeed * e.speedMultiplier * t, 8);
                (e.xSpeed = e.targetVector.x * s), (e.ySpeed = e.targetVector.y * s);
            } else {
                const s = 5 * this.maxSpeed * t;
                (e.xSpeed += e.targetVector.x * s), (e.ySpeed += e.targetVector.y * s);
                const i = this.dotProduct(e.xSpeed, e.ySpeed),
                    a = Math.pow(Math.max(this.maxSpeed * e.speedMultiplier, 8), 2);
                i > a && ((e.xSpeed *= a / i), (e.ySpeed *= a / i));
            }
            let s = { x: e.position.x + e.xSpeed * t, y: e.position.y + e.ySpeed * t };
            if (((e.turnTimer -= t), e.turnTimer < 0 && ((e.turnTimer = 0.5), !this.isSpaceToMove(e, s.x, s.y)))) {
                if (Math.random() > 0.5) {
                    const t = { x: -e.ySpeed / 2 + e.xSpeed / 2, y: e.xSpeed / 2 + e.ySpeed / 2 };
                    (e.xSpeed = t.x), (e.ySpeed = t.y);
                } else {
                    const t = { x: e.ySpeed / 2 + e.xSpeed / 2, y: -e.xSpeed / 2 + e.ySpeed / 2 };
                    (e.xSpeed = t.x), (e.ySpeed = t.y);
                }
                s = { x: e.position.x + e.xSpeed * t, y: e.position.y + e.ySpeed * t };
            }
            const i = this.map.checkCollisions(e.position, s);
            i && (i.x && (e.xSpeed = 0), i.y && (e.ySpeed = 0), (s = { x: e.position.x + e.xSpeed * t, y: e.position.y + e.ySpeed * t }), i.x && (s.x = i.validX), i.y && (s.y = i.validY)),
                e.position.set(s.x, s.y),
                (e.zIndex = e.position.y),
                (e.scale.x = e.xSpeed > 0 ? e.scaling : -e.scaling);
        }
        isSpaceToMove(e, t, s) {
            const i = this.partitionGetNeighbours(e);
            for (let a = 0; a < i.length; a++)
                if (i[a].health >= e.health && i[a].zombieId != e.zombieId && Math.abs(i[a].x - t) < this.spaceNeeded && Math.abs(i[a].y - s) < this.spaceNeeded && Math.abs(i[a].x - t) < this.spaceNeeded)
                    return this.fastDistance(t, s, i[a].x, i[a].y) > this.fastDistance(e.x, e.y, i[a].x, i[a].y);
            return !0;
        }
    }
    class Le extends Pe {
        constructor() {
            super(...arguments), (this.boneshieldTimer = 3), (this.boneshield = 0), (this.boneshieldContainer = new Ge());
        }
    }
    class Ze extends PIXI.Sprite {
        constructor() {
            super(...arguments), (this.speed = { x: 0, y: 0 }), (this.flying = !1);
        }
    }
    class Ge extends PIXI.Container {
        constructor() {
            super(...arguments), (this.spacing = (2 * Math.PI) / 10), (this.bones = []);
        }
        getTexture() {
            if (this.texture) return this.texture;
            const e = document.createElement("canvas");
            (e.width = 4), (e.height = 1);
            const t = e.getContext("2d");
            return (t.fillStyle = "#dddddd"), t.fillRect(0, 0, 4, 1), (this.texture = PIXI.Texture.from(e)), this.texture;
        }
        getBone() {
            const e = new Ze(this.getTexture());
            return e.anchor.set(0.5, 20), this.addChild(e), this.bones.push(e), e;
        }
        update(e) {
            e > this.bones.length && (this.getBone().rotation = this.spacing * this.bones.length);
            for (let t = 0; t < this.bones.length; t++) this.bones[t].visible = t < e;
        }
    }
    class Xe {
        constructor() {
            if (
                ((this.skeletons = []),
                    (this.aliveSkeletons = []),
                    (this.discardedSprites = []),
                    (this.aliveHumans = []),
                    (this.scaling = 1),
                    (this.moveTargetDistance = 15),
                    (this.attackDistance = 25),
                    (this.attackSpeed = 3),
                    (this.targetDistance = 100),
                    (this.fadeSpeed = 0.1),
                    (this.currId = 1),
                    (this.scanTime = 3),
                    (this.spawnTimer = 0),
                    (this.respawnTime = 10),
                    (this.moveSpeed = 40),
                    (this.lastKillingBlow = 0),
                    (this.randomSpells = []),
                    (this.lootChance = 0.001),
                    (this.spellTimer = 3),
                    (this.textures = { set: !1, up: [], down: [], left: [], right: [], dead: [] }),
                    (this.directions = { down: 1, up: 2, right: 3, left: 4, dead: 5 }),
                    (this.burnTickTimer = 5),
                    (this.smokeTimer = 0.3),
                    (this.fastDistance = i),
                    (this.magnitude = t),
                    (this.damageZombie = null),
                    (this.searchClosestTarget = null),
                    (this.updateBurns = null),
                    (this.updateZombieRegen = null),
                    (this.causePlagueExplosion = null),
                    (this.inflictPlague = null),
                    (this.healZombie = null),
                    (this.setSpeedMultiplier = null),
                    (this.storageName = "incremancerskele"),
                    (this.talentsStorageName = "incremancertalents"),
                    (this.persistent = { xpRate: 0, skeletons: 0, level: 1, xp: 0, items: [], currItemId: 0, talentReset: !1 }),
                    (this.talents = []),
                    (this.talentPoints = 0),
                    (this.killingBlowParts = 0),
                    (this.lootChanceMod = 1),
                    (this.darkorb = 0),
                    (this.darkorbTimer = 0),
                    (this.boneshield = 0),
                    (this.aliveZombies = []),
                    (this.graveyardAttackers = []),
                    (this.lootPositions = {
                        helmet: { id: 1, name: "Helmet" },
                        chest: { id: 2, name: "Chest" },
                        legs: { id: 3, name: "Legs" },
                        gloves: { id: 4, name: "Gloves" },
                        boots: { id: 5, name: "Boots" },
                        sword: { id: 6, name: "Sword" },
                        shield: { id: 7, name: "Shield" },
                    }),
                    (this.rarity = { common: 1, rare: 2, epic: 3, legendary: 4 }),
                    (this.prefixes = {
                        commonQuality: ["Wooden", "Sturdy", "Rigid", "Iron", "Rusty", "Flimsy", "Battered", "Damaged", "Used", "Stained", "Training"],
                        rareQuality: ["Steel", "Shiny", "Polished", "Forged", "Plated", "Bronze", "Reinforced", "Veteran's", "Reliable"],
                        epicQuality: ["Antique", "Ancient", "Famous", "Bejeweled", "Notorious", "Historic", "Mythical", "Extraordinary"],
                        legendaryQuality: ["Monstrous", "Diabolical", "Withering", "Terrible", "Demoniacal"],
                    }),
                    (this.stats = { respawnTime: { id: 1, scaling: 1 }, speed: { id: 2, scaling: 1 }, zombieHealth: { id: 3, scaling: 24 }, zombieDamage: { id: 4, scaling: 3 }, zombieSpeed: { id: 5, scaling: 1 } }),
                    Xe.instance)
            )
                return Xe.instance;
            Xe.instance = this;
        }
        getUsedPoints() {
            return this.talents.reduce((e, t) => e + t, 0);
        }
        getAvailablePoints() {
            return this.talentPoints - this.getUsedPoints();
        }
        xpForNextLevel() {
            return 1e3 * Math.pow(this.persistent.level, 2);
        }
        addXp(e) {
            if (this.isAlive() && ((this.persistent.xp += e * this.persistent.xpRate), this.persistent.xp > this.xpForNextLevel())) {
                (this.persistent.xp -= this.xpForNextLevel()), this.persistent.level++, this.upgrades.applyUpgrades(), this.model.sendMessage("Skeleton Champion reached level " + this.persistent.level + "!");
                const e = document.getElementById("skeleton");
                e &&
                    (e.classList.toggle("levelup"),
                        setTimeout(function () {
                            e.classList.toggle("levelup");
                        }, 3e3));
            }
        }
        isAlive() {
            for (let e = 0; e < this.skeletons.length; e++) if (!this.skeletons[e].flags.dead) return !0;
            return !1;
        }
        applyUpgrades() {
            if (this.persistent.skeletons > 0) {
                this.applyItemUpgrades();
                const e = 1 + this.persistent.level / 100;
                (this.model.bloodPCMod *= e), (this.model.brainsPCMod *= e), (this.model.bonesPCMod *= e), (this.model.partsPCMod *= e), (this.model.zombieDamagePCMod *= e), (this.model.zombieHealthPCMod *= e);
            }
        }
        acceptOffer() {
            (this.model.persistentData.trophies = []),
                this.persistent.skeletons < 1 ? ((this.persistent.skeletons = 1), (this.persistent.xpRate = 1), this.model.sendMessage("Skeleton Champion joins the fight!")) : (this.persistent.xpRate *= 2),
                this.upgrades.applyUpgrades(),
                this.model.saveData();
        }
        populate() {
            if (
                ((this.model = ne.getInstance()),
                    (this.map = new MapManager()),
                    (this.graveyard = new Oe()),
                    (this.exclamations = new it()),
                    (this.bullets = new rt()),
                    (this.spells = new SpellManager()),
                    (this.smoke = new ot()),
                    (this.upgrades = new oe()),
                    (this.humans = new HumanManager()),
                    (this.zombies = new ZombieManager()),
                    (this.prestigePoints = new Je()),
                    (this.partFactory = new se()),
                    (this.bones = new tt()),
                    (this.blasts = new nt()),
                    (this.blood = new _e()),
                    (this.damageZombie = this.zombies.damageZombie),
                    (this.searchClosestTarget = this.zombies.searchClosestTarget),
                    (this.updateBurns = this.zombies.updateBurns),
                    (this.updateZombieRegen = this.zombies.updateZombieRegen),
                    (this.causePlagueExplosion = this.zombies.causePlagueExplosion),
                    (this.inflictPlague = this.zombies.inflictPlague),
                    (this.healZombie = this.zombies.healZombie),
                    (this.setSpeedMultiplier = this.zombies.setSpeedMultiplier),
                    !this.textures.set)
            ) {
                (this.textures.down = []), (this.textures.up = []), (this.textures.right = []), (this.textures.dead = []);
                for (let e = 0; e < 3; e++) this.textures.down.push(PIXI.Texture.from("skeleton" + e + ".png"));
                for (let e = 3; e < 6; e++) this.textures.up.push(PIXI.Texture.from("skeleton" + e + ".png"));
                for (let e = 6; e < 9; e++) this.textures.right.push(PIXI.Texture.from("skeleton" + e + ".png"));
                this.textures.dead.push(PIXI.Texture.from("skeleton9.png")), (this.textures.set = !0);
            }
            const e = [];
            for (let t = 0; t < this.skeletons.length; t++)
                this.skeletons[t].flags.dead
                    ? (this.discardedSprites.push(this.skeletons[t]), g.removeChild(this.skeletons[t]))
                    : (e.push(this.skeletons[t]),
                        (this.skeletons[t].x = this.graveyard.sprite.x),
                        (this.skeletons[t].zIndex = this.skeletons[t].y = this.graveyard.sprite.y + (this.graveyard.level > 2 ? 8 : 0)),
                        (this.skeletons[t].target = null),
                        (this.skeletons[t].state = be.lookingForTarget),
                        (this.skeletons[t].timer.scan = 0));
            (this.skeletons = e), (this.aliveSkeletons = []), (this.lootChance = 0.001), this.model.level < this.persistent.level && (this.lootChance *= 0.5), this.model.level > 2 * this.persistent.level && (this.lootChance *= 1.5);
        }
        spawnCreature() {
            let e;
            this.discardedSprites.length > 0 ? ((e = this.discardedSprites.pop()), (e.textures = this.textures.down)) : ((e = new Le(this.textures.down)), e.addChild(e.boneshieldContainer), e.boneshieldContainer.position.set(0, -16)),
                (e.tint = 15658734),
                (e.immuneToBurns = !1),
                (e.bulletReflect = 0),
                (e.zombie = !0),
                (e.textureSet = this.textures),
                (e.deadTexture = this.textures.dead),
                (e.currentDirection = this.directions.down),
                (e.flags = new K()),
                (e.burnDamage = 0),
                (e.lastKnownBuilding = !1),
                (e.alpha = 1),
                (e.animationSpeed = 0.15),
                e.anchor.set(8.5 / 16, 1),
                e.position.set(this.graveyard.sprite.x, this.graveyard.sprite.y + (this.graveyard.level > 2 ? 8 : 0)),
                (e.target = null),
                (e.zIndex = e.position.y),
                (e.visible = !0),
                (e.maxHealth = e.health = 10 * this.model.zombieHealth),
                (e.attackDamage = 10 * this.model.zombieDamage),
                (e.regenTimer = 5),
                (e.state = be.lookingForTarget),
                (e.scaling = this.scaling),
                e.scale.set(e.scaling, e.scaling),
                (e.timer.ability = 4 * Math.random()),
                (e.timer.attack = 0),
                (e.timer.scan = 0),
                (e.timer.burnTick = this.burnTickTimer),
                (e.timer.smoke = this.smokeTimer),
                (e.xSpeed = 0),
                (e.ySpeed = 0),
                (e.speedMultiplier = 1),
                (e.maxSpeed = this.moveSpeed),
                e.play(),
                (e.zombieId = this.currId++),
                this.skeletons.push(e),
                g.addChild(e),
                this.smoke.newZombieSpawnCloud(e.x, e.y - 2);
        }
        skeletonTimer() {
            return this.aliveSkeletons.length < this.persistent.skeletons ? this.spawnTimer : 0;
        }
        update(e) {
            (this.aliveHumans = this.humans.aliveHumans), (this.graveyardAttackers = this.humans.graveyardAttackers), (this.aliveZombies = this.zombies.aliveZombies), (this.aliveSkeletons = []), (this.spellTimer -= e);
            for (let t = 0; t < this.skeletons.length; t++)
                this.skeletons[t].visible && (this.updateCreature(this.skeletons[t], e), this.skeletons[t].flags.dead || (this.aliveZombies.push(this.skeletons[t]), this.aliveSkeletons.push(this.skeletons[t])));
            this.aliveSkeletons.length < this.persistent.skeletons && ((this.spawnTimer -= e), this.spawnTimer < 0 && (this.spawnCreature(), (this.spawnTimer = this.respawnTime))), (this.lastKillingBlow -= e);
        }
        updateCreature(e, t) {
            if (e.flags.dead) {
                if (!e.visible) return;
                return (e.alpha -= this.fadeSpeed * t), void (e.alpha < 0 && ((e.visible = !1), g.removeChild(e)));
            }
            switch (
            (this.boneshield > 0 && e.boneshield < this.boneshield && ((e.boneshieldTimer -= t), e.boneshieldTimer < 0 && ((e.boneshieldTimer = 10 / this.boneshield), e.boneshield++)),
                this.boneshield ? ((e.boneshieldContainer.visible = !0), e.boneshieldContainer.update(e.boneshield), (e.boneshieldContainer.rotation += t)) : (e.boneshieldContainer.visible = !1),
                this.darkorb > 0 && ((this.darkorbTimer -= t), this.darkorbTimer < 0 && e.target && !e.target.flags.dead && ((this.darkorbTimer = this.darkorb), this.bullets.newBullet(e, e.target, this.calculateDamage(e), !1, !1, !1, !0))),
                (e.timer.attack -= t),
                (e.timer.scan -= t),
                (e.timer.ability -= t),
                this.model.runeEffects.healthRegen > 0 && this.updateZombieRegen(e, t),
                e.flags.burning && !e.immuneToBurns && this.updateBurns(e, t),
                e.timer.ability < 0 && (e.timer.ability = 4),
                (e.target && !e.target.flags.dead) || ((e.state = be.lookingForTarget), (e.timer.target = 0), (e.timer.scan = 0)),
                e.state)
            ) {
                case be.lookingForTarget:
                    this.searchClosestTarget(e), e.target && (e.state = be.movingToTarget);
                    break;
                case be.movingToTarget: {
                    const s = this.fastDistance(e.position.x, e.position.y, e.target.x, e.target.y);
                    if (s < this.attackDistance) {
                        e.state = be.attackingTarget;
                        break;
                    }
                    s > 3 * this.attackDistance && e.timer.scan < 0 && this.searchClosestTarget(e), this.updateCreatureSpeed(e, t);
                    break;
                }
                case be.attackingTarget: {
                    const s = this.fastDistance(e.position.x, e.position.y, e.target.x, e.target.y);
                    if (s < this.attackDistance) {
                        if (
                            e.timer.attack < 0 &&
                            !e.target.flags.dead &&
                            (this.humans.damageHuman(e.target, this.calculateDamage(e)),
                                e.target.flags.dead && this.killingBlow(e.target),
                                (e.timer.attack = this.attackSpeed * (1 / this.model.runeEffects.attackSpeed)),
                                e.flags.burning && (e.timer.attack *= 1 / this.model.burningSpeedMod),
                                this.randomSpells.length > 0)
                        )
                            for (let e = 0; e < this.randomSpells.length; e++) this.spellTimer < 0 && Math.random() < 0.07 && (this.spells.castSpellNoMana(this.randomSpells[e]), (this.spellTimer = 3));
                        s > this.attackDistance / 2 && this.updateCreatureSpeed(e, t);
                    } else e.state = be.movingToTarget;
                    break;
                }
            }
        }
        killingBlow(e) {
            this.killingBlowParts && (this.model.persistentData.parts += this.killingBlowParts * this.partFactory.factoryStats().partsPerSec),
                this.lastKillingBlow <= 0 && (this.model.addPrestigePoints(this.persistent.level), (this.lastKillingBlow = 20), this.prestigePoints.newPart(e.x, e.y));
        }
        orbHit(e) {
            if ((e.flags.dead && this.killingBlow(e), this.randomSpells.length > 0))
                for (let e = 0; e < this.randomSpells.length; e++) this.spellTimer < 0 && Math.random() < 0.04 && (this.spells.castSpellNoMana(this.randomSpells[e]), (this.spellTimer = 3));
        }
        incinerate() {
            let e;
            for (let t = 0; t < this.skeletons.length; t++) this.skeletons[t].visible && (e = this.skeletons[t]);
            if (e) for (let t = 0; t < this.aliveHumans.length; t++) Math.abs(this.aliveHumans[t].x - e.x) < 200 && Math.abs(this.aliveHumans[t].y - e.y) < 200 && this.humans.burnHuman(this.aliveHumans[t], e.attackDamage);
        }
        getCreatureDirection(e) {
            return Math.abs(e.xSpeed) > Math.abs(e.ySpeed) ? (e.xSpeed < 0 ? this.directions.left : this.directions.right) : e.ySpeed < 0 ? this.directions.up : this.directions.down;
        }
        changeTextureDirection(e) {
            const t = this.getCreatureDirection(e);
            if (t !== e.currentDirection) {
                switch (t) {
                    case this.directions.up:
                        (e.textures = e.textureSet.up), (e.scale.x = e.scaling);
                        break;
                    case this.directions.down:
                        (e.textures = e.textureSet.down), (e.scale.x = e.scaling);
                        break;
                    case this.directions.right:
                        (e.textures = e.textureSet.right), (e.scale.x = e.scaling);
                        break;
                    case this.directions.left:
                        (e.textures = e.textureSet.right), (e.scale.x = -e.scaling);
                }
                (e.currentDirection = t), e.play();
            }
        }
        updateCreatureSpeed(e, t) {
            if (e.timer.dogStun > 0) return void (e.timer.dogStun -= t);
            (e.timer.target && e.targetVector) || (e.timer.target = 0), (e.timer.target -= t), e.timer.target <= 0 && ((e.targetVector = this.map.howDoIGetToMyTarget(e, e.target)), (e.timer.target = 0.2));
            const s = 4 * this.fastDistance(e.x, e.y, e.target.x, e.target.y),
                i = Math.min(e.speedMultiplier * e.maxSpeed, s);
            (e.xSpeed = e.targetVector.x * i), (e.ySpeed = e.targetVector.y * i), (e.position.x += e.xSpeed * t), (e.position.y += e.ySpeed * t), (e.zIndex = e.position.y), this.changeTextureDirection(e);
        }
        calculateDamage(e) {
            let t = e.attackDamage;
            return this.model.runeEffects.critChance > 0 && Math.random() < this.model.runeEffects.critChance && ((t *= this.model.runeEffects.critDamage), He(e.x, e.y - 10, t)), t;
        }
        applyItemUpgrades() {
            (this.model = ne.getInstance()),
                (this.moveSpeed = 40),
                (this.respawnTime = 10),
                (this.randomSpells = []),
                this.persistent.items
                    .filter((e) => e.q)
                    .forEach((e) => {
                        e.e.forEach((t) => {
                            switch (t) {
                                case this.stats.respawnTime.id:
                                    this.respawnTime--;
                                    break;
                                case this.stats.speed.id:
                                    this.moveSpeed++;
                                    break;
                                case this.stats.zombieHealth.id:
                                    this.model.zombieHealth += e.l * this.stats.zombieHealth.scaling;
                                    break;
                                case this.stats.zombieDamage.id:
                                    this.model.zombieDamage += e.l * this.stats.zombieDamage.scaling;
                                    break;
                                case this.stats.zombieSpeed.id:
                                    this.model.zombieSpeed++;
                            }
                        }),
                            e.se &&
                            e.se.forEach((e) => {
                                this.randomSpells.push(e);
                            });
                    });
        }
        getLootName(e) {
            let t = "";
            switch (e.r) {
                case this.rarity.common:
                    t = this.prefixes.commonQuality[e.p];
                    break;
                case this.rarity.rare:
                    t = this.prefixes.rareQuality[e.p];
                    break;
                case this.rarity.epic:
                    t = this.prefixes.epicQuality[e.p];
                    break;
                case this.rarity.legendary:
                    t = this.prefixes.legendaryQuality[e.p];
            }
            let s = "";
            switch (e.s) {
                case this.lootPositions.helmet.id:
                    s = this.lootPositions.helmet.name;
                    break;
                case this.lootPositions.chest.id:
                    s = this.lootPositions.chest.name;
                    break;
                case this.lootPositions.legs.id:
                    s = this.lootPositions.legs.name;
                    break;
                case this.lootPositions.gloves.id:
                    s = this.lootPositions.gloves.name;
                    break;
                case this.lootPositions.boots.id:
                    s = this.lootPositions.boots.name;
                    break;
                case this.lootPositions.sword.id:
                    s = this.lootPositions.sword.name;
                    break;
                case this.lootPositions.shield.id:
                    s = this.lootPositions.shield.name;
            }
            return t + " " + s;
        }
        getLootClass(e) {
            switch (e.r) {
                case this.rarity.common:
                    return "common";
                case this.rarity.rare:
                    return "rare";
                case this.rarity.epic:
                    return "epic";
                case this.rarity.legendary:
                    return "legendary";
            }
        }
        getLootStats(e) {
            const t = [];
            if (e.e)
                for (let s = 0; s < e.e.length; s++)
                    switch (e.e[s]) {
                        case this.stats.respawnTime.id:
                            t.push("-1 second respawn time");
                            break;
                        case this.stats.speed.id:
                            t.push("+1 movement speed");
                            break;
                        case this.stats.zombieHealth.id:
                            t.push("+" + n(this.stats.zombieHealth.scaling * e.l) + " zombie health");
                            break;
                        case this.stats.zombieDamage.id:
                            t.push("+" + n(this.stats.zombieDamage.scaling * e.l) + " zombie damage");
                            break;
                        case this.stats.zombieSpeed.id:
                            t.push("+1 zombie speed");
                    }
            return t;
        }
        getSpecialEffects(e) {
            const t = [];
            if (e.se)
                for (let s = 0; s < e.se.length; s++) {
                    const i = this.spells.spells.filter((t) => t.id == e.se[s])[0];
                    t.push(i.itemText || "Has a chance to cast " + i.name + " when attacking, this does not cost energy or trigger a cooldown");
                }
            return t;
        }
        testForLoot() {
            if (this.persistent.skeletons > 0 && Math.random() < this.lootChance) {
                const e = this.generateLoot(this.persistent.level);
                this.model.sendMessage(this.getLootName(e) + " collected!"), this.persistent.items.push(e);
            }
        }
        generateLoot(e) {
            const t = Math.round(6 * Math.random()) + 1;
            let s = this.rarity.common;
            const i = [];
            if (Math.random() < 0.2 * this.lootChanceMod && ((s = this.rarity.rare), Math.random() < 0.2 * this.lootChanceMod && ((s = this.rarity.epic), Math.random() < 0.1 * this.lootChanceMod))) {
                s = this.rarity.legendary;
                const e = a(this.spells.spells, Math.random());
                i.push(e.id);
            }
            let r = 0;
            switch (s) {
                case this.rarity.common:
                    r = Math.floor(Math.random() * this.prefixes.commonQuality.length);
                    break;
                case this.rarity.rare:
                    r = Math.floor(Math.random() * this.prefixes.rareQuality.length);
                    break;
                case this.rarity.epic:
                    r = Math.floor(Math.random() * this.prefixes.epicQuality.length);
                    break;
                case this.rarity.legendary:
                    r = Math.floor(Math.random() * this.prefixes.legendaryQuality.length);
            }
            const n = [Math.random() > 0.5 ? this.stats.zombieHealth.id : this.stats.zombieDamage.id];
            for (let e = 0; e < s - 1; e++) {
                let e = Math.ceil(5 * Math.random());
                for (; n.includes(e);) e = Math.ceil(5 * Math.random());
                n.push(e);
            }
            return { id: this.persistent.currItemId++, l: e, s: t, r: s, p: r, e: n, se: i, q: !1 };
        }
        destroyItem(e) {
            this.addXp(e.l * e.r * 10);
            for (let t = 0; t < this.persistent.items.length; t++) this.persistent.items[t].id === e.id && this.persistent.items.splice(t, 1);
        }
        destroyAllItems() {
            this.addXp(this.xpForItems()), (this.persistent.items = this.persistent.items.filter((e) => e.q || e.r == this.rarity.legendary));
        }
        xpForItems() {
            let e = 0;
            return (
                this.persistent.items
                    .filter((e) => !e.q && e.r != this.rarity.legendary)
                    .forEach(function (t) {
                        e += t.l * t.r * 10;
                    }),
                e
            );
        }
    }
    class Ue {
        constructor() {
            if (
                ((this.creatureFactory = new CreatureFactory()),
                    (this.zombies = new ZombieManager()),
                    (this.creatures = []),
                    (this.creatureCount = []),
                    (this.aliveCreatures = []),
                    (this.aliveZombies = []),
                    (this.graveyardAttackers = []),
                    (this.discardedSprites = []),
                    (this.aliveHumans = []),
                    (this.scaling = 1.6),
                    (this.moveTargetDistance = 15),
                    (this.attackDistance = 20),
                    (this.attackSpeed = 3),
                    (this.targetDistance = 100),
                    (this.fadeSpeed = 0.1),
                    (this.currId = 1),
                    (this.scanTime = 3),
                    (this.refundChance = 0),
                    (this.creatureTypes = this.creatureFactory.types),
                    (this.golemTextures = { set: !1, down: [], up: [], left: [], right: [], dead: [] }),
                    (this.directions = { down: 1, up: 2, right: 3, left: 4, dead: 5 }),
                    (this.burnTickTimer = 5),
                    (this.smokeTimer = 0.3),
                    (this.fastDistance = i),
                    (this.magnitude = t),
                    (this.damageZombie = this.zombies.damageZombie),
                    (this.searchClosestTarget = this.zombies.searchClosestTarget),
                    (this.updateBurns = this.zombies.updateBurns),
                    (this.updateZombieRegen = this.zombies.updateZombieRegen),
                    (this.causePlagueExplosion = this.zombies.causePlagueExplosion),
                    (this.inflictPlague = this.zombies.inflictPlague),
                    (this.healZombie = this.zombies.healZombie),
                    (this.setSpeedMultiplier = this.zombies.setSpeedMultiplier),
                    Ue.instance)
            )
                return Ue.instance;
            Ue.instance = this;
        }
        populate() {
            if (
                ((this.map = new MapManager()),
                    (this.model = ne.getInstance()),
                    (this.graveyard = new Oe()),
                    (this.smoke = new ot()),
                    (this.bullets = new rt()),
                    (this.humans = new HumanManager()),
                    (this.exclamations = new it()),
                    (this.blood = new _e()),
                    (this.bones = new tt()),
                    (this.blasts = new nt()),
                    !this.golemTextures.set)
            ) {
                (this.golemTextures.down = []), (this.golemTextures.up = []), (this.golemTextures.right = []), (this.golemTextures.dead = []);
                for (let e = 0; e < 3; e++) this.golemTextures.down.push(PIXI.Texture.from("golem" + e + ".png"));
                for (let e = 3; e < 6; e++) this.golemTextures.up.push(PIXI.Texture.from("golem" + e + ".png"));
                for (let e = 6; e < 9; e++) this.golemTextures.right.push(PIXI.Texture.from("golem" + e + ".png"));
                this.golemTextures.dead.push(PIXI.Texture.from("golem9.png")), (this.golemTextures.set = !0);
            }
            const e = [];
            for (let t = 0; t < this.creatures.length; t++)
                this.model.constructions.monsterFactory
                    ? this.creatures[t].flags.dead
                        ? (this.discardedSprites.push(this.creatures[t]), g.removeChild(this.creatures[t]))
                        : (e.push(this.creatures[t]),
                            (this.creatures[t].x = this.graveyard.sprite.x),
                            (this.creatures[t].zIndex = this.creatures[t].y = this.graveyard.sprite.y + (this.graveyard.level > 2 ? 8 : 0)),
                            (this.creatures[t].target = null),
                            (this.creatures[t].state = be.lookingForTarget))
                    : (this.discardedSprites.push(this.creatures[t]), g.removeChild(this.creatures[t]));
            (this.creatures = e), (this.aliveCreatures = []), this.creatureFactory.spawnSavedCreatures();
        }
        spawnCreature(e, t, s, i, a, r) {
            if (this.model.creatureCount >= this.model.creatureLimit) return;
            let n;
            switch ((this.discardedSprites.length > 0 ? ((n = this.discardedSprites.pop()), (n.textures = this.golemTextures.down)) : (n = new Pe(this.golemTextures.down)), i)) {
                case this.creatureTypes.earthGolem:
                    (n.tint = 11042610), (n.bulletReflect = this.model.bulletproofChance);
                    break;
                case this.creatureTypes.airGolem:
                    n.tint = 10266040;
                    break;
                case this.creatureTypes.fireGolem:
                    (n.tint = 14370586), (n.immuneToBurns = !0);
                    break;
                case this.creatureTypes.waterGolem:
                    (n.tint = 5080808), (n.immuneToBurns = !0);
            }
            (n.flags = new K()),
                (n.flags.golem = !0),
                (n.burnDamage = 0),
                (n.level = a),
                (n.textureSet = this.golemTextures),
                (n.deadTexture = this.golemTextures.dead),
                (n.currentDirection = this.directions.down),
                (n.creatureType = i),
                (n.price = r),
                (n.lastKnownBuilding = !1),
                (n.alpha = 1),
                (n.animationSpeed = 0.15),
                n.anchor.set(8.5 / 16, 1),
                n.position.set(this.graveyard.sprite.x, this.graveyard.sprite.y + (this.graveyard.level > 2 ? 8 : 0)),
                (n.target = null),
                (n.zIndex = n.position.y),
                (n.visible = !0),
                (n.maxHealth = n.health = e),
                (n.attackDamage = t),
                (n.regenTimer = 5),
                (n.state = be.lookingForTarget),
                (n.scaling = this.scaling),
                n.scale.set(n.scaling, n.scaling),
                (n.xSpeed = 0),
                (n.ySpeed = 0),
                (n.speedMultiplier = 1),
                (n.maxSpeed = s),
                (n.timer.ability = 4 * Math.random()),
                (n.timer.attack = 0),
                (n.timer.scan = 0),
                (n.timer.burnTick = this.burnTickTimer),
                (n.timer.smoke = this.smokeTimer),
                n.play(),
                (n.zombieId = this.currId++),
                this.creatures.push(n),
                g.addChild(n),
                this.smoke.newZombieSpawnCloud(n.x, n.y - 2),
                this.model.creatureCount++;
        }
        update(e) {
            let t = 0;
            (this.aliveHumans = this.humans.aliveHumans), (this.graveyardAttackers = this.humans.graveyardAttackers), (this.aliveZombies = this.zombies.aliveZombies), (this.creatureCount = []);
            for (let e = 0; e < this.creatureFactory.creatures.length; e++) this.creatureCount[this.creatureFactory.creatures[e].type] = 0;
            this.model.persistentData.savedCreatures = [];
            for (let t = 0; t < this.creatures.length; t++) this.creatures[t].visible && this.updateCreature(this.creatures[t], e);
            for (let e = 0; e < this.creatures.length; e++)
                this.creatures[e].visible &&
                    (this.creatures[e].flags.dead ||
                        (this.aliveZombies.push(this.creatures[e]),
                            t++,
                            this.creatureCount[this.creatures[e].creatureType]++,
                            this.model.persistentData.savedCreatures.push({ t: this.creatures[e].creatureType, l: this.creatures[e].level })));
            this.model.creatureCount = t;
        }
        updateCreature(e, t) {
            if (e.flags.dead) {
                if (!e.visible) return;
                return (e.alpha -= this.fadeSpeed * t), void (e.alpha < 0 && ((e.visible = !1), g.removeChild(e)));
            }
            if (
                ((e.timer.attack -= t), (e.timer.scan -= t), (e.timer.ability -= t), this.model.runeEffects.healthRegen > 0 && this.updateZombieRegen(e, t), e.flags.burning && !e.immuneToBurns && this.updateBurns(e, t), e.timer.ability < 0)
            )
                switch (((e.timer.ability = 4), e.creatureType)) {
                    case this.creatureTypes.earthGolem:
                        this.golemTaunt(e);
                        break;
                    case this.creatureTypes.waterGolem:
                        this.golemHeal(e);
                        break;
                    case this.creatureTypes.fireGolem:
                        this.golemFireball(e);
                }
            switch (((!e.target || e.target.flags.dead) && e.timer.scan < 0 && (e.state = be.lookingForTarget), e.state)) {
                case be.lookingForTarget:
                    this.searchClosestTarget(e), e.target && (e.state = be.movingToTarget);
                    break;
                case be.movingToTarget: {
                    const s = this.fastDistance(e.position.x, e.position.y, e.target.x, e.target.y);
                    if (s < this.attackDistance) {
                        e.state = be.attackingTarget;
                        break;
                    }
                    s > 3 * this.attackDistance && e.timer.scan < 0 && this.searchClosestTarget(e), this.updateCreatureSpeed(e, t);
                    break;
                }
                case be.attackingTarget: {
                    const s = this.fastDistance(e.position.x, e.position.y, e.target.x, e.target.y);
                    s < this.attackDistance
                        ? ((e.scale.x = e.target.x > e.x ? e.scaling : -e.scaling),
                            e.timer.attack < 0 &&
                            (this.humans.damageHuman(e.target, this.calculateDamage(e)),
                                e.creatureType == this.creatureTypes.fireGolem && this.humans.burnHuman(e.target, e.attackDamage / 2),
                                (e.timer.attack = this.attackSpeed * (1 / this.model.runeEffects.attackSpeed)),
                                e.flags.burning && (e.timer.attack *= 1 / this.model.burningSpeedMod)),
                            s > this.attackDistance / 2 && this.updateCreatureSpeed(e, t))
                        : (e.state = be.movingToTarget);
                    break;
                }
            }
        }
        getCreatureDirection(e) {
            return Math.abs(e.xSpeed) > Math.abs(e.ySpeed) ? (e.xSpeed < 0 ? this.directions.left : this.directions.right) : e.ySpeed < 0 ? this.directions.up : this.directions.down;
        }
        changeTextureDirection(e) {
            const t = this.getCreatureDirection(e);
            if (t !== e.currentDirection) {
                switch (t) {
                    case this.directions.up:
                        (e.textures = e.textureSet.up), (e.scale.x = e.scaling);
                        break;
                    case this.directions.down:
                        (e.textures = e.textureSet.down), (e.scale.x = e.scaling);
                        break;
                    case this.directions.right:
                        (e.textures = e.textureSet.right), (e.scale.x = e.scaling);
                        break;
                    case this.directions.left:
                        (e.textures = e.textureSet.right), (e.scale.x = -e.scaling);
                }
                (e.currentDirection = t), e.play();
            }
        }
        updateCreatureSpeed(e, t) {
            if (e.timer.dogStun && e.timer.dogStun > 0) return void (e.timer.dogStun -= t);
            (e.timer.target && e.targetVector) || (e.timer.target = 0), (e.timer.target -= t), e.timer.target <= 0 && ((e.targetVector = this.map.howDoIGetToMyTarget(e, e.target)), (e.timer.target = 0.2));
            const s = e.speedMultiplier * e.maxSpeed;
            (e.xSpeed = e.targetVector.x * s), (e.ySpeed = e.targetVector.y * s), (e.position.x += e.xSpeed * t), (e.position.y += e.ySpeed * t), (e.zIndex = e.position.y), this.changeTextureDirection(e);
        }
        calculateDamage(e) {
            let t = e.attackDamage;
            return this.model.runeEffects.critChance > 0 && Math.random() < this.model.runeEffects.critChance && ((t *= this.model.runeEffects.critDamage), He(e.x, e.y - 10, t)), t;
        }
        golemTaunt(e) {
            for (let t = 0; t < this.aliveHumans.length; t++)
                Math.abs(this.aliveHumans[t].x - e.x) < this.targetDistance &&
                    Math.abs(this.aliveHumans[t].y - e.y) < this.targetDistance &&
                    (this.aliveHumans[t].vip || ((this.aliveHumans[t].zombieTarget = e), (this.aliveHumans[t].target = e)));
        }
        golemHeal(e) {
            const t = e.attackDamage;
            for (let s = 0; s < this.aliveZombies.length; s++) Math.abs(this.aliveZombies[s].x - e.x) < this.targetDistance && Math.abs(this.aliveZombies[s].y - e.y) < this.targetDistance && this.healZombie(this.aliveZombies[s], t);
            for (let s = 0; s < this.creatures.length; s++)
                !this.creatures[s].flags.dead && this.creatures[s].visible && Math.abs(this.creatures[s].x - e.x) < this.targetDistance && Math.abs(this.creatures[s].y - e.y) < this.targetDistance && this.healZombie(this.creatures[s], t);
        }
        golemFireball(e) {
            let t = 5;
            for (let s = 0; s < this.aliveHumans.length; s++)
                t > 0 && Math.abs(this.aliveHumans[s].x - e.x) < this.targetDistance && Math.abs(this.aliveHumans[s].y - e.y) < this.targetDistance && (t--, this.bullets.newBullet(e, this.aliveHumans[s], e.attackDamage / 2, !1, !1, !0));
        }
    }
    class Ne extends PIXI.Sprite {
        constructor() {
            super(...arguments), (this.graveyard = !0);
        }
    }
    class Oe {
        constructor() {
            if (
                ((this.spikeSprites = []),
                    (this.level = 1),
                    (this.spikeTimer = 5),
                    (this.fenceRadius = 50),
                    (this.fastDistance = i),
                    (this.graveyardHealth = 0),
                    (this.graveyardMaxHealth = 0),
                    (this.target = { graveyard: !0, x: 0, y: 0 }),
                    (this.healthBar = null),
                    (this.fence = null),
                    (this.fencePosts = []),
                    Oe.instance)
            )
                return Oe.instance;
            Oe.instance = this;
        }
        initialize() {
            (this.boneCollectors = new Ve()),
                (this.zmMap = new MapManager()),
                (this.zombies = new ZombieManager()),
                (this.bones = new tt()),
                (this.gameModel = ne.getInstance()),
                (this.smoke = new ot()),
                (this.harpies = new Ke()),
                (this.blood = new _e()),
                (this.humans = new HumanManager()),
                void 0 === this.gameModel.persistentData.graveyardZombies && (this.gameModel.persistentData.graveyardZombies = 1),
                this.drawGraveyard(),
                this.drawFence(),
                this.drawHealthBar(),
                this.bones.initialize(),
                this.boneCollectors.populate(),
                this.harpies.populate();
        }
        damageGraveyard(e) {
            this.gameModel.isBossStage(this.gameModel.level) && ((this.graveyardHealth -= e), this.graveyardHealth < 0 && ((this.gameModel.currentState = this.gameModel.states.failed), (this.gameModel.startTimer = 3)));
        }
        drawHealthBar() {
            this.gameModel.isBossStage(this.gameModel.level)
                ? (this.gameModel.sendMessage("Defend the Graveyard!"),
                    (this.graveyardHealth = this.graveyardMaxHealth = 100 * this.gameModel.zombieHealth * this.gameModel.graveyardHealthMod),
                    this.healthBar ||
                    ((this.healthBar = { container: new PIXI.Container(), background: new PIXI.Graphics(), foreground: new PIXI.Graphics(), percentage: 100 }),
                        this.healthBar.container.addChild(this.healthBar.background),
                        this.healthBar.container.addChild(this.healthBar.foreground),
                        b.addChild(this.healthBar.container)),
                    (this.target.x = P.x / 2),
                    (this.target.y = P.y / 2),
                    (this.healthBar.container.visible = !0),
                    (this.healthBar.container.x = this.target.x - 50),
                    (this.healthBar.container.y = this.target.y - 100),
                    this.healthBar.background.clear(),
                    this.healthBar.background.lineStyle(12, 3355443),
                    this.healthBar.background.moveTo(-2, 0),
                    this.healthBar.background.lineTo(102, 0),
                    this.healthBar.foreground.clear(),
                    this.healthBar.foreground.lineStyle(8, 16601682),
                    this.healthBar.foreground.moveTo(0, 0),
                    this.healthBar.foreground.lineTo(100, 0))
                : this.healthBar && (this.healthBar.background.clear(), this.healthBar.foreground.clear(), (this.healthBar.container.visible = !1));
        }
        updateHealthBar() {
            const e = Math.max(Math.round((this.graveyardHealth / this.graveyardMaxHealth) * 100), 0);
            e != this.healthBar.percentage &&
                (this.healthBar.foreground.clear(), e > 0 && (this.healthBar.foreground.lineStyle(8, 16601682), this.healthBar.foreground.moveTo(0, 0), this.healthBar.foreground.lineTo(e, 0)), (this.healthBar.percentage = e));
        }
        drawGraveyard() {
            this.spikeTexture || (this.spikeTexture = PIXI.Texture.from("spikes.png")), this.sprite && u.removeChild(this.sprite), this.fortSprite && (g.removeChild(this.fortSprite), (this.fortSprite = null)), (this.level = 1);
            let e = "graveyard1.png",
                t = "";
            this.gameModel.constructions.crypt && ((this.level = 2), (e = "graveyard2.png")),
                this.gameModel.constructions.fort && ((this.level = 3), (e = "sprites/megagraveyard.png"), (t = "fort1.png")),
                this.gameModel.constructions.fortress && ((this.level = 4), (e = "sprites/megagraveyard.png"), (t = "fort2.png")),
                this.gameModel.constructions.citadel && ((this.level = 5), (e = "sprites/megagraveyard.png"), (t = "fort3.png")),
                this.sprite ? (this.sprite.texture = PIXI.Texture.from(e)) : (this.sprite = new Ne(PIXI.Texture.from(e)));
            const s = this.zmMap.graveYardLocation;
            (this.sprite.width = 32),
                (this.sprite.height = 32),
                this.sprite.anchor.set(0.5, 0.5),
                this.sprite.scale.set(2, 2),
                (this.sprite.visible = !1),
                u.addChild(this.sprite),
                (this.sprite.x = s.x),
                (this.sprite.y = s.y),
                (this.zmMap.graveyardCollision = !1),
                t &&
                (this.fortSprite ? (this.fortSprite.texture = PIXI.Texture.from(t)) : (this.fortSprite = new PIXI.Sprite(PIXI.Texture.from(t))),
                    this.fortSprite.anchor.set(0.5, 1),
                    this.fortSprite.scale.set(2, 2),
                    (this.fortSprite.x = s.x),
                    (this.fortSprite.zIndex = this.fortSprite.y = s.y + 2),
                    (this.fortSprite.visible = !1),
                    g.addChild(this.fortSprite));
        }
        drawFence() {
            if ((this.fence || ((this.fence = new PIXI.Container()), u.addChild(this.fence)), (this.fenceRadius = this.gameModel.fenceRadius), !this.fenceTextures)) {
                this.fenceTextures = [];
                for (let e = 0; e < 4; e++) this.fenceTextures.push(PIXI.Texture.from("fencepost" + (e + 1) + ".png"));
            }
            this.fencePosts.forEach((e) => (e.visible = !1)), (this.fence.cacheAsBitmap = !1);
            const e = Math.round(0.4 * this.fenceRadius),
                t = (2 * Math.PI) / e;
            for (let r = 0; r < e; r++) {
                let e;
                this.fencePosts[r] ? ((e = this.fencePosts[r]), (e.visible = !0)) : ((e = new PIXI.Sprite(a(this.fenceTextures, Math.random()))), this.fencePosts.push(e), this.fence.addChild(e)),
                    e.anchor.set(0.5, 1),
                    (e.scale.x = Math.random() > 0.5 ? 1 : -1);
                const n = 10 * Math.random() - 5,
                    o = (0, (s = this.fenceRadius + n), (i = t * r), { x: 0 * Math.cos(i) - s * Math.sin(i), y: 0 * Math.sin(i) + s * Math.cos(i) });
                e.position.set(o.x, o.y);
            }
            var s, i;
            this.fence.cacheAsBitmap = !0;
            const r = this.zmMap.graveYardLocation;
            (this.fence.x = r.x), (this.fence.y = r.y);
        }
        update(e) {
            if (
                (this.boneCollectors.addAndRemoveBoneCollectors(),
                    this.harpies.addAndRemoveHarpies(),
                    this.gameModel.isBossStage(this.gameModel.level) && this.updateHealthBar(),
                    !this.gameModel.constructions.graveyard || this.gameModel.currentState != this.gameModel.states.playingLevel)
            )
                return (this.sprite.visible = !1), void (this.fence.visible = !1);
            if (
                (((this.level < 2 && this.gameModel.constructions.crypt) ||
                    (this.level < 3 && this.gameModel.constructions.fort) ||
                    (this.level < 4 && this.gameModel.constructions.fortress) ||
                    (this.level < 5 && this.gameModel.constructions.citadel)) &&
                    this.drawGraveyard(),
                    (this.sprite.visible = !0),
                    this.fortSprite && (this.fortSprite.visible = !0),
                    5 == this.level && Math.random() > 0.9 && (Math.random() > 0.5 ? this.smoke.newFireSmoke(this.sprite.x - 20, this.sprite.y - 113) : this.smoke.newFireSmoke(this.sprite.x + 20, this.sprite.y - 113)),
                    this.gameModel.energy >= this.gameModel.energyMax && !this.gameModel.hidden)
            )
                for (let e = 0; e < this.gameModel.persistentData.graveyardZombies; e++) this.zombies.spawnZombie(this.sprite.x, this.sprite.y + (this.level > 2 ? 8 : 0));
            this.bones.update(e),
                this.boneCollectors.update(e),
                this.harpies.update(e),
                this.gameModel.constructions.fence && this.gameModel.currentState == this.gameModel.states.playingLevel
                    ? (this.fenceRadius !== this.gameModel.fenceRadius && this.drawFence(), (this.fence.visible = !0))
                    : (this.fence.visible = !1),
                this.updatePlagueSpikes(e),
                this.updateSpikeSprites(e);
        }
        updatePlagueSpikes(e) {
            if (this.gameModel.constructions.plagueSpikes && ((this.spikeTimer -= e), this.spikeTimer < 0)) {
                this.spikeTimer = this.gameModel.spikeDelay;
                const e = this.humans.aliveHumans;
                for (let t = 0; t < e.length; t++)
                    Math.abs(e[t].x - this.sprite.x) < this.fenceRadius &&
                        Math.abs(e[t].y - this.sprite.y) < this.fenceRadius &&
                        this.fastDistance(this.sprite.x, this.sprite.y, e[t].x, e[t].y) < this.fenceRadius &&
                        (this.zombies.inflictPlague(e[t]), this.humans.damageHuman(e[t], this.gameModel.zombieDamage), this.blood.newPlagueSplatter(e[t].x, e[t].y), this.addSpikeSprite(e[t]));
            }
        }
        addSpikeSprite(e) {
            let t = null;
            for (let e = 0; e < this.spikeSprites.length; e++)
                if (!this.spikeSprites[e].visible) {
                    t = this.spikeSprites[e];
                    break;
                }
            t || ((t = new PIXI.Sprite(this.spikeTexture)), this.spikeSprites.push(t), g.addChild(t), t.anchor.set(0.5, 1)),
                (t.visible = !0),
                (t.alpha = 1),
                (t.x = e.x),
                (t.y = e.y + 2),
                (t.zIndex = t.y),
                (t.scale.y = 2),
                (t.scale.x = Math.random() > 0.5 ? 1.5 : -1.5);
        }
        updateSpikeSprites(e) {
            for (let t = 0; t < this.spikeSprites.length; t++) this.spikeSprites[t].visible && ((this.spikeSprites[t].alpha -= 0.4 * e), this.spikeSprites[t].alpha <= 0 && (this.spikeSprites[t].visible = !1));
        }
        isWithinFence(e) {
            return (
                !(!this.gameModel.constructions.fence || this.gameModel.currentState != this.gameModel.states.playingLevel) &&
                e.x > this.fence.x - this.fenceRadius &&
                e.x < this.fence.x + this.fenceRadius &&
                e.y > this.fence.y - this.fenceRadius &&
                e.y < this.fence.y + this.fenceRadius &&
                this.fastDistance(e.x, e.y, this.fence.x, this.fence.y) <= this.fenceRadius
            );
        }
    }
    class Ye extends PIXI.AnimatedSprite {
        constructor(e) {
            super(e), (this.xSpeed = 0), (this.ySpeed = 0), (this.bones = 0), (this.speedFactor = 0), (this.boneList = []), (this.target = null), (this.animationSpeed = 0.2);
        }
    }
    var We, qe;
    !(function (e) {
        (e[(e.collecting = 0)] = "collecting"), (e[(e.returning = 1)] = "returning"), (e[(e.waiting = 2)] = "waiting");
    })(We || (We = {}));
    class Ve {
        constructor() {
            if (((this.sprites = []), (this.maxSpeed = 125), (this.scaling = 2), (this.collectDistance = 10), (this.fastDistance = i), Ve.instance)) return Ve.instance;
            Ve.instance = this;
        }
        populate() {
            if (((this.graveyard = new Oe()), (this.gameModel = ne.getInstance()), (this.bones = new tt()), !this.texture)) {
                this.texture = [];
                for (let e = 0; e < 2; e++) this.texture.push(PIXI.Texture.from("bonecollector" + (e + 1) + ".png"));
            }
            for (let e = 0; e < this.sprites.length; e++)
                (this.sprites[e].boneList = []), (this.sprites[e].target = !1), this.sprites[e].position.set(this.graveyard.sprite.x, this.graveyard.sprite.y), (this.sprites[e].state = We.collecting);
        }
        addAndRemoveBoneCollectors() {
            if (this.sprites.length > this.gameModel.persistentData.boneCollectors) {
                const e = this.sprites.pop();
                if (e.boneList) for (let t = 0; t < e.boneList.length; t++) (e.boneList[t].collector = !1), e.target && e.target.collector && (e.target.collector = !1);
                this.gameModel.addBones(e.bones), g.removeChild(e);
            }
            if (this.sprites.length < this.gameModel.persistentData.boneCollectors) {
                const e = new Ye(this.texture);
                (e.animationSpeed = 0.2),
                    e.anchor.set(0.5, 1),
                    e.position.set(this.graveyard.sprite.x, this.graveyard.sprite.y),
                    (e.zIndex = e.position.y),
                    (e.visible = !0),
                    e.scale.set(Math.random() > 0.5 ? this.scaling : -1 * this.scaling, this.scaling),
                    (e.xSpeed = 0),
                    (e.ySpeed = 0),
                    (e.bones = 0),
                    (e.speedFactor = 0),
                    (e.state = We.collecting),
                    e.play(),
                    (e.boneList = []),
                    this.sprites.push(e),
                    g.addChild(e);
            }
        }
        update(e) {
            for (let t = 0; t < this.sprites.length; t++) this.updateBoneCollector(this.sprites[t], e);
        }
        findNearestBone(e) {
            if ((e.boneList || (e.boneList = []), 0 == e.boneList.length)) {
                let t = e.x,
                    s = e.y;
                for (let i = 0; i < 3; i++) {
                    let i = null,
                        a = 2e3;
                    for (let e = 0; e < this.bones.uncollected.length; e++)
                        if (this.bones.uncollected[e].value > 0 && !this.bones.uncollected[e].collector) {
                            const r = this.fastDistance(t, s, this.bones.uncollected[e].x, this.bones.uncollected[e].y);
                            r < a && ((a = r), (i = this.bones.uncollected[e]));
                        }
                    if (!i) break;
                    e.boneList.push(i), (i.collector = !0), (t = i.x), (s = i.y);
                }
            }
            e.boneList.length > 0 ? (e.target = e.boneList.shift()) : (e.target = !1);
        }
        updateBoneCollector(e, t) {
            switch ((!e.target || (e.target.graveyard && e.state == We.collecting) || this.updateSpeed(e, t), e.state)) {
                case We.collecting:
                    if (
                        ((e.target && e.target.value && e.target.visible) || this.findNearestBone(e),
                            e.target && e.target.value > 0 && this.fastDistance(e.position.x, e.position.y, e.target.x, e.target.y) < this.collectDistance && ((e.bones += e.target.value), (e.target.value = 0), (e.speedFactor = 0)),
                            e.bones >= this.gameModel.boneCollectorCapacity || !e.target)
                    )
                        return (e.state = We.returning), void (e.target = this.graveyard.sprite);
                    break;
                case We.returning:
                    e.target || (e.target = this.graveyard.sprite),
                        this.fastDistance(e.position.x, e.position.y, e.target.x, e.target.y) < this.collectDistance && ((e.target = !1), this.gameModel.addBones(e.bones), (e.bones = 0), (e.state = We.collecting), (e.speedFactor = 0));
            }
        }
        updateSpeed(e, t) {
            e.speedFactor = Math.min(1, (e.speedFactor += 3 * t));
            const s = e.target.x - e.x,
                i = e.target.y - e.y,
                a = Math.abs(s),
                r = Math.abs(i);
            if (0 == Math.max(a, r)) return;
            let n = 1 / Math.max(a, r);
            (n *= 1.29289 - (a + r) * n * 0.29289),
                (e.xSpeed = s * n * this.maxSpeed * e.speedFactor),
                (e.ySpeed = i * n * this.maxSpeed * e.speedFactor),
                (e.position.x += e.xSpeed * t),
                (e.position.y += e.ySpeed * t),
                (e.zIndex = e.position.y);
        }
    }
    !(function (e) {
        (e[(e.bombing = 0)] = "bombing"), (e[(e.returning = 1)] = "returning");
    })(qe || (qe = {}));
    class je extends PIXI.AnimatedSprite {
        constructor(e) {
            super(e), (this.target = null), (this.xSpeed = 0), (this.ySpeed = 0), (this.bombs = 0), (this.speedFactor = 0), (this.animationSpeed = 0.2), this.anchor.set(0.5, 1), (this.visible = !0);
        }
    }
    class $e extends PIXI.Sprite {
        constructor(e) {
            super(e), (this.dropped = !1), (this.floor = 0), (this.rotSpeed = 0), (this.xSpeed = 0), (this.ySpeed = 0), (this.fire = !1), this.anchor.set(0.5, 0.5);
        }
    }
    class Ke {
        constructor() {
            if (((this.sprites = []), (this.discardedSprites = []), (this.bombSprites = []), (this.discardedBombSprites = []), (this.bombHeight = 100), (this.scaling = 2.5), (this.fastDistance = i), Ke.instance)) return Ke.instance;
            Ke.instance = this;
        }
        populate() {
            if (((this.model = ne.getInstance()), (this.graveyard = new Oe()), (this.zombies = new ZombieManager()), (this.humans = new HumanManager()), (this.tanks = new De()), !this.textures)) {
                this.textures = [];
                for (let e = 0; e < 2; e++) this.textures.push(PIXI.Texture.from("harpy" + (e + 1) + ".png"));
                this.bombTexture = PIXI.Texture.from("harpybomb.png");
            }
            void 0 === this.model.persistentData.harpies && (this.model.persistentData.harpies = 0);
            for (let e = 0; e < this.bombSprites.length; e++) this.bombSprites[e].visible && ((this.bombSprites[e].visible = !1), this.discardedBombSprites.push(this.bombSprites[e]));
            for (let e = 0; e < this.sprites.length; e++)
                (this.sprites[e].bomb = null), (this.sprites[e].target = !1), this.sprites[e].position.set(this.graveyard.sprite.x, this.graveyard.sprite.y - this.bombHeight), (this.sprites[e].state = qe.returning);
        }
        addAndRemoveHarpies() {
            if (this.sprites.length > this.model.persistentData.harpies) {
                const e = this.sprites.pop();
                (e.target = !1), e.bomb && ((e.bomb.dropped = !0), (e.bomb.floor = e.bomb.y + this.bombHeight)), b.removeChild(e), this.discardedSprites.push(e);
            }
            if (this.sprites.length < this.model.persistentData.harpies) {
                const e = this.discardedSprites.length > 0 ? this.discardedSprites.pop() : new je(this.textures);
                e.position.set(this.graveyard.sprite.x, this.graveyard.sprite.y - this.bombHeight),
                    (e.zIndex = e.position.y),
                    e.scale.set(Math.random() > 0.5 ? this.scaling : -1 * this.scaling, this.scaling),
                    (e.state = qe.returning),
                    e.play(),
                    this.sprites.push(e),
                    b.addChild(e);
            }
        }
        update(e) {
            for (let t = 0; t < this.sprites.length; t++) this.updateHarpy(this.sprites[t], e);
            for (let t = 0; t < this.bombSprites.length; t++) this.bombSprites[t].visible && this.updateBomb(this.bombSprites[t], e);
        }
        updateBomb(e, t) {
            e.dropped
                ? ((e.rotation += t * e.rotSpeed),
                    (e.ySpeed += 50 * t),
                    (e.scale.x = e.scale.y -= 0.2 * t),
                    (e.y += e.ySpeed * t),
                    e.y >= e.floor - 2 &&
                    ((e.visible = !1), this.discardedBombSprites.push(e), e.fire && this.humans.burnHuman(e.target, 0.1 * this.model.zombieHealth), this.zombies.causePlagueExplosion(e, 0.2 * this.model.zombieHealth, !1, !1)))
                : ((e.x = e.harpy.x), (e.y = e.harpy.y));
        }
        updateHarpy(e, t) {
            switch (e.state) {
                case qe.bombing:
                    if (!e.target || e.target.graveyard || e.target.dead)
                        if (this.model.tankBuster && this.model.isBossStage(this.model.level) && this.tanks.aliveTanks.length > 0) (e.target = a(this.tanks.aliveTanks, Math.random())), (e.bomb.fire = !0);
                        else {
                            for (let t = 0; t < 8 && ((e.target = a(this.humans.aliveHumans, Math.random())), e.target && !(this.fastDistance(e.x, e.y, e.target.x, e.target.y - this.bombHeight) < 500)); t++);
                            e.bomb.fire = !1;
                        }
                    if (!e.target) return void (e.state = qe.returning);
                    this.fastDistance(e.x, e.y, e.target.x, e.target.y - this.bombHeight) < 10
                        ? (e.bombs--, (e.bomb.dropped = !0), (e.bomb.floor = e.target.y), (e.bomb.target = e.target), (e.bomb = null), (e.speedFactor = 0), (e.target = !1), e.bombs <= 0 ? (e.state = qe.returning) : this.getBomb(e))
                        : this.updateHarpySpeed(e, t);
                    break;
                case qe.returning:
                    e.target || (e.target = this.graveyard.sprite),
                        this.fastDistance(e.x, e.y, e.target.x, e.target.y - this.bombHeight) < 10 ? ((e.bombs = this.model.harpyBombs), e.bomb || this.getBomb(e), (e.state = qe.bombing), (e.speedFactor = 0)) : this.updateHarpySpeed(e, t);
            }
        }
        getBomb(e) {
            let t;
            this.discardedBombSprites.length > 0 ? (t = this.discardedBombSprites.pop()) : ((t = new $e(this.bombTexture)), this.bombSprites.push(t), b.addChild(t)),
                (t.scale.x = t.scale.y = 2),
                (t.rotation = 0),
                (t.rotSpeed = Math.random() > 0.5 ? 4 : -4),
                (t.ySpeed = 0),
                (t.visible = !0),
                (t.dropped = !1),
                (t.harpy = e),
                (e.bomb = t);
        }
        updateHarpySpeed(e, t) {
            e.speedFactor = Math.min(1, (e.speedFactor += 2 * t));
            const s = e.target.x - e.x,
                i = e.target.y - this.bombHeight - e.y,
                a = Math.abs(s),
                r = Math.abs(i);
            if (0 == Math.max(a, r)) return;
            let n = 1 / Math.max(a, r);
            (n *= 1.29289 - (a + r) * n * 0.29289),
                (e.xSpeed = s * n * this.model.harpySpeed * e.speedFactor),
                (e.ySpeed = i * n * this.model.harpySpeed * e.speedFactor),
                (e.position.x += e.xSpeed * t),
                (e.position.y += e.ySpeed * t),
                (e.scale.x = e.xSpeed > 0 ? this.scaling : -1 * this.scaling);
        }
    }
    class Qe {
        constructor() {
            if (((this.blood = new _e()), (this.smoke = new ot()), (this.prestigePoints = new Je()), (this.bullets = new rt()), (this.exclamations = new it()), (this.blasts = new nt()), (this.fragments = new lt()), Qe.instance))
                return Qe.instance;
            Qe.instance = this;
        }
        initialize() {
            this.blood.initialize(), this.bullets.initialize(), this.exclamations.initialize(), this.blasts.initialize(), this.smoke.initialize(), this.fragments.initialize(), this.prestigePoints.initialize();
        }
        update(e) {
            this.blood.update(e),
                this.bullets.update(e),
                this.exclamations.update(e),
                this.blasts.update(e),
                this.smoke.update(e),
                this.fragments.update(e),
                this.prestigePoints.update(e),
                (function (e) {
                    for (let t = 0; t < Be.length; t++) Be[t].updateCritText(e);
                })(e);
        }
    }
    class Je extends _ {
        constructor() {
            if ((super(), (this.zmMap = new MapManager()), (this.speed = 20), Je.instance)) return Je.instance;
            (Je.instance = this), (this.create = (e) => new J(e));
        }
        initialize() {
            (this.gameModel = ne.getInstance()),
                this.container || (this.setup(new PIXI.Container(), PIXI.Texture.from("pp.png")), b.addChild(this.container)),
                (this.targetElement = document.getElementById("prestige-button")),
                (this.animElement = document.getElementById("prestige-bg"));
        }
        update(e) {
            if (!this.gameModel.persistentData.particles) return void (this.container.visible = !1);
            this.container.visible = !0;
            let t = { x: 0, y: 0 };
            if (null != this.targetElement) {
                const e = this.targetElement.getBoundingClientRect();
                (t = { x: e.x + e.width / 2, y: e.y + e.height / 2 }), (t.x -= c.x), (t.y -= c.y), (t.x = t.x / c.scale.x), (t.y = t.y / c.scale.y);
            }
            for (let s = 0; s < this.sprites.length; s++) this.sprites[s].visible && this.updatePart(this.sprites[s], e, t);
        }
        updatePart(e, t, s) {
            const a = this.zmMap.normalizeVector({ x: s.x - e.x, y: s.y - e.y }),
                r = 300 * a.x - e.xSpeed,
                n = 300 * a.y - e.ySpeed;
            if (((e.xSpeed += r * t), (e.ySpeed += n * t), (e.x += e.xSpeed * t), (e.y += e.ySpeed * t), i(e.x, e.y, s.x, s.y) < 30 && ((e.visible = !1), (e.x = 100), (e.y = 100), this.animElement))) {
                const e = this.animElement;
                e.classList.toggle("levelup"),
                    setTimeout(function () {
                        e.classList.toggle("levelup");
                    }, 3e3);
            }
        }
        newPart(e, t) {
            if (!this.container.visible) return;
            const s = this.getSprite();
            (s.x = e), (s.y = t - 10), (s.visible = !0), s.scale.set(2, 2), (s.xSpeed = 0), (s.ySpeed = -100);
        }
    }
    class _e {
        constructor() {
            if (
                ((this.maxParts = 500),
                    (this.partCounter = 0),
                    (this.partsPerSplatter = 6),
                    (this.ecoPartsPerSplatter = 3),
                    (this.container = null),
                    (this.sprites = []),
                    (this.gravity = 100),
                    (this.spraySpeed = 20),
                    (this.fadeSpeed = 0.7),
                    (this.visibleParts = 0),
                    (this.viewableArea = null),
                    _e.instance)
            )
                return _e.instance;
            _e.instance = this;
        }
        getTexture(e) {
            const t = document.createElement("canvas");
            (t.width = 1), (t.height = 1);
            const s = t.getContext("2d");
            return (s.fillStyle = e), s.fillRect(0, 0, 1, 1), PIXI.Texture.from(t);
        }
        initialize() {
            if (
                ((this.gameModel = ne.getInstance()),
                    (this.viewableArea = G),
                    this.container || ((this.container = new PIXI.Container()), p.addChild(this.container), (this.texture = this.getTexture("#ff0000")), (this.plagueTexture = this.getTexture("#00ff00"))),
                    this.sprites.length < this.maxParts)
            )
                for (let e = 0; e < this.maxParts; e++) {
                    const e = new ht(this.texture);
                    this.sprites.push(e), (e.visible = !1), Math.random() > 0.5 && e.scale.set(2, 2), this.container.addChild(e);
                }
        }
        update(e) {
            if (this.gameModel.persistentData.particles) {
                (this.container.visible = !0), (this.visibleParts = 0);
                for (let t = 0; t < this.sprites.length; t++) this.sprites[t].visible && (this.updatePart(this.sprites[t], e), this.visibleParts++);
            } else this.container.visible = !1;
        }
        updatePart(e, t) {
            e.hitFloor ? ((e.alpha -= this.fadeSpeed * t), e.alpha <= 0 && (e.visible = !1)) : ((e.ySpeed += this.gravity * t), (e.x += e.xSpeed * t), (e.y += e.ySpeed * t), e.y >= e.floor && (e.hitFloor = !0));
        }
        newPart(e, t, s) {
            if (this.viewableArea.hideParticle(e, t)) return;
            const i = this.sprites[this.partCounter++];
            this.partCounter >= this.maxParts && (this.partCounter = 0),
                (i.texture = s ? this.plagueTexture : this.texture),
                (i.x = e),
                (i.y = t - (8 + 10 * Math.random())),
                (i.floor = t),
                (i.hitFloor = !1),
                (i.visible = !0),
                (i.alpha = 1),
                i.scale.set(1, 1),
                Math.random() > 0.5 && i.scale.set(2, 2);
            const a = Math.random() * (s ? 1.5 * this.spraySpeed : this.spraySpeed);
            (i.xSpeed = Math.random() > 0.5 ? -1 * a : a), (i.ySpeed = -1 * (s ? 1.5 * this.spraySpeed : this.spraySpeed));
        }
        newSplatter(e, t) {
            if (this.container.visible)
                if (this.visibleParts < 0.9 * this.maxParts) for (let s = 0; s < this.partsPerSplatter; s++) this.newPart(e, t, !1);
                else for (let s = 0; s < this.ecoPartsPerSplatter; s++) this.newPart(e, t, !1);
        }
        newPlagueSplatter(e, t) {
            if (this.container.visible) for (let s = 0; s < this.partsPerSplatter; s++) this.newPart(e, t, !0);
        }
    }
    class et extends J {
        constructor() {
            super(...arguments), (this.fadeTime = 0), (this.floor = 0), (this.rotSpeed = 0), (this.value = 1), (this.collector = null), (this.hitFloor = !1);
        }
    }
    class tt {
        constructor() {
            if (
                ((this.partsLimit = 100),
                    (this.partsPerSplatter = 3),
                    (this.container = null),
                    (this.sprites = []),
                    (this.discardedSprites = []),
                    (this.uncollected = []),
                    (this.gravity = 100),
                    (this.spraySpeed = 20),
                    (this.fadeTime = 40),
                    (this.fadeSpeed = 0.2),
                    (this.fadeBones = !1),
                    (this.texture = null),
                    (this.gameModel = null),
                    tt.instance)
            )
                return tt.instance;
            tt.instance = this;
        }
        getTexture() {
            const e = document.createElement("canvas");
            (e.width = 4), (e.height = 1);
            const t = e.getContext("2d");
            return (t.fillStyle = "#dddddd"), t.fillRect(0, 0, 4, 1), PIXI.Texture.from(e);
        }
        initialize() {
            (this.gameModel = ne.getInstance()), this.container || ((this.container = new PIXI.Container()), p.addChild(this.container), (this.texture = this.getTexture()));
            for (let e = 0; e < this.sprites.length; e++) (this.sprites[e].value = 0), (this.sprites[e].visible = !1), this.container.removeChild(this.sprites[e]);
            this.discardedSprites = this.sprites.slice();
        }
        update(e) {
            const t = [];
            for (let s = 0; s < this.sprites.length; s++) this.sprites[s].visible && (this.updatePart(this.sprites[s], e), t.push(this.sprites[s]));
            (this.uncollected = t), (this.fadeBones = t.length > 200);
        }
        updatePart(e, t) {
            if (e.value <= 0) return (e.visible = !1), this.discardedSprites.push(e), void this.container.removeChild(e);
            e.hitFloor
                ? (this.fadeBones && (e.fadeTime -= t), e.fadeTime < 0 && !e.collector && ((e.alpha -= this.fadeSpeed * t), e.alpha <= 0 && ((e.visible = !1), this.discardedSprites.push(e), this.container.removeChild(e))))
                : ((e.ySpeed += this.gravity * t), (e.rotation += e.rotSpeed * t), (e.x += e.xSpeed * t), (e.y += e.ySpeed * t), e.y >= e.floor && (e.hitFloor = !0));
        }
        newPart(e, t, s) {
            let i = null;
            this.discardedSprites.length > 0 ? (i = this.discardedSprites.pop()) : ((i = new et(this.texture)), this.sprites.push(i)),
                this.container.addChild(i),
                (i.x = e),
                (i.y = t - (8 + 10 * Math.random())),
                (i.fadeTime = Math.random() * this.fadeTime),
                (i.rotation = 5 * Math.random()),
                (i.rotSpeed = 4 * Math.random() - 2),
                (i.floor = t),
                (i.hitFloor = !1),
                (i.collector = !1),
                (i.visible = !0),
                (i.value = s),
                (i.alpha = 1),
                i.scale.set(1, 1),
                Math.random() > 0.5 && i.scale.set(1.5, 1.5);
            const a = Math.random() * this.spraySpeed;
            (i.xSpeed = Math.random() > 0.5 ? -1 * a : a), (i.ySpeed = -1 * this.spraySpeed);
        }
        newBones(e, t) {
            if (this.gameModel.constructions.graveyard)
                if (this.sprites.length - this.discardedSprites.length > this.partsLimit) this.newPart(e, t, 3);
                else for (let s = 0; s < this.partsPerSplatter; s++) this.newPart(e, t, 1);
        }
    }
    class st extends PIXI.Sprite {
        constructor() {
            super(...arguments), (this.time = 0), (this.target = null);
        }
    }
    class it {
        constructor() {
            if (((this.sprites = []), (this.discardedSprites = []), (this.maxSprites = 10), (this.height = 20), (this.fadeSpeed = 4), it.instance)) return it.instance;
            it.instance = this;
        }
        initialize() {
            this.container ||
                ((this.container = new PIXI.Container()),
                    b.addChild(this.container),
                    (this.healTexture = PIXI.Texture.from("healing.png")),
                    (this.exclamationTexture = PIXI.Texture.from("exclamation.png")),
                    (this.radioTexture = PIXI.Texture.from("radio.png")),
                    (this.fireTexture = PIXI.Texture.from("fire.png")),
                    (this.shieldTexture = PIXI.Texture.from("shield.png")),
                    (this.poisonTexture = PIXI.Texture.from("poison.png")));
            for (let e = 0; e < this.sprites.length; e++) this.container.removeChild(this.sprites[e]);
            if (this.sprites.length < this.maxSprites)
                for (let e = 0; e < this.maxSprites; e++) {
                    const e = new st(this.exclamationTexture);
                    e.anchor.set(0.5, 1), this.sprites.push(e), (e.visible = !1);
                }
            this.discardedSprites = this.sprites.slice();
        }
        newIcon(e, t, s) {
            if (e.hasIcon) return;
            let i;
            this.discardedSprites.length > 0 ? (i = this.discardedSprites.pop()) : ((i = new st(this.exclamationTexture)), i.anchor.set(0.5, 1), this.sprites.push(i)),
                this.container.addChild(i),
                (i.texture = t),
                (i.target = e),
                (i.target.hasIcon = !0),
                (i.x = e.x),
                (i.y = e.y - this.height),
                (i.visible = !0),
                (i.time = s),
                (i.alpha = 1),
                i.scale.set(1.5, 1.5);
        }
        newHealing(e) {
            this.newIcon(e, this.healTexture, 1);
        }
        newExclamation(e) {
            this.newIcon(e, this.exclamationTexture, 2);
        }
        newRadio(e) {
            this.newIcon(e, this.radioTexture, 3);
        }
        newFire(e) {
            this.newIcon(e, this.fireTexture, 1);
        }
        newShield(e) {
            this.newIcon(e, this.shieldTexture, 1);
        }
        newPoison(e) {
            this.newIcon(e, this.poisonTexture, 1);
        }
        update(e) {
            for (let t = 0; t < this.sprites.length; t++) this.sprites[t].visible && this.updateSprite(this.sprites[t], e);
        }
        updateSprite(e, t) {
            (e.x = e.target.x), (e.y = e.target.y - this.height), (e.time -= t), e.time < 0 && ((e.alpha -= t * this.fadeSpeed), e.alpha < 0 && ((e.visible = !1), (e.target.hasIcon = !1), this.discardedSprites.push(e)));
        }
    }
    class at extends J {
        constructor() {
            super(...arguments), (this.plague = !1), (this.rocket = !1), (this.fireball = !1), (this.darkorb = !1), (this.target = null), (this.source = null), (this.hitbox = 0), (this.damage = 0);
        }
    }
    class rt {
        constructor() {
            if (
                ((this.zombies = new ZombieManager()),
                    (this.humans = new HumanManager()),
                    (this.graveyard = new Oe()),
                    (this.army = new Te()),
                    (this.maxParts = 20),
                    (this.speed = 150),
                    (this.hitbox = 12),
                    (this.sprites = []),
                    (this.discardedSprites = []),
                    (this.fadeSpeed = 0.2),
                    rt.instance)
            )
                return rt.instance;
            rt.instance = this;
        }
        getTexture() {
            const e = document.createElement("canvas");
            (e.width = 1), (e.height = 1);
            const t = e.getContext("2d");
            return (t.fillStyle = "#ffffff"), t.fillRect(0, 0, 1, 1), PIXI.Texture.from(e);
        }
        getFireballTexture() {
            const e = document.createElement("canvas");
            (e.width = 8), (e.height = 8);
            const t = e.getContext("2d"),
                s = t.createRadialGradient(4, 4, 0, 4, 4, 4);
            return s.addColorStop(0, "rgba(255,255,0,1)"), s.addColorStop(0.8, "rgba(255,0,0,0.2)"), s.addColorStop(1, "rgba(255,0,0,0)"), (t.fillStyle = s), t.fillRect(0, 0, 8, 8), PIXI.Texture.from(e);
        }
        getDarkOrbTexture() {
            const e = document.createElement("canvas");
            (e.width = 8), (e.height = 8);
            const t = e.getContext("2d"),
                s = t.createRadialGradient(4, 4, 0, 4, 4, 4);
            return s.addColorStop(0, "rgba(0,0,0,1)"), s.addColorStop(0.8, "rgba(0,0,128,0.5)"), s.addColorStop(1, "rgba(0,0,255,0)"), (t.fillStyle = s), t.fillRect(0, 0, 8, 8), PIXI.Texture.from(e);
        }
        initialize() {
            this.texture || ((this.texture = this.getTexture()), (this.fireballTexture = this.getFireballTexture()), (this.darkOrbTexture = this.getDarkOrbTexture()));
            for (let e = 0; e < this.sprites.length; e++) g.removeChild(this.sprites[e]);
            if (this.sprites.length < this.maxParts)
                for (let e = 0; e < this.maxParts; e++) {
                    const e = new at(this.texture);
                    (e.scale.x = e.scale.y = 2), (e.visible = !1), this.sprites.push(e);
                }
            this.discardedSprites = this.sprites.slice();
        }
        update(e) {
            for (let t = 0; t < this.sprites.length; t++) this.sprites[t].visible && this.updatePart(this.sprites[t], e);
        }
        updatePart(e, t) {
            i(e.x, e.y + 8, e.target.x, e.target.y) < e.hitbox
                ? (e.plague
                    ? (this.zombies.inflictPlague(e.target), this.humans.damageHuman(e.target, e.damage))
                    : e.fireball
                        ? (this.humans.burnHuman(e.target, e.damage), this.humans.damageHuman(e.target, e.damage))
                        : e.darkorb
                            ? e.target.flags.dead || (this.humans.damageHuman(e.target, e.damage), (e.target.timer.dogStun = 5), new Xe().orbHit(e.target))
                            : !e.rocket && e.target.bulletReflect && Math.random() < e.target.bulletReflect
                                ? this.newBullet(e.target, e.source, e.damage, !1, !1, !1)
                                : e.rocket
                                    ? (e.target.graveyard && this.graveyard.damageGraveyard(e.damage), this.army.droneExplosion(e.target.x, e.target.y, null, e.damage))
                                    : (e.target.zombie && this.zombies.damageZombie(e.target, e.damage, e.source), e.target.human && this.humans.damageHuman(e.target, e.damage)),
                    (e.visible = !1),
                    this.discardedSprites.push(e),
                    g.removeChild(e))
                : ((e.x += e.xSpeed * t), (e.y += e.ySpeed * t), (e.zIndex = e.y)),
                e.darkorb ? (e.alpha -= this.fadeSpeed * t * 0.4) : (e.alpha -= this.fadeSpeed * t),
                e.alpha < 0 && ((e.visible = !1), this.discardedSprites.push(e), g.removeChild(e));
        }
        newBullet(e, t, s, i = !1, a = !1, r = !1, n = !1) {
            let o;
            this.discardedSprites.length > 0 ? (o = this.discardedSprites.pop()) : ((o = new at(this.texture)), (o.scale.x = o.scale.y = 2), this.sprites.push(o)),
                g.addChild(o),
                (o.texture = n ? this.darkOrbTexture : r ? this.fireballTexture : this.texture),
                (o.source = e),
                (o.x = e.x),
                (o.y = e.y - 8),
                i && (o.y = e.y - 12),
                (o.target = t),
                (o.damage = s),
                (o.visible = !0),
                (o.alpha = 1),
                (o.hitbox = a ? 1.5 * this.hitbox : this.hitbox),
                (o.plague = i),
                (o.rocket = a),
                (o.fireball = r),
                (o.darkorb = n),
                (o.tint = i ? 65280 : a ? 16772096 : 16777215),
                (o.scale.x = o.scale.y = a ? 2.5 : 2),
                r && (o.scale.x = o.scale.y = 1.5);
            const h = t.x - o.x,
                l = t.y - 8 - o.y,
                d = Math.abs(h),
                c = Math.abs(l);
            let u = 1 / Math.max(d, c);
            (u *= 1.29289 - (d + c) * u * 0.29289), (o.xSpeed = h * u * this.speed), (o.ySpeed = l * u * this.speed), (o.rotation = Math.atan2(o.ySpeed, o.xSpeed));
        }
    }
    class nt extends _ {
        constructor() {
            if ((super(), (this.viewableArea = null), nt.instance)) return nt.instance;
            (nt.instance = this), (this.create = (e) => new J(e));
        }
        getTexture() {
            const e = document.createElement("canvas");
            (e.width = 32), (e.height = 32);
            const t = e.getContext("2d"),
                s = t.createRadialGradient(16, 16, 0, 16, 16, 16);
            return s.addColorStop(0, "rgba(255,255,255,1)"), s.addColorStop(0.8, "rgba(255,255,128,0.2)"), s.addColorStop(1, "rgba(255,180,0,0)"), (t.fillStyle = s), t.fillRect(0, 0, 32, 32), PIXI.Texture.from(e);
        }
        initialize() {
            (this.viewableArea = G), this.texture || ((this.texture = this.getTexture()), (this.container = new PIXI.Container()), b.addChild(this.container), this.setup(this.container, this.texture));
        }
        update(e) {
            for (let t = 0; t < this.sprites.length; t++) this.sprites[t].visible && this.updatePart(this.sprites[t], e);
        }
        updatePart(e, t) {
            e.visible && ((e.scale.y -= 10 * t), (e.scale.x = e.scale.y), e.scale.x <= 0 && this.discardSprite(e));
        }
        newBlast(e, t) {
            if (this.viewableArea.hideParticle(e, t)) return;
            const s = this.getSprite();
            s.anchor.set(0.5, 0.5), (s.tint = 16777215), (s.scale.x = s.scale.y = 2), (s.x = e), (s.y = t), new ot().newCloud(e, t);
        }
        newZombieBlast(e, t) {
            if (this.viewableArea.hideParticle(e, t)) return;
            const s = this.getSprite();
            s.anchor.set(0.5, 0.5), (s.tint = 11206570), (s.scale.x = s.scale.y = 2), (s.x = e), (s.y = t), new ot().newCloud(e, t);
        }
        newDetonateBlast(e, t) {
            if (this.viewableArea.hideParticle(e, t)) return;
            const s = this.getSprite();
            s.anchor.set(0.5, 0.5), (s.tint = 6750054), (s.scale.x = s.scale.y = 2.5), (s.x = e), (s.y = t), new ot().newCloud(e, t);
        }
        newDroneBlast(e, t) {
            const s = this.getSprite();
            s.anchor.set(0.5, 0.5), (s.scale.x = s.scale.y = 2), (s.tint = 16777215), (s.x = e), (s.y = t), new ot().newDroneCloud(e, t);
        }
    }
    class ot extends _ {
        constructor() {
            if ((super(), (this.tint = 16777215), (this.viewableArea = null), (this.allowTint = !1), (this.gameModel = null), (this.sizeVariance = 0.2), ot.instance)) return ot.instance;
            (ot.instance = this), (this.create = (e) => new J(e));
        }
        getTexture() {
            const e = document.createElement("canvas");
            (e.width = 12), (e.height = 12);
            const t = e.getContext("2d");
            (t.shadowBlur = 5), (t.shadowColor = "white");
            const s = t.createRadialGradient(6, 6, 0, 6, 6, 4);
            return s.addColorStop(0, "rgba(255,255,255,0.05)"), s.addColorStop(0.5, "rgba(255,255,255,0.1)"), s.addColorStop(1, "rgba(255,255,255,0)"), (t.fillStyle = s), t.fillRect(0, 0, 12, 12), PIXI.Texture.from(e);
        }
        initialize() {
            (this.gameModel = ne.getInstance()),
                (this.viewableArea = G),
                (this.allowTint = this.gameModel.app && this.gameModel.app.renderer && 1 == this.gameModel.app.renderer.type),
                this.texture || (this.setup(new PIXI.Container(), this.getTexture()), b.addChild(this.container));
        }
        update(e) {
            if (this.gameModel.persistentData.particles) {
                this.container.visible = !0;
                for (let t = 0; t < this.sprites.length; t++) this.sprites[t].visible && this.updatePart(this.sprites[t], e);
            } else this.container.visible = !1;
        }
        updatePart(e, t) {
            (e.scale.y -= 1.5 * t), (e.scale.x = e.scale.y), (e.y += e.ySpeed * t), e.scale.x <= 0 && this.discardSprite(e);
        }
        newSmoke(e, t, s = 0) {
            if (this.viewableArea.hideParticle(e, t)) return;
            const i = this.getSprite();
            this.allowTint && (i.tint = this.tint),
                (i.ySpeed = -30),
                i.anchor.set(0.5, 0.5),
                (i.scale.x = i.scale.y = 1.6 - this.sizeVariance + Math.random() * this.sizeVariance * 2),
                (i.visible = !0),
                (i.x = e - s + Math.random() * s * 2),
                (i.y = t - s + Math.random() * s * 2);
        }
        newFireSmoke(e, t) {
            this.container.visible && ((this.tint = 16777215), this.newSmoke(e, t, 3));
        }
        newCloud(e, t) {
            if (this.container.visible) {
                this.tint = 65280;
                for (let s = 0; s < 10; s++) this.newSmoke(e, t, 16);
            }
        }
        newDroneCloud(e, t) {
            if (this.container.visible) {
                this.tint = 16777215;
                for (let s = 0; s < 10; s++) this.newSmoke(e, t, 24);
            }
        }
        newZombieSpawnCloud(e, t) {
            if (this.container.visible) {
                this.tint = 65280;
                for (let s = 0; s < 5; s++) this.newSmoke(e, t, 6);
            }
        }
    }
    class ht extends J {
        constructor() {
            super(...arguments), (this.hitFloor = !1);
        }
    }
    class lt extends _ {
        constructor() {
            if ((super(), (this.partsPerSplatter = 15), (this.gravity = 100), (this.spraySpeed = 50), (this.fadeSpeed = 0.7), (this.viewableArea = G), lt.instance)) return lt.instance;
            (lt.instance = this), (this.create = (e) => new ht(e));
        }
        getTexture() {
            const e = document.createElement("canvas");
            (e.width = 5), (e.height = 1);
            const t = e.getContext("2d");
            return (t.fillStyle = "#FFFFFF"), t.fillRect(0, 0, 5, 1), PIXI.Texture.from(e);
        }
        initialize() {
            (this.gameModel = ne.getInstance()), (this.viewableArea = G), this.container || ((this.container = new PIXI.Container()), p.addChild(this.container), (this.texture = this.getTexture()), this.setup(this.container, this.texture));
        }
        update(e) {
            if (this.gameModel.persistentData.particles) {
                this.container.visible = !0;
                for (let t = 0; t < this.sprites.length; t++) this.sprites[t].visible && this.updatePart(this.sprites[t], e);
            } else this.container.visible = !1;
        }
        updatePart(e, t) {
            e.hitFloor
                ? ((e.alpha -= this.fadeSpeed * t), e.alpha <= 0 && this.discardSprite(e))
                : ((e.ySpeed += this.gravity * t), (e.x += e.xSpeed * t), (e.y += e.ySpeed * t), e.y >= e.floor && (e.hitFloor = !0), (e.rotation += e.rotSpeed * t));
        }
        newPart(e, t, s) {
            if (!this.container.visible) return;
            if (this.viewableArea.hideParticle(e, t)) return;
            const i = this.getSprite();
            (i.tint = s), (i.x = e), (i.y = t - (8 + 10 * Math.random())), (i.floor = t), (i.hitFloor = !1), (i.rotation = 5 * Math.random()), (i.rotSpeed = 4 * Math.random() - 2), (i.alpha = 1), i.scale.set(2, 2);
            const a = Math.random() * this.spraySpeed;
            (i.xSpeed = Math.random() > 0.5 ? -1 * a : a), (i.ySpeed = -1 * (10 + Math.random() * this.spraySpeed));
        }
        newFragmentExplosion(e, t, s) {
            if (this.container.visible) for (let i = 0; i < this.partsPerSplatter; i++) this.newPart(e, t, s);
        }
    }
    const dt = new Xe(),
        ct = new ZombieManager(),
        ut = new Ue(),
        pt = new CreatureFactory(),
        gt = new SpellManager(),
        mt = "Golem Mastery",
        bt = "Zombie Mastery",
        ft = "Skeleton Mastery",
        yt = "Spell Mastery";
    class xt {
        constructor(e, t, s, i, a, r) {
            (this.id = 0),
                (this.maxPoints = 0),
                (this.active = function () {
                    return dt.talents[this.id] && dt.talents[this.id] > 0;
                }),
                (this.full = function () {
                    return dt.talents[this.id] && 10 == dt.talents[this.id];
                }),
                (this.reset = function () {
                    dt.talents[this.id] = 0;
                }),
                (this.max = function () {
                    (dt.talents[this.id] = this.maxPoints), dt.getAvailablePoints() < 0 && (dt.talents[this.id] += dt.getAvailablePoints());
                }),
                (this.set = function (e) {
                    dt.talents[this.id] || (dt.talents[this.id] = 0),
                        (e < 0 || (e > 0 && dt.getAvailablePoints() > 0)) && ((dt.talents[this.id] += e), dt.talents[this.id] < 0 && (dt.talents[this.id] = 0), dt.talents[this.id] > this.maxPoints && (dt.talents[this.id] = this.maxPoints));
                }),
                (this.id = e),
                (this.name = t),
                (this.description = r),
                (this.group = s),
                (this.maxPoints = i),
                (this.apply = a);
        }
    }
    class vt {
        constructor(e, t) {
            (this.talents = []), (this.name = e), (this.class = t);
        }
    }
    const St = [
        new xt(
            1,
            "Efficiency",
            mt,
            10,
            function () {
                pt.creatureCostReduction = 1;
                const e = dt.talents[this.id];
                e && e > 0 && (pt.creatureCostReduction -= 0.05 * e);
            },
            function () {
                const e = dt.talents[this.id];
                return e && e > 0 ? `Golem upgrade and summoning cost reduced by ${5 * e}%` : "Reduces golem upgrade and summoning cost by 5%";
            }
        ),
        new xt(
            2,
            "Thrifty",
            mt,
            10,
            function () {
                dt.killingBlowParts = 0;
                const e = dt.talents[this.id];
                e && e > 0 && (dt.killingBlowParts = 10 * e);
            },
            function () {
                const e = dt.talents[this.id];
                return e && e > 0 ? `Skeleton killing blows reward ${10 * e}% of your current parts per second` : "Skeleton killing blows reward 10% of your current parts per second";
            }
        ),
        new xt(
            3,
            "Fatal Bargain",
            mt,
            10,
            function () {
                (ut.refundChance = 0), (ct.refundChance = 0);
                const e = dt.talents[this.id];
                e && e > 0 && ((ut.refundChance = 0.08 * e), (ct.refundChance = 0.08 * e));
            },
            function () {
                const e = dt.talents[this.id];
                return e && e > 0 ? 8 * e + "% parts refund on golem death" : "Grants 8% parts refund on golem death";
            }
        ),
        new xt(
            4,
            "Recovery",
            yt,
            10,
            function () {
                gt.cooldownReduction = 1;
                const e = dt.talents[this.id];
                e && e > 0 && (gt.cooldownReduction = 1 - 0.05 * e);
            },
            function () {
                const e = dt.talents[this.id];
                return e && e > 0 ? `Spell cooldown time reduced by ${5 * e}%` : "Reduces spell cooldown time by 5%";
            }
        ),
        new xt(
            5,
            "Endurance",
            yt,
            10,
            function () {
                gt.timeExtension = 0;
                const e = dt.talents[this.id];
                e && e > 0 && (gt.timeExtension = e);
            },
            function () {
                const e = dt.talents[this.id];
                return e && e > 0 ? `Spell duration increased by ${e} seconds` : "Increases spell duration by 1 second";
            }
        ),
        new xt(
            6,
            "Conservation",
            yt,
            10,
            function () {
                gt.costReduction = 0;
                const e = dt.talents[this.id];
                e && e > 0 && (gt.costReduction = 5 * e);
            },
            function () {
                const e = dt.talents[this.id];
                return e && e > 0 ? `Spell cost reduced by ${5 * e} energy` : "Reduces spell cost by 5 energy";
            }
        ),
        new xt(
            7,
            "Shiny",
            ft,
            10,
            function () {
                dt.lootChanceMod = 1;
                const e = dt.talents[this.id];
                e && e > 0 && (dt.lootChanceMod = 1 + 0.1 * e);
            },
            function () {
                const e = dt.talents[this.id];
                return e && e > 0 ? `Rare loot chance increased by ${10 * e}%` : "Increases the chance for rare loot by 10%";
            }
        ),
        new xt(
            8,
            "Dark Orb",
            ft,
            10,
            function () {
                dt.darkorb = 0;
                const e = dt.talents[this.id];
                e && e > 0 && (dt.darkorb = 12 - e);
            },
            function () {
                const e = dt.talents[this.id];
                return e && e > 0 ? `Dark orb released every ${12 - e} seconds` : "Releases a dark orb of energy every 11 seconds";
            }
        ),
        new xt(
            9,
            "Bone Shield",
            ft,
            10,
            function () {
                dt.boneshield = 0;
                const e = dt.talents[this.id];
                e && e > 0 && (dt.boneshield = e);
            },
            function () {
                const e = dt.talents[this.id];
                return e && e > 0 ? `Gains a shield of ${e} bones every 10 seconds` : "Gain a shield of 1 bone to protect the skeleton every 10 seconds";
            }
        ),
        new xt(
            10,
            "Gigamutagen",
            bt,
            10,
            function () {
                ct.gigamutagen = 0;
                const e = dt.talents[this.id];
                e && e > 0 && (ct.gigamutagen = 14 - e);
            },
            function () {
                const e = dt.talents[this.id];
                return e && e > 0 ? `Gigazombie mutation every ${14 - e} seconds` : "Mutates a random zombie into a gigazombie every 13 seconds";
            }
        ),
        new xt(
            11,
            "Blood Pact",
            bt,
            10,
            function () {
                ct.bloodpact = 0;
                const e = dt.talents[this.id];
                e && e > 0 && (ct.bloodpact = 0.05 * e);
            },
            function () {
                const e = dt.talents[this.id];
                return e && e > 0 ? 5 * e + "% of zombie damage converted to blood" : "Converts an additional 5% of zombie damage to blood";
            }
        ),
        new xt(
            12,
            "Blood Born",
            bt,
            10,
            function () {
                ct.bloodborn = 0;
                const e = dt.talents[this.id];
                e && e > 0 && (ct.bloodborn = e);
            },
            function () {
                const e = dt.talents[this.id];
                return e && e > 0 ? `${e} seconds of additional 50% damage reduction` : "Grants 1 second of additional 50% damage reduction to newly spawned zombies";
            }
        ),
    ],
        Mt = [];
    function kt() {
        St.forEach((e) => {
            const t = dt.talents[e.id];
            t && t < 0 && (dt.talents[e.id] = 0);
        }),
            dt.talentPoints < dt.getUsedPoints() && wt(),
            St.forEach((e) => e.apply());
    }
    function wt() {
        dt.persistent.talentReset && (St.forEach((e) => e.reset()), (dt.persistent.talentReset = !1));
    }
    St.forEach((e) => {
        if (0 == Mt.filter((t) => t.name == e.group).length) {
            let t = "blood";
            e.group == mt && (t = "parts"), e.group == ft && (t = "bones"), e.group == yt && (t = "energy"), e.group == bt && (t = "brains"), Mt.push(new vt(e.group, t));
        }
        Mt.filter((t) => t.name == e.group)[0].talents.push(e), dt.talents[e.id] || (dt.talents[e.id] = 0);
    }),
        angular
            .module("zombieApp", [])
            .config(function ($sceDelegateProvider) {
                $sceDelegateProvider.resourceUrlWhitelist([
                    // Allow same origin resource loads.
                    'self',
                    // Allow loading from our assets domain. ** matches all subdomains.
                    'http://127.0.0.1:5501/**',
                    // Allow loading YouTube embeds.
                    'https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/**'
                ]);
            })
            .filter("decimal", function () {
                return r;
            })
            .filter("whole", function () {
                return n;
            })
            .config([
                "$compileProvider",
                function (e) {
                    e.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|javascript|data|blob):/), e.debugInfoEnabled(!1);
                },
            ])
            .controller("ZombieController", [
                "$scope",
                "$interval",
                "$document",
                function (e, t, s) {
                    const i = new Xe(),
                        a = new SpellManager(),
                        r = new se(),
                        o = new CreatureFactory(),
                        h = new oe(),
                        l = new de(),
                        c = this;
                    function u() {
                        const e = new Date().getTime();
                        !(function (e, t) {
                            c.model.update(e, t), c.updateMessages(e), c.sidePanels.factory && (c.factoryStats = r.factoryStats());
                        })(Math.min(1e3, Math.max(e - c.lastUpdate, 0)) / 1e3, e),
                            (c.lastUpdate = e);
                    }
                    (c.model = ne.getInstance()),
                        (c.skeleton = function () {
                            return i.persistent;
                        }),
                        (c.spells = a),
                        (c.keysPressed = Y),
                        (c.files = []),
                        (c.messageTimer = 4),
                        (c.message = !1),
                        (c.lastUpdate = 0),
                        (c.sidePanels = {}),
                        (c.upgrades = []),
                        (c.currentShopFilter = "blood"),
                        (c.currentConstructionFilter = "available"),
                        (c.graveyardTab = "minions"),
                        (c.trophyTab = "all"),
                        (c.factoryTab = "parts"),
                        (c.factoryStats = {}),
                        (c.moveTooltip = d),
                        (c.confirmMessage = ""),
                        (c.confirmCancel = function () {
                            c.confirmCallback = !1;
                        }),
                        (c.closeSidePanels = function () {
                            (c.currentShopFilter = "blood"),
                                (c.currentConstructionFilter = "available"),
                                (c.graveyardTab = "minions"),
                                (c.factoryTab = "parts"),
                                (c.sidePanels.options = !1),
                                (c.sidePanels.graveyard = !1),
                                (c.sidePanels.runesmith = !1),
                                (c.sidePanels.prestige = !1),
                                (c.sidePanels.construction = !1),
                                (c.sidePanels.shop = !1),
                                (c.sidePanels.open = !1),
                                (c.sidePanels.factory = !1),
                                (c.levelSelect.shown = !1);
                        }),
                        (c.openSidePanel = function (e) {
                            switch ((c.closeSidePanels(), e)) {
                                case "shop":
                                    c.filterShop(c.currentShopFilter), (c.sidePanels.shop = !0);
                                    break;
                                case "construction":
                                    c.filterConstruction(c.currentConstructionFilter), (c.sidePanels.construction = !0);
                                    break;
                                case "graveyard":
                                    (c.sidePanels.graveyard = !0), (c.graveyardTab = "minions"), (c.trophyTab = "all");
                                    break;
                                case "runesmith":
                                    c.sidePanels.runesmith = !0;
                                    break;
                                case "factory":
                                    (c.sidePanels.factory = !0), (c.upgrades = r.generators), (c.factoryStats = r.factoryStats()), c.factory.updateDelays();
                                    break;
                                case "prestige":
                                    (c.upgrades = h.prestigeUpgrades.filter((e) => 0 == e.cap || c.currentRank(e) < e.cap)),
                                        c.upgrades.push(...h.prestigeUpgrades.filter((e) => 0 !== e.cap && c.currentRank(e) >= e.cap)),
                                        (c.upgrades = c.upgrades.filter((e) => 115 !== e.id)),
                                        (c.sidePanels.prestige = !0);
                                    break;
                                case "options":
                                    (c.sidePanels.options = !0), c.model.downloadSaveGame();
                            }
                            c.sidePanels.open = !0;
                        }),
                        (c.graveyardTabSelect = function (e) {
                            (c.graveyardTab = e), "trophies" == e && ((c.trophies = l.getTrophyList()), (c.trophyTab = "all"));
                        }),
                        (c.trophyTabSelect = function (e) {
                            switch (((c.trophyTab = e), e)) {
                                case "all":
                                    c.trophies = l.getTrophyList();
                                    break;
                                case "collected":
                                    c.trophies = l.getTrophyList().filter((e) => e.owned);
                                    break;
                                case "uncollected":
                                    c.trophies = l.getTrophyList().filter((e) => !e.owned);
                                    break;
                                case "totals":
                                    c.trophies = l.getTrophyTotals();
                            }
                        }),
                        (c.filterShop = function (e) {
                            (c.currentShopFilter = e), (c.upgrades = h.getUpgrades(e));
                        }),
                        (c.filterConstruction = function (e) {
                            switch (((c.currentConstructionFilter = e), e)) {
                                case "available":
                                    c.upgrades = h.getAvailableConstructions();
                                    break;
                                case "completed":
                                    c.upgrades = h.getCompletedConstructions();
                            }
                        }),
                        (c.resetGame = function () {
                            (c.confirmMessage = "Are you sure you want to reset everything? If you have a cloud save it will also be deleted. Make sure you export your save game first."),
                                (c.confirmCallback = function () {
                                    c.model.resetData(), (c.confirmCallback = !1);
                                });
                        }),
                        (c.addBoneCollector = function () {
                            c.model.getEnergyRate() >= 1 && c.model.persistentData.boneCollectors++;
                        }),
                        (c.subtractBoneCollector = function () {
                            c.model.persistentData.boneCollectors > 0 && c.model.persistentData.boneCollectors--;
                        }),
                        (c.maxBoneCollectors = function () {
                            return Math.floor(c.model.getEnergyRate() + c.model.persistentData.boneCollectors);
                        }),
                        (c.setBoneCollectors = function (e) {
                            e >= 0 && c.model.getEnergyRate() >= e - c.model.persistentData.boneCollectors && (c.model.persistentData.boneCollectors = e);
                        }),
                        (c.setHarpies = function (e) {
                            ((e >= 0 && e < c.model.persistentData.harpies) || (c.model.getEnergyRate() >= 1 && e > 0)) && (c.model.persistentData.harpies = e);
                        }),
                        (c.maxHarpies = function () {
                            return Math.floor(c.model.getEnergyRate() + c.model.persistentData.harpies);
                        }),
                        (c.setGraveyardZombies = function (e) {
                            e <= c.maxGraveyardZombies() && e >= 0 && (c.model.persistentData.graveyardZombies = e);
                        }),
                        (c.maxGraveyardZombies = function () {
                            return Math.floor(c.model.energyMax / c.model.zombieCost);
                        }),
                        (c.upgradePrice = function (e) {
                            return c.sidePanels.factory && "prestigePoints" != e.costType ? r.purchasePrice(e) : h.upgradePrice(e);
                        }),
                        (c.factory = {
                            delays: [],
                            changeFactoryTab(e) {
                                (c.factoryTab = e), "parts" == e ? ((c.upgrades = r.generators), this.updateDelays()) : (c.upgrades = o.creatures);
                            },
                            buyGenerator(e) {
                                c.keysPressed.shift ? r.purchaseMaxGenerators(e) : r.purchaseGenerator(e), (c.factoryStats = r.factoryStats());
                            },
                            generatorPrice: (e) => r.purchasePrice(e),
                            creaturePrice: (e) => o.purchasePrice(e),
                            creatureLevelPrice: (e) => o.levelPrice(e),
                            creaturePercent(e) {
                                return Math.min(Math.round((c.model.persistentData.parts / this.creaturePrice(e)) * 100), 100);
                            },
                            creatureLevelPercent(e) {
                                return Math.min(Math.round((c.model.persistentData.parts / this.creatureLevelPrice(e)) * 100), 100);
                            },
                            buyCreature: (e) => o.startBuilding(e),
                            creatureTooExpensive: (e) => !o.canAffordCreature(e),
                            creatureButtonText(e) {
                                return e.building ? "Building..." : this.creatureTooExpensive(e) ? n(this.creaturePrice(e) - c.model.persistentData.parts) + " parts required" : "Build (" + n(this.creaturePrice(e)) + " parts)";
                            },
                            creatureLevelButtonText(e) {
                                return this.canLevelCreature(e) ? "Upgrade Level " + (e.level + 1) + " (" + n(this.creatureLevelPrice(e)) + " parts)" : n(this.creatureLevelPrice(e) - c.model.persistentData.parts) + " parts required";
                            },
                            canBuildCreature(e) {
                                return !this.creatureTooExpensive(e) && !e.building && o.creaturesBuildingCount() + c.model.creatureCount < c.model.creatureLimit;
                            },
                            canLevelCreature(e) {
                                return this.creatureLevelPrice(e) < c.model.persistentData.parts;
                            },
                            levelCreature(e) {
                                o.levelCreature(e);
                            },
                            autoBuild(e, t) {
                                e.autobuild + t >= 0 && e.autobuild + t <= c.model.creatureLimit && o.creatureAutoBuildNumber(e, t);
                            },
                            creatureStats: (e) => o.creatureStats(e),
                            updateDelays() {
                                this.delays = [];
                                for (let e = 0; e < r.generatorsApplied.length; e++) this.delays[r.generatorsApplied[e].id] = (-1 * (r.generatorsApplied[e].time - r.generatorsApplied[e].timeLeft)).toFixed(2);
                            },
                        }),
                        (c.levelSelect = {
                            shown: !1,
                            levelsPerPage: 50,
                            levels: [],
                            levelRanges: [],
                            start: 1,
                            showButton: () => c.model.persistentData.allTimeHighestLevel > 1,
                            show() {
                                this.shown
                                    ? (this.shown = !1)
                                    : (c.closeSidePanels(),
                                        (this.shown = !0),
                                        (this.level = c.model.levelInfo(c.model.level)),
                                        (this.start = Math.floor((this.level.level - 1) / this.levelsPerPage) * this.levelsPerPage + 1),
                                        this.populate());
                            },
                            populate() {
                                (this.levels = []),
                                    (this.levelRanges = []),
                                    this.start > this.levelsPerPage && this.levelRanges.push(this.start - this.levelsPerPage),
                                    this.levelRanges.push(this.start),
                                    this.start + this.levelsPerPage <= c.model.persistentData.allTimeHighestLevel + 1 && this.levelRanges.push(this.start + this.levelsPerPage);
                                for (let e = this.start; e < this.start + this.levelsPerPage; e++) this.levels.push(c.model.levelInfo(e));
                            },
                            selectRange(e) {
                                (this.start = e), this.populate();
                            },
                            select(e) {
                                this.level = e;
                            },
                            startLevel() {
                                c.model.startLevel(this.level.level), (this.shown = !1);
                            },
                        }),
                        (c.addToHomeScreen = function () {
                            c.model.deferredPrompt;
                        }),
                        (c.constructionPercent = function () {
                            if (c.model.persistentData.currentConstruction) {
                                const e = c.model.persistentData.currentConstruction.time - c.model.persistentData.currentConstruction.timeRemaining;
                                return Math.round((e / c.model.persistentData.currentConstruction.time) * 100);
                            }
                            return 0;
                        }),
                        (c.updateConstructionUpgrades = function () {
                            1 == c.sidePanels.construction && (c.upgrades = h.getAvailableConstructions());
                        }),
                        (c.startConstruction = function (e) {
                            h.startConstruction(e), (c.upgrades = h.getAvailableConstructions());
                        }),
                        (c.playPauseConstruction = function () {
                            h.playPauseConstruction();
                        }),
                        (c.cancelConstruction = function () {
                            (c.confirmMessage = "Are you sure you want to cancel construction? Used materials will not be refunded"),
                                (c.confirmCallback = function () {
                                    h.cancelConstruction(), (c.upgrades = h.getAvailableConstructions()), (c.confirmCallback = !1);
                                });
                        }),
                        (c.upgradeSubtitle = function (e) {
                            switch (e.type) {
                                case h.types.energyRate:
                                    return "+" + e.effect + " energy per second";
                                case h.types.energyCap:
                                    return "+" + e.effect + " max energy";
                                case h.types.bloodCap:
                                    return "+" + n(e.effect) + " max blood";
                                case h.types.bloodStoragePC:
                                    return "+" + Math.round(100 * e.effect) + "% max blood";
                                case h.types.bloodGainPC:
                                    return "+" + Math.round(100 * e.effect) + "% blood income";
                                case h.types.brainsGainPC:
                                    return "+" + Math.round(100 * e.effect) + "% brains income";
                                case h.types.bonesGainPC:
                                    return "+" + Math.round(100 * e.effect) + "% bones income";
                                case h.types.partsGainPC:
                                    return "+" + Math.round(100 * e.effect) + "% parts income";
                                case h.types.brainsStoragePC:
                                    return "+" + Math.round(100 * e.effect) + "% max brains";
                                case h.types.energyCost:
                                    return "-" + e.effect + " zombie energy cost";
                                case h.types.brainsCap:
                                    return "+" + e.effect + " max brains";
                                case h.types.damage:
                                    return "+" + e.effect + " zombie damage";
                                case h.types.speed:
                                    return "+" + e.effect + " zombie speed";
                                case h.types.health:
                                    return "+" + e.effect + " zombie health";
                                case h.types.brainRecoverChance:
                                    return "+" + Math.round(100 * e.effect) + "% chance to recover brain";
                                case h.types.riseFromTheDeadChance:
                                    return "+" + Math.round(100 * e.effect) + "% chance for corpse to become zombie";
                                case h.types.infectedBite:
                                    return "+" + Math.round(100 * e.effect) + "% chance for zombies to infect their targets";
                                case h.types.infectedBlast:
                                    return "+" + Math.round(100 * e.effect) + "% chance for zombies to explode on death";
                                case h.types.boneCollectorCapacity:
                                    return "+" + e.effect + " bone collector capacity";
                                case h.types.zombieDmgPC:
                                    return "+" + n(Math.round(100 * e.effect)) + "% zombie damage";
                                case h.types.zombieHealthPC:
                                    return "+" + n(Math.round(100 * e.effect)) + "% zombie health";
                                case h.types.bonesRate:
                                    return "+" + e.effect + " bones per second";
                                case h.types.brainsRate:
                                    return "+" + e.effect + " brains per second";
                                case h.types.plagueDamage:
                                    return "+" + n(e.effect) + " plague damage";
                                case h.types.plagueTicks:
                                    return "+" + n(e.effect) + " plague ticks";
                                case h.types.spitDistance:
                                    return "+" + e.effect + " spit distance";
                                case h.types.blastHealing:
                                    return "+" + Math.round(100 * e.effect) + "% plague healing";
                                case h.types.plagueArmor:
                                    return "+" + Math.round(100 * e.effect) + "% damage reduction";
                                case h.types.monsterLimit:
                                    return "+" + e.effect + " creature limit";
                                case h.types.runicSyphon:
                                    return "+" + Math.round(100 * e.effect) + "% runic syphon";
                                case h.types.gigazombies:
                                    return "Unlock more gigazombies";
                                case h.types.bulletproof:
                                    return "+" + Math.round(100 * e.effect) + "% earth golem bullet reflect";
                                case h.types.harpySpeed:
                                    return "+" + e.effect + " harpy speed";
                                case h.types.harpyBombs:
                                    return "+" + e.effect + " harpy bombs";
                                case h.types.tankBuster:
                                    return "Anti tank harpies";
                                case h.types.spikeDelay:
                                    return "-20% spike delay";
                            }
                            return "";
                        }),
                        (c.currentRank = function (e) {
                            return c.sidePanels.factory ? r.currentRank(e) : h.currentRank(e);
                        }),
                        (c.currentRankConstruction = function (e) {
                            return h.currentRankConstruction(e);
                        }),
                        (c.upgradeTooExpensive = function (e) {
                            return c.sidePanels.factory ? !r.canAffordGenerator(e) : !h.canAffordUpgrade(e) || (0 != e.cap && h.currentRank(e) >= e.cap);
                        }),
                        (c.requiredForUpgrade = function (e) {
                            const t = c.upgradePrice(e);
                            switch (e.costType) {
                                case h.costs.energy:
                                    return n(t - c.model.energy) + " energy required";
                                case h.costs.blood:
                                case r.costs.blood:
                                    return n(t - c.model.persistentData.blood) + " blood required";
                                case h.costs.brains:
                                    return n(t - c.model.persistentData.brains) + " brains required";
                                case h.costs.bones:
                                    return n(t - c.model.persistentData.bones) + " bones required";
                                case h.costs.prestigePoints:
                                    return n(t - c.model.persistentData.prestigePointsToSpend) + " prestige points required";
                                case r.costs.parts:
                                    return n(t - c.model.persistentData.parts) + " parts required";
                            }
                        }),
                        (c.purchaseText = function (e) {
                            if (c.keysPressed.shift) {
                                if (c.sidePanels.factory) {
                                    const t = r.upgradeMaxAffordable(e);
                                    return "Purchase " + t + " (" + n(r.upgradeMaxPrice(e, t)) + " " + c.costTranslate(e.costType) + ")";
                                }
                                {
                                    const t = h.upgradeMaxAffordable(e);
                                    return "Purchase " + t + " (" + n(h.upgradeMaxPrice(e, t)) + " " + c.costTranslate(e.costType) + ")";
                                }
                            }
                            return "Purchase (" + n(c.upgradePrice(e)) + " " + c.costTranslate(e.costType) + ")";
                        }),
                        (c.costTranslate = function (e) {
                            return e == h.costs.prestigePoints ? "points" : e;
                        }),
                        (c.buyUpgrade = function (e) {
                            c.keysPressed.shift ? h.purchaseMaxUpgrades(e) : h.purchaseUpgrade(e);
                        }),
                        (c.destroyUpgrade = function (e) {
                            h.removeUpgrade(e);
                        }),
                        (c.upgradeStatInfo = function (e) {
                            return h.displayStatValue(e);
                        }),
                        (c.startGame = function () {
                            c.model.startGame();
                        }),
                        (c.nextLevel = function () {
                            c.model.nextLevel();
                        }),
                        (c.toggleAutoStart = function () {
                            c.model.persistentData.autoStart ? (c.model.persistentData.autoStart = !1) : (c.model.persistentData.autoStart = !0);
                        }),
                        (c.toggleResolution = function (e) {
                            (c.model.persistentData.resolution = e), c.model.setResolution(c.model.persistentData.resolution);
                        }),
                        (c.getResolution = function () {
                            return c.model.persistentData.resolution || 1;
                        }),
                        (c.toggleZoomButtons = function () {
                            c.model.persistentData.zoomButtons = !c.model.persistentData.zoomButtons;
                        }),
                        (c.zoom = function (e) {
                            c.model.zoom(e);
                        }),
                        (c.resetZoom = function () {
                            c.model.centerGameContainer(!0);
                        }),
                        (c.toggleShowFps = function () {
                            c.model.persistentData.showfps = !c.model.persistentData.showfps;
                        }),
                        (c.toggleParticles = function () {
                            c.model.persistentData.particles = !c.model.persistentData.particles;
                        }),
                        (c.isShowPrestige = function () {
                            return void 0 !== c.model.persistentData.prestigePointsEarned && c.model.persistentData.allTimeHighestLevel > 5;
                        }),
                        (c.doPrestige = function () {
                            (c.confirmMessage = "Are you sure you want to prestige now?"),
                                (c.confirmCallback = function () {
                                    c.model.prestige(), (c.confirmCallback = !1);
                                });
                        }),
                        (c.constructionLeadsTo = function (e) {
                            return h.constructionLeadsTo(e);
                        }),
                        (c.howToPlay = [
                            "Energy refills over time. You need 10 energy to spawn a zombie by clicking on the ground.",
                            "Hold shift or control to spawn multiple zombies with a single click.",
                            "Whenever one of your zombies attacks a human you will collect some blood.",
                            "Killing a human or turning them into a zombie will earn you 1 brain.",
                            "You can spend these currencies in the shop to purchase upgrades for your zombie horde.",
                            "Hold shift to buy the maximum affordable number of upgrades.",
                            "The world can be dragged with the mouse to explore it. Or by using the WASD or arrow keys.",
                            "You can zoom in and out using your mouse wheel. Pinch to zoom on mobile.",
                        ]),
                        (c.updateMessages = function (e) {
                            c.message
                                ? ((c.messageTimer -= e), c.model.messageQueue.length > 0 && (c.messageTimer -= e), c.messageTimer < 0 && ((c.message = !1), (c.messageTimer = 4)))
                                : c.model.messageQueue.length > 0 && ((c.message = c.model.messageQueue.shift()), (c.messageTimer = 4));
                        }),
                        (c.infusionAmount = 1e3),
                        (c.infusionMax = !1),
                        (c.infuseRune = function (e, t) {
                            if (c.infusionMax)
                                switch (t) {
                                    case "blood":
                                        h.infuseRune(e, t, c.model.persistentData.blood);
                                        break;
                                    case "brains":
                                        h.infuseRune(e, t, c.model.persistentData.brains);
                                        break;
                                    case "bones":
                                        h.infuseRune(e, t, c.model.persistentData.bones);
                                }
                            else h.infuseRune(e, t, c.infusionAmount);
                        }),
                        (c.shatterPercent = function (e) {
                            return h.shatterPercent(e);
                        }),
                        (c.shatterBloodCost = function (e) {
                            return h.shatterBloodCost(e);
                        }),
                        (c.shatterSatiate = function (e, t) {
                            h.infuseRune(e, "blood", this.shatterBloodCost(t));
                        }),
                        (c.canShatter = function () {
                            return h.canShatter();
                        }),
                        (c.doShatter = function () {
                            h.doShatter();
                        }),
                        (c.shatterEffect = function () {
                            return 100 * h.shatterEffect();
                        }),
                        (c.infuseButtonText = function () {
                            return c.infusionMax ? "Max" : n(c.infusionAmount);
                        }),
                        (c.energyPercent = function () {
                            return Math.min(Math.round((c.model.energy / c.model.energyMax) * 100), 100);
                        }),
                        (c.bloodPercent = function () {
                            return Math.min(Math.round((c.model.persistentData.blood / c.model.bloodMax) * 100), 100);
                        }),
                        (c.brainsPercent = function () {
                            return Math.min(Math.round((c.model.persistentData.brains / c.model.brainsMax) * 100), 100);
                        }),
                        (c.costAboveCap = function (e, t) {
                            switch (e.costType) {
                                case "blood":
                                    if (t > c.model.bloodMax) return "Blood capacity too low";
                                    break;
                                case "brains":
                                    if (t > c.model.brainsMax) return "Brains capacity too low";
                            }
                            return !1;
                        }),
                        (c.upgradeButtonText = function (e) {
                            if (0 != e.cap && c.currentRank(e) >= e.cap) return "Sold Out";
                            const t = c.upgradePrice(e);
                            if (c.upgradeTooExpensive(e)) {
                                return c.costAboveCap(e, t) || c.requiredForUpgrade(e);
                            }
                            return c.purchaseText(e, t);
                        }),
                        (c.upgradePercent = function (e) {
                            switch (e.costType) {
                                case "blood":
                                    return Math.round(100 * Math.min(1, c.model.persistentData.blood / c.upgradePrice(e)));
                                case "brains":
                                    return Math.round(100 * Math.min(1, c.model.persistentData.brains / c.upgradePrice(e)));
                                case "bones":
                                    return Math.round(100 * Math.min(1, c.model.persistentData.bones / c.upgradePrice(e)));
                                case "parts":
                                    return Math.round(100 * Math.min(1, c.model.persistentData.parts / c.upgradePrice(e)));
                                case "prestigePoints":
                                    return Math.round(100 * Math.min(1, c.model.persistentData.prestigePointsToSpend / c.upgradePrice(e)));
                            }
                        }),
                        (c.skeletonTimer = function () {
                            return i.skeletonTimer();
                        }),
                        (c.skeletonMenu = {
                            isShown: !1,
                            tab: "inventory",
                            changeTab(e) {
                                this.tab = e;
                            },
                            equipped: [],
                            show() {
                                (this.tab = "inventory"), (this.upgrade = h.prestigeUpgrades.filter((e) => 115 == e.id)[0]), (this.upgrades = Mt), (this.isShown = !this.isShown), this.isShown && this.updateEquippedItems();
                            },
                            acceptOffer() {
                                i.acceptOffer(), (this.isShown = !1);
                            },
                            anotherOffer: () => i.persistent.skeletons > 0 && c.model.persistentData.trophies.length >= 20 * i.persistent.xpRate,
                            trophies: () => (i.persistent.skeletons > 0 ? ` - ${c.model.persistentData.trophies.length} / ${20 * i.persistent.xpRate} Trophies` : ""),
                            talentPoints: () => i.talentPoints,
                            talentsAssigned: () => i.getUsedPoints(),
                            talentValue: (e) => i.talents[e.id] + " / " + e.maxPoints,
                            talentSet(e, t) {
                                e.set(t), kt();
                            },
                            talentReset(e) {
                                e.reset(), kt();
                            },
                            canReset: () => i.persistent.talentReset,
                            talentsReset() {
                                wt(), kt();
                            },
                            talentMax(e) {
                                e.max(), kt();
                            },
                            xpPercent: () => Math.round(100 * Math.min(1, c.skeleton().xp / i.xpForNextLevel())),
                            xpForNextLevel: () => i.xpForNextLevel(),
                            xpRate: () => 100 * i.persistent.xpRate,
                            isAlive: () => i.isAlive(),
                            timer: () => Math.ceil(i.skeletonTimer()),
                            updateEquippedItems() {
                                this.equipped = [];
                                const e = i.persistent.items.filter((e) => e.q && e.s == i.lootPositions.helmet.id);
                                e.length > 0 ? this.equipped.push([e[0]]) : this.equipped.push([{ name: "Helmet Slot", s: i.lootPositions.helmet.id, id: -1 }]);
                                const t = [],
                                    s = i.persistent.items.filter((e) => e.q && e.s == i.lootPositions.sword.id);
                                s.length > 0 ? t.push(s[0]) : t.push({ name: "Sword Slot", s: i.lootPositions.sword.id, id: -2 });
                                const a = i.persistent.items.filter((e) => e.q && e.s == i.lootPositions.chest.id);
                                a.length > 0 ? t.push(a[0]) : t.push({ name: "Chest Slot", s: i.lootPositions.chest.id, id: -3 });
                                const r = i.persistent.items.filter((e) => e.q && e.s == i.lootPositions.shield.id);
                                r.length > 0 ? t.push(r[0]) : t.push({ name: "Shield Slot", s: i.lootPositions.shield.id, id: -4 }), this.equipped.push(t);
                                const n = [],
                                    o = i.persistent.items.filter((e) => e.q && e.s == i.lootPositions.gloves.id);
                                o.length > 0 ? n.push(o[0]) : n.push({ name: "Gloves Slot", s: i.lootPositions.gloves.id, id: -5 });
                                const h = i.persistent.items.filter((e) => e.q && e.s == i.lootPositions.legs.id);
                                h.length > 0 ? n.push(h[0]) : n.push({ name: "Legs Slot", s: i.lootPositions.legs.id, id: -6 });
                                const l = i.persistent.items.filter((e) => e.q && e.s == i.lootPositions.boots.id);
                                l.length > 0 ? n.push(l[0]) : n.push({ name: "Boots Slot", s: i.lootPositions.boots.id, id: -7 }), this.equipped.push(n), this.equipped.push([{ name: "Destroy Items", s: -1, id: -8 }]);
                            },
                            inventoryItems: () => i.persistent.items.filter((e) => !e.q).sort((e, t) => t.r * t.l - e.r * e.l),
                            itemName: (e) => e.name || i.getLootName(e),
                            itemSubName(e) {
                                if (!e.name)
                                    switch (e.r) {
                                        case i.rarity.common:
                                            return "Common level " + e.l + " " + this.itemType(e);
                                        case i.rarity.rare:
                                            return "Rare level " + e.l + " " + this.itemType(e);
                                        case i.rarity.epic:
                                            return "Epic level " + e.l + " " + this.itemType(e);
                                        case i.rarity.legendary:
                                            return "Legendary level " + e.l + " " + this.itemType(e);
                                    }
                                if (-1 == e.s) return "Click this to destroy all non-equipped items (legendary items will not be automatically destroyed). Or drag items here to destroy them.";
                            },
                            itemStats: (e) => i.getLootStats(e),
                            itemEffects: (e) => i.getSpecialEffects(e),
                            itemType(e) {
                                switch (e.s) {
                                    case -1:
                                        return "trash";
                                    case i.lootPositions.helmet.id:
                                        return "helmet";
                                    case i.lootPositions.chest.id:
                                        return "chest";
                                    case i.lootPositions.gloves.id:
                                        return "gloves";
                                    case i.lootPositions.legs.id:
                                        return "legs";
                                    case i.lootPositions.boots.id:
                                        return "boots";
                                    case i.lootPositions.sword.id:
                                        return "sword";
                                    case i.lootPositions.shield.id:
                                        return "shield";
                                }
                            },
                            itemClass: (e) => (e.name ? "empty" : i.getLootClass(e)),
                            itemById(e) {
                                let t = null;
                                return (
                                    i.persistent.items.forEach(function (s) {
                                        s.id == e && (t = s);
                                    }),
                                    t
                                );
                            },
                            itemDropped(e, t) {
                                let s = null;
                                i.persistent.items.forEach(function (t) {
                                    t.id == e && (s = t);
                                }),
                                    -1 == t
                                        ? i.destroyItem(s)
                                        : (s.s == t &&
                                            (i.persistent.items.forEach(function (e) {
                                                e.s == t && (e.q = !1);
                                            }),
                                                (s.q = !0),
                                                h.applyUpgrades()),
                                            this.updateEquippedItems());
                            },
                            equipItem(e) {
                                i.persistent.items.forEach(function (t) {
                                    t.s == e.s && (t.q = !1);
                                }),
                                    (e.q = !0),
                                    h.applyUpgrades(),
                                    this.updateEquippedItems();
                            },
                            trashAll() {
                                (c.confirmMessage = "Are you sure you want to destroy all non-equipped items? You will earn " + n(i.xpForItems()) + " xp"),
                                    (c.confirmCallback = function () {
                                        (c.confirmCallback = !1), i.destroyAllItems();
                                    });
                            },
                        }),
                        s.ready(function () {
                            (e.updatePromise = t(u, 200)), (h.angularModel = c), kt();
                        });
                },
            ])
            .directive("levelSelect", function () {
                return { templateUrl: "https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/templates/levelselect.html?updatedAt=1757690626766" };
            })
            .directive("levelStats", function () {
                return { templateUrl: "https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/templates/levelstats.html?updatedAt=1757690626800" };
            })
            .directive("graveyardMenu", function () {
                return { templateUrl: "https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/templates/graveyardmenu.html?updatedAt=1757690627709" };
            })
            .directive("runesmithMenu", function () {
                return { templateUrl: "https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/templates/runesmithmenu.html?updatedAt=1757690625356" };
            })
            .directive("optionsMenu", function () {
                return { templateUrl: "https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/templates/optionsmenu.html?updatedAt=1757690627346" };
            })
            .directive("shopMenu", function () {
                return { templateUrl: "https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/templates/shopmenu.html?updatedAt=1757690627231" };
            })
            .directive("constructionMenu", function () {
                return { templateUrl: "https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/templates/constructionmenu.html?updatedAt=1757690626018" };
            })
            .directive("prestigeMenu", function () {
                return { templateUrl: "https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/templates/prestigemenu.html?updatedAt=1757690628363" };
            })
            .directive("championsHoldMenu", function () {
                return { templateUrl: "https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/templates/championshold.html?updatedAt=1757690627737" };
            })
            .directive("factoryMenu", function () {
                return { templateUrl: "https://ik.imagekit.io/9370901/Spy%20Mode/incremancer/templates/factorymenu.html?updatedAt=1757690627584" };
            })
            .directive("customOnChange", function () {
                return {
                    restrict: "A",
                    link: function (e, t, s) {
                        const i = e.$eval(s.customOnChange);
                        t.on("change", i),
                            t.on("$destroy", function () {
                                t.off();
                            });
                    },
                };
            })
            .directive("draggableItem", [
                "$rootScope",
                function (e) {
                    return {
                        restrict: "A",
                        link: function (t, s, i, a) {
                            const r = t.item.id;
                            "true" == i.draggableItem &&
                                (angular.element(s).attr("draggable", "true"),
                                    s.bind("dragstart", function (t) {
                                        document.getElementById("champ-hold").classList.toggle("no-tooltip"), t.dataTransfer.setData("text", r);
                                        const i = s[0].getBoundingClientRect();
                                        t.dataTransfer.setDragImage(s[0], i.width / 2, i.height / 2),
                                            e.$emit("item-drag-start", r),
                                            setTimeout(function () {
                                                angular.element(s)[0].style.opacity = "0.3";
                                            });
                                    }),
                                    s.bind("dragend", function (t) {
                                        document.getElementById("champ-hold").classList.toggle("no-tooltip"), (angular.element(s)[0].style.opacity = ""), e.$emit("item-drag-end", r);
                                    }));
                        },
                    };
                },
            ])
            .directive("droppableTarget", [
                "$rootScope",
                function (e) {
                    return {
                        restrict: "A",
                        link: function (t, s, i, a) {
                            const r = t.item.s;
                            s.bind("dragover", function (e) {
                                return e.preventDefault && e.preventDefault(), (e.dataTransfer.dropEffect = "move"), !1;
                            }),
                                s.bind("dragenter", function (e) {
                                    e.target && e.target.classList && e.target.classList.contains("icon") && angular.element(e.target.parentElement).addClass("over");
                                }),
                                s.bind("dragleave", function (e) {
                                    e.target && e.target.classList && e.target.classList.contains("icon") && angular.element(e.target.parentElement).removeClass("over");
                                }),
                                s.bind("drop", function (e) {
                                    e.preventDefault && e.preventDefault(), e.stopPropagation && e.stopPropagation(), e.target.classList.contains("icon") && angular.element(e.target.parentElement).removeClass("over");
                                    const s = e.dataTransfer.getData("text"),
                                        i = t.zm.skeletonMenu.itemById(s);
                                    if (i) {
                                        const e = t.zm.skeletonMenu.itemType(i);
                                        document.getElementsByClassName("equipped")[0].classList.remove(e);
                                    }
                                    t.zm.skeletonMenu.itemDropped(s, r);
                                }),
                                e.$on("item-drag-start", function (e, s) {
                                    const i = t.zm.skeletonMenu.itemById(s);
                                    if (i) {
                                        const e = t.zm.skeletonMenu.itemType(i);
                                        document.getElementsByClassName("equipped")[0].classList.add(e);
                                    }
                                }),
                                e.$on("item-drag-end", function (e, s) {
                                    const i = t.zm.skeletonMenu.itemById(s);
                                    if (i) {
                                        const e = t.zm.skeletonMenu.itemType(i);
                                        document.getElementsByClassName("equipped")[0].classList.remove(e);
                                    }
                                });
                        },
                    };
                },
            ]),
        (Incremancer = e);
})();
//# sourceMappingURL=bundle.js.map


